"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root21 = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply2(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array4, setter, iteratee, accumulator) {
          var index4 = -1, length3 = array4 == null ? 0 : array4.length;
          while (++index4 < length3) {
            var value = array4[index4];
            setter(accumulator, value, iteratee(value), array4);
          }
          return accumulator;
        }
        function arrayEach(array4, iteratee) {
          var index4 = -1, length3 = array4 == null ? 0 : array4.length;
          while (++index4 < length3) {
            if (iteratee(array4[index4], index4, array4) === false) {
              break;
            }
          }
          return array4;
        }
        function arrayEachRight(array4, iteratee) {
          var length3 = array4 == null ? 0 : array4.length;
          while (length3--) {
            if (iteratee(array4[length3], length3, array4) === false) {
              break;
            }
          }
          return array4;
        }
        function arrayEvery(array4, predicate) {
          var index4 = -1, length3 = array4 == null ? 0 : array4.length;
          while (++index4 < length3) {
            if (!predicate(array4[index4], index4, array4)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array4, predicate) {
          var index4 = -1, length3 = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
          while (++index4 < length3) {
            var value = array4[index4];
            if (predicate(value, index4, array4)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array4, value) {
          var length3 = array4 == null ? 0 : array4.length;
          return !!length3 && baseIndexOf(array4, value, 0) > -1;
        }
        function arrayIncludesWith(array4, value, comparator) {
          var index4 = -1, length3 = array4 == null ? 0 : array4.length;
          while (++index4 < length3) {
            if (comparator(value, array4[index4])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array4, iteratee) {
          var index4 = -1, length3 = array4 == null ? 0 : array4.length, result = Array(length3);
          while (++index4 < length3) {
            result[index4] = iteratee(array4[index4], index4, array4);
          }
          return result;
        }
        function arrayPush(array4, values2) {
          var index4 = -1, length3 = values2.length, offset = array4.length;
          while (++index4 < length3) {
            array4[offset + index4] = values2[index4];
          }
          return array4;
        }
        function arrayReduce(array4, iteratee, accumulator, initAccum) {
          var index4 = -1, length3 = array4 == null ? 0 : array4.length;
          if (initAccum && length3) {
            accumulator = array4[++index4];
          }
          while (++index4 < length3) {
            accumulator = iteratee(accumulator, array4[index4], index4, array4);
          }
          return accumulator;
        }
        function arrayReduceRight(array4, iteratee, accumulator, initAccum) {
          var length3 = array4 == null ? 0 : array4.length;
          if (initAccum && length3) {
            accumulator = array4[--length3];
          }
          while (length3--) {
            accumulator = iteratee(accumulator, array4[length3], length3, array4);
          }
          return accumulator;
        }
        function arraySome(array4, predicate) {
          var index4 = -1, length3 = array4 == null ? 0 : array4.length;
          while (++index4 < length3) {
            if (predicate(array4[index4], index4, array4)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array4, predicate, fromIndex, fromRight) {
          var length3 = array4.length, index4 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index4-- : ++index4 < length3) {
            if (predicate(array4[index4], index4, array4)) {
              return index4;
            }
          }
          return -1;
        }
        function baseIndexOf(array4, value, fromIndex) {
          return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array4, value, fromIndex, comparator) {
          var index4 = fromIndex - 1, length3 = array4.length;
          while (++index4 < length3) {
            if (comparator(array4[index4], value)) {
              return index4;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array4, iteratee) {
          var length3 = array4 == null ? 0 : array4.length;
          return length3 ? baseSum(array4, iteratee) / length3 : NAN;
        }
        function baseProperty(key) {
          return function(object2) {
            return object2 == null ? undefined2 : object2[key];
          };
        }
        function basePropertyOf(object2) {
          return function(key) {
            return object2 == null ? undefined2 : object2[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index4, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index4, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array4, comparer) {
          var length3 = array4.length;
          array4.sort(comparer);
          while (length3--) {
            array4[length3] = array4[length3].value;
          }
          return array4;
        }
        function baseSum(array4, iteratee) {
          var result, index4 = -1, length3 = array4.length;
          while (++index4 < length3) {
            var current = iteratee(array4[index4]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index4 = -1, result = Array(n);
          while (++index4 < n) {
            result[index4] = iteratee(index4);
          }
          return result;
        }
        function baseToPairs(object2, props) {
          return arrayMap(props, function(key) {
            return [key, object2[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object2, props) {
          return arrayMap(props, function(key) {
            return object2[key];
          });
        }
        function cacheHas(cache2, key) {
          return cache2.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index4 = -1, length3 = strSymbols.length;
          while (++index4 < length3 && baseIndexOf(chrSymbols, strSymbols[index4], 0) > -1) {
          }
          return index4;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index4 = strSymbols.length;
          while (index4-- && baseIndexOf(chrSymbols, strSymbols[index4], 0) > -1) {
          }
          return index4;
        }
        function countHolders(array4, placeholder) {
          var length3 = array4.length, result = 0;
          while (length3--) {
            if (array4[length3] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object2, key) {
          return object2 == null ? undefined2 : object2[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data2, result = [];
          while (!(data2 = iterator.next()).done) {
            result.push(data2.value);
          }
          return result;
        }
        function mapToArray(map4) {
          var index4 = -1, result = Array(map4.size);
          map4.forEach(function(value, key) {
            result[++index4] = [key, value];
          });
          return result;
        }
        function overArg(func, transform2) {
          return function(arg) {
            return func(transform2(arg));
          };
        }
        function replaceHolders(array4, placeholder) {
          var index4 = -1, length3 = array4.length, resIndex = 0, result = [];
          while (++index4 < length3) {
            var value = array4[index4];
            if (value === placeholder || value === PLACEHOLDER) {
              array4[index4] = PLACEHOLDER;
              result[resIndex++] = index4;
            }
          }
          return result;
        }
        function setToArray(set5) {
          var index4 = -1, result = Array(set5.size);
          set5.forEach(function(value) {
            result[++index4] = value;
          });
          return result;
        }
        function setToPairs(set5) {
          var index4 = -1, result = Array(set5.size);
          set5.forEach(function(value) {
            result[++index4] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array4, value, fromIndex) {
          var index4 = fromIndex - 1, length3 = array4.length;
          while (++index4 < length3) {
            if (array4[index4] === value) {
              return index4;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array4, value, fromIndex) {
          var index4 = fromIndex + 1;
          while (index4--) {
            if (array4[index4] === value) {
              return index4;
            }
          }
          return index4;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index4 = string.length;
          while (index4-- && reWhitespace.test(string.charAt(index4))) {
          }
          return index4;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root21 : _25.defaults(root21.Object(), context, _25.pick(root21, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root21._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol3 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : undefined2, symIterator = Symbol3 ? Symbol3.iterator : undefined2, symToStringTag = Symbol3 ? Symbol3.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root21.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root21.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root21.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol3 ? Symbol3.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = /* @__PURE__ */ function() {
            function object2() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object2.prototype = proto;
              var result2 = new object2();
              object2.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array4 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array4), isRight = dir < 0, arrLength = isArr ? array4.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length3 = end - start2, index4 = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length3, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length3 && takeCount == length3) {
              return baseWrapperValue(array4, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length3-- && resIndex < takeCount) {
                index4 += dir;
                var iterIndex = -1, value = array4[index4];
                while (++iterIndex < iterLength) {
                  var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type2 = data2.type, computed = iteratee2(value);
                  if (type2 == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type2 == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index4 = -1, length3 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index4 < length3) {
              var entry = entries[index4];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data2 = this.__data__;
            if (nativeCreate) {
              var result2 = data2[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data2, key) ? data2[key] : undefined2;
          }
          function hashHas(key) {
            var data2 = this.__data__;
            return nativeCreate ? data2[key] !== undefined2 : hasOwnProperty.call(data2, key);
          }
          function hashSet(key, value) {
            var data2 = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data2[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index4 = -1, length3 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index4 < length3) {
              var entry = entries[index4];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data2 = this.__data__, index4 = assocIndexOf(data2, key);
            if (index4 < 0) {
              return false;
            }
            var lastIndex = data2.length - 1;
            if (index4 == lastIndex) {
              data2.pop();
            } else {
              splice.call(data2, index4, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data2 = this.__data__, index4 = assocIndexOf(data2, key);
            return index4 < 0 ? undefined2 : data2[index4][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data2 = this.__data__, index4 = assocIndexOf(data2, key);
            if (index4 < 0) {
              ++this.size;
              data2.push([key, value]);
            } else {
              data2[index4][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index4 = -1, length3 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index4 < length3) {
              var entry = entries[index4];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data2 = getMapData(this, key), size3 = data2.size;
            data2.set(key, value);
            this.size += data2.size == size3 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values3) {
            var index4 = -1, length3 = values3 == null ? 0 : values3.length;
            this.__data__ = new MapCache();
            while (++index4 < length3) {
              this.add(values3[index4]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data2 = this.__data__ = new ListCache(entries);
            this.size = data2.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data2 = this.__data__, result2 = data2["delete"](key);
            this.size = data2.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data2 = this.__data__;
            if (data2 instanceof ListCache) {
              var pairs2 = data2.__data__;
              if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
                pairs2.push([key, value]);
                this.size = ++data2.size;
                return this;
              }
              data2 = this.__data__ = new MapCache(pairs2);
            }
            data2.set(key, value);
            this.size = data2.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length3 = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length3)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array4) {
            var length3 = array4.length;
            return length3 ? array4[baseRandom(0, length3 - 1)] : undefined2;
          }
          function arraySampleSize(array4, n) {
            return shuffleSelf(copyArray(array4), baseClamp(n, 0, array4.length));
          }
          function arrayShuffle(array4) {
            return shuffleSelf(copyArray(array4));
          }
          function assignMergeValue(object2, key, value) {
            if (value !== undefined2 && !eq(object2[key], value) || value === undefined2 && !(key in object2)) {
              baseAssignValue(object2, key, value);
            }
          }
          function assignValue(object2, key, value) {
            var objValue = object2[key];
            if (!(hasOwnProperty.call(object2, key) && eq(objValue, value)) || value === undefined2 && !(key in object2)) {
              baseAssignValue(object2, key, value);
            }
          }
          function assocIndexOf(array4, key) {
            var length3 = array4.length;
            while (length3--) {
              if (eq(array4[length3][0], key)) {
                return length3;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object2, source2) {
            return object2 && copyObject(source2, keys(source2), object2);
          }
          function baseAssignIn(object2, source2) {
            return object2 && copyObject(source2, keysIn(source2), object2);
          }
          function baseAssignValue(object2, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object2, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object2[key] = value;
            }
          }
          function baseAt(object2, paths) {
            var index4 = -1, length3 = paths.length, result2 = Array2(length3), skip2 = object2 == null;
            while (++index4 < length3) {
              result2[index4] = skip2 ? undefined2 : get5(object2, paths[index4]);
            }
            return result2;
          }
          function baseClamp(number5, lower2, upper) {
            if (number5 === number5) {
              if (upper !== undefined2) {
                number5 = number5 <= upper ? number5 : upper;
              }
              if (lower2 !== undefined2) {
                number5 = number5 >= lower2 ? number5 : lower2;
              }
            }
            return number5;
          }
          function baseClone(value, bitmask, customizer, key, object2, stack2) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object2 ? customizer(value, key, object2, stack2) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object2) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object2 ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack2 || (stack2 = new Stack());
            var stacked = stack2.get(value);
            if (stacked) {
              return stacked;
            }
            stack2.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
            });
            return result2;
          }
          function baseConforms(source2) {
            var props = keys(source2);
            return function(object2) {
              return baseConformsTo(object2, source2, props);
            };
          }
          function baseConformsTo(object2, source2, props) {
            var length3 = props.length;
            if (object2 == null) {
              return !length3;
            }
            object2 = Object2(object2);
            while (length3--) {
              var key = props[length3], predicate = source2[key], value = object2[key];
              if (value === undefined2 && !(key in object2) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array4, values3, iteratee2, comparator) {
            var index4 = -1, includes2 = arrayIncludes, isCommon = true, length3 = array4.length, result2 = [], valuesLength = values3.length;
            if (!length3) {
              return result2;
            }
            if (iteratee2) {
              values3 = arrayMap(values3, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values3.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values3 = new SetCache(values3);
            }
            outer:
              while (++index4 < length3) {
                var value = array4[index4], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values3[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values3, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index4, collection2) {
              result2 = !!predicate(value, index4, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array4, iteratee2, comparator) {
            var index4 = -1, length3 = array4.length;
            while (++index4 < length3) {
              var value = array4[index4], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array4, value, start2, end) {
            var length3 = array4.length;
            start2 = toInteger(start2);
            if (start2 < 0) {
              start2 = -start2 > length3 ? 0 : length3 + start2;
            }
            end = end === undefined2 || end > length3 ? length3 : toInteger(end);
            if (end < 0) {
              end += length3;
            }
            end = start2 > end ? 0 : toLength(end);
            while (start2 < end) {
              array4[start2++] = value;
            }
            return array4;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index4, collection2) {
              if (predicate(value, index4, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array4, depth, predicate, isStrict, result2) {
            var index4 = -1, length3 = array4.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index4 < length3) {
              var value = array4[index4];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object2, iteratee2) {
            return object2 && baseFor(object2, iteratee2, keys);
          }
          function baseForOwnRight(object2, iteratee2) {
            return object2 && baseForRight(object2, iteratee2, keys);
          }
          function baseFunctions(object2, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object2[key]);
            });
          }
          function baseGet(object2, path2) {
            path2 = castPath(path2, object2);
            var index4 = 0, length3 = path2.length;
            while (object2 != null && index4 < length3) {
              object2 = object2[toKey(path2[index4++])];
            }
            return index4 && index4 == length3 ? object2 : undefined2;
          }
          function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object2);
            return isArray(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other2) {
            return value > other2;
          }
          function baseHas(object2, key) {
            return object2 != null && hasOwnProperty.call(object2, key);
          }
          function baseHasIn(object2, key) {
            return object2 != null && key in Object2(object2);
          }
          function baseInRange(number5, start2, end) {
            return number5 >= nativeMin(start2, end) && number5 < nativeMax(start2, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length3 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array4 = arrays[othIndex];
              if (othIndex && iteratee2) {
                array4 = arrayMap(array4, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array4.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length3 >= 120 && array4.length >= 120) ? new SetCache(othIndex && array4) : undefined2;
            }
            array4 = arrays[0];
            var index4 = -1, seen = caches[0];
            outer:
              while (++index4 < length3 && result2.length < maxLength) {
                var value = array4[index4], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache2 = caches[othIndex];
                    if (!(cache2 ? cacheHas(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object2, setter, iteratee2, accumulator) {
            baseForOwn(object2, function(value, key, object3) {
              setter(accumulator, iteratee2(value), key, object3);
            });
            return accumulator;
          }
          function baseInvoke(object2, path2, args) {
            path2 = castPath(path2, object2);
            object2 = parent(object2, path2);
            var func = object2 == null ? object2 : object2[toKey(last(path2))];
            return func == null ? undefined2 : apply2(func, object2, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other2, bitmask, customizer, stack2) {
            if (value === other2) {
              return true;
            }
            if (value == null || other2 == null || !isObjectLike(value) && !isObjectLike(other2)) {
              return value !== value && other2 !== other2;
            }
            return baseIsEqualDeep(value, other2, bitmask, customizer, baseIsEqual, stack2);
          }
          function baseIsEqualDeep(object2, other2, bitmask, customizer, equalFunc, stack2) {
            var objIsArr = isArray(object2), othIsArr = isArray(other2), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other2);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object2)) {
              if (!isBuffer(other2)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack2 || (stack2 = new Stack());
              return objIsArr || isTypedArray(object2) ? equalArrays(object2, other2, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other2, objTag, bitmask, customizer, equalFunc, stack2);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other2, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other2.value() : other2;
                stack2 || (stack2 = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack2 || (stack2 = new Stack());
            return equalObjects(object2, other2, bitmask, customizer, equalFunc, stack2);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object2, source2, matchData, customizer) {
            var index4 = matchData.length, length3 = index4, noCustomizer = !customizer;
            if (object2 == null) {
              return !length3;
            }
            object2 = Object2(object2);
            while (index4--) {
              var data2 = matchData[index4];
              if (noCustomizer && data2[2] ? data2[1] !== object2[data2[0]] : !(data2[0] in object2)) {
                return false;
              }
            }
            while (++index4 < length3) {
              data2 = matchData[index4];
              var key = data2[0], objValue = object2[key], srcValue = data2[1];
              if (noCustomizer && data2[2]) {
                if (objValue === undefined2 && !(key in object2)) {
                  return false;
                }
              } else {
                var stack2 = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object2, source2, stack2);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity6;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object2) {
            if (!isPrototype(object2)) {
              return nativeKeys(object2);
            }
            var result2 = [];
            for (var key in Object2(object2)) {
              if (hasOwnProperty.call(object2, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object2) {
            if (!isObject(object2)) {
              return nativeKeysIn(object2);
            }
            var isProto = isPrototype(object2), result2 = [];
            for (var key in object2) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object2, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other2) {
            return value < other2;
          }
          function baseMap(collection, iteratee2) {
            var index4 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index4] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source2) {
            var matchData = getMatchData(source2);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object2) {
              return object2 === source2 || baseIsMatch(object2, source2, matchData);
            };
          }
          function baseMatchesProperty(path2, srcValue) {
            if (isKey(path2) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path2), srcValue);
            }
            return function(object2) {
              var objValue = get5(object2, path2);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object2, source2, srcIndex, customizer, stack2) {
            if (object2 === source2) {
              return;
            }
            baseFor(source2, function(srcValue, key) {
              stack2 || (stack2 = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object2, source2, key, srcIndex, baseMerge, customizer, stack2);
              } else {
                var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source2, stack2) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object2, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object2, source2, key, srcIndex, mergeFunc, customizer, stack2) {
            var objValue = safeGet(object2, key), srcValue = safeGet(source2, key), stacked = stack2.get(srcValue);
            if (stacked) {
              assignMergeValue(object2, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source2, stack2) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack2.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
              stack2["delete"](srcValue);
            }
            assignMergeValue(object2, key, newValue);
          }
          function baseNth(array4, n) {
            var length3 = array4.length;
            if (!length3) {
              return;
            }
            n += n < 0 ? length3 : 0;
            return isIndex(n, length3) ? array4[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity6];
            }
            var index4 = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index4, "value": value };
            });
            return baseSortBy(result2, function(object2, other2) {
              return compareMultiple(object2, other2, orders);
            });
          }
          function basePick(object2, paths) {
            return basePickBy(object2, paths, function(value, path2) {
              return hasIn(object2, path2);
            });
          }
          function basePickBy(object2, paths, predicate) {
            var index4 = -1, length3 = paths.length, result2 = {};
            while (++index4 < length3) {
              var path2 = paths[index4], value = baseGet(object2, path2);
              if (predicate(value, path2)) {
                baseSet(result2, castPath(path2, object2), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path2) {
            return function(object2) {
              return baseGet(object2, path2);
            };
          }
          function basePullAll(array4, values3, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index4 = -1, length3 = values3.length, seen = array4;
            if (array4 === values3) {
              values3 = copyArray(values3);
            }
            if (iteratee2) {
              seen = arrayMap(array4, baseUnary(iteratee2));
            }
            while (++index4 < length3) {
              var fromIndex = 0, value = values3[index4], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array4) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array4, fromIndex, 1);
              }
            }
            return array4;
          }
          function basePullAt(array4, indexes2) {
            var length3 = array4 ? indexes2.length : 0, lastIndex = length3 - 1;
            while (length3--) {
              var index4 = indexes2[length3];
              if (length3 == lastIndex || index4 !== previous) {
                var previous = index4;
                if (isIndex(index4)) {
                  splice.call(array4, index4, 1);
                } else {
                  baseUnset(array4, index4);
                }
              }
            }
            return array4;
          }
          function baseRandom(lower2, upper) {
            return lower2 + nativeFloor(nativeRandom() * (upper - lower2 + 1));
          }
          function baseRange(start2, end, step, fromRight) {
            var index4 = -1, length3 = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length3);
            while (length3--) {
              result2[fromRight ? length3 : ++index4] = start2;
              start2 += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start2) {
            return setToString(overRest(func, start2, identity6), func + "");
          }
          function baseSample(collection) {
            return arraySample(values2(collection));
          }
          function baseSampleSize(collection, n) {
            var array4 = values2(collection);
            return shuffleSelf(array4, baseClamp(n, 0, array4.length));
          }
          function baseSet(object2, path2, value, customizer) {
            if (!isObject(object2)) {
              return object2;
            }
            path2 = castPath(path2, object2);
            var index4 = -1, length3 = path2.length, lastIndex = length3 - 1, nested = object2;
            while (nested != null && ++index4 < length3) {
              var key = toKey(path2[index4]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object2;
              }
              if (index4 != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject(objValue) ? objValue : isIndex(path2[index4 + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object2;
          }
          var baseSetData = !metaMap ? identity6 : function(func, data2) {
            metaMap.set(func, data2);
            return func;
          };
          var baseSetToString = !defineProperty ? identity6 : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant2(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values2(collection));
          }
          function baseSlice(array4, start2, end) {
            var index4 = -1, length3 = array4.length;
            if (start2 < 0) {
              start2 = -start2 > length3 ? 0 : length3 + start2;
            }
            end = end > length3 ? length3 : end;
            if (end < 0) {
              end += length3;
            }
            length3 = start2 > end ? 0 : end - start2 >>> 0;
            start2 >>>= 0;
            var result2 = Array2(length3);
            while (++index4 < length3) {
              result2[index4] = array4[index4 + start2];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index4, collection2) {
              result2 = predicate(value, index4, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array4, value, retHighest) {
            var low = 0, high = array4 == null ? low : array4.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array4[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array4, value, identity6, retHighest);
          }
          function baseSortedIndexBy(array4, value, iteratee2, retHighest) {
            var low = 0, high = array4 == null ? 0 : array4.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array4[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array4, iteratee2) {
            var index4 = -1, length3 = array4.length, resIndex = 0, result2 = [];
            while (++index4 < length3) {
              var value = array4[index4], computed = iteratee2 ? iteratee2(value) : value;
              if (!index4 || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array4, iteratee2, comparator) {
            var index4 = -1, includes2 = arrayIncludes, length3 = array4.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length3 >= LARGE_ARRAY_SIZE) {
              var set6 = iteratee2 ? null : createSet(array4);
              if (set6) {
                return setToArray(set6);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index4 < length3) {
                var value = array4[index4], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object2, path2) {
            path2 = castPath(path2, object2);
            object2 = parent(object2, path2);
            return object2 == null || delete object2[toKey(last(path2))];
          }
          function baseUpdate(object2, path2, updater, customizer) {
            return baseSet(object2, path2, updater(baseGet(object2, path2)), customizer);
          }
          function baseWhile(array4, predicate, isDrop, fromRight) {
            var length3 = array4.length, index4 = fromRight ? length3 : -1;
            while ((fromRight ? index4-- : ++index4 < length3) && predicate(array4[index4], index4, array4)) {
            }
            return isDrop ? baseSlice(array4, fromRight ? 0 : index4, fromRight ? index4 + 1 : length3) : baseSlice(array4, fromRight ? index4 + 1 : 0, fromRight ? length3 : index4);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action2) {
              return action2.func.apply(action2.thisArg, arrayPush([result3], action2.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length3 = arrays.length;
            if (length3 < 2) {
              return length3 ? baseUniq(arrays[0]) : [];
            }
            var index4 = -1, result2 = Array2(length3);
            while (++index4 < length3) {
              var array4 = arrays[index4], othIndex = -1;
              while (++othIndex < length3) {
                if (othIndex != index4) {
                  result2[index4] = baseDifference(result2[index4] || array4, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values3, assignFunc) {
            var index4 = -1, length3 = props.length, valsLength = values3.length, result2 = {};
            while (++index4 < length3) {
              var value = index4 < valsLength ? values3[index4] : undefined2;
              assignFunc(result2, props[index4], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity6;
          }
          function castPath(value, object2) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object2) ? [value] : stringToPath(toString(value));
          }
          var castRest = baseRest;
          function castSlice(array4, start2, end) {
            var length3 = array4.length;
            end = end === undefined2 ? length3 : end;
            return !start2 && end >= length3 ? array4 : baseSlice(array4, start2, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id2) {
            return root21.clearTimeout(id2);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length3 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length3) : new buffer.constructor(length3);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other2) {
            if (value !== other2) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other2 !== undefined2, othIsNull = other2 === null, othIsReflexive = other2 === other2, othIsSymbol = isSymbol(other2);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other2 || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other2 || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object2, other2, orders) {
            var index4 = -1, objCriteria = object2.criteria, othCriteria = other2.criteria, length3 = objCriteria.length, ordersLength = orders.length;
            while (++index4 < length3) {
              var result2 = compareAscending(objCriteria[index4], othCriteria[index4]);
              if (result2) {
                if (index4 >= ordersLength) {
                  return result2;
                }
                var order = orders[index4];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object2.index - other2.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source2, array4) {
            var index4 = -1, length3 = source2.length;
            array4 || (array4 = Array2(length3));
            while (++index4 < length3) {
              array4[index4] = source2[index4];
            }
            return array4;
          }
          function copyObject(source2, props, object2, customizer) {
            var isNew = !object2;
            object2 || (object2 = {});
            var index4 = -1, length3 = props.length;
            while (++index4 < length3) {
              var key = props[index4];
              var newValue = customizer ? customizer(object2[key], source2[key], key, object2, source2) : undefined2;
              if (newValue === undefined2) {
                newValue = source2[key];
              }
              if (isNew) {
                baseAssignValue(object2, key, newValue);
              } else {
                assignValue(object2, key, newValue);
              }
            }
            return object2;
          }
          function copySymbols(source2, object2) {
            return copyObject(source2, getSymbols(source2), object2);
          }
          function copySymbolsIn(source2, object2) {
            return copyObject(source2, getSymbolsIn(source2), object2);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object2, sources) {
              var index4 = -1, length3 = sources.length, customizer = length3 > 1 ? sources[length3 - 1] : undefined2, guard = length3 > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length3--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length3 < 3 ? undefined2 : customizer;
                length3 = 1;
              }
              object2 = Object2(object2);
              while (++index4 < length3) {
                var source2 = sources[index4];
                if (source2) {
                  assigner(object2, source2, index4, customizer);
                }
              }
              return object2;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length3 = collection.length, index4 = fromRight ? length3 : -1, iterable = Object2(collection);
              while (fromRight ? index4-- : ++index4 < length3) {
                if (iteratee2(iterable[index4], index4, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object2, iteratee2, keysFunc) {
              var index4 = -1, iterable = Object2(object2), props = keysFunc(object2), length3 = props.length;
              while (length3--) {
                var key = props[fromRight ? length3 : ++index4];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object2;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root21 && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length3 = arguments.length, args = Array2(length3), index4 = length3, placeholder = getHolder(wrapper);
              while (index4--) {
                args[index4] = arguments[index4];
              }
              var holders = length3 < 3 && args[0] !== placeholder && args[length3 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length3 -= holders.length;
              if (length3 < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length3
                );
              }
              var fn = this && this !== root21 && this instanceof wrapper ? Ctor : func;
              return apply2(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index4 = findIndexFunc(collection, predicate, fromIndex);
              return index4 > -1 ? iterable[iteratee2 ? collection[index4] : index4] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length3 = funcs.length, index4 = length3, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index4--) {
                var func = funcs[index4];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index4 = wrapper ? index4 : length3;
              while (++index4 < length3) {
                func = funcs[index4];
                var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined2;
                if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
                  wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index5 = 0, result2 = length3 ? funcs[index5].apply(this, args) : value;
                while (++index5 < length3) {
                  result2 = funcs[index5].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length3 = arguments.length, args = Array2(length3), index4 = length3;
              while (index4--) {
                args[index4] = arguments[index4];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length3 -= holdersCount;
              if (isCurried && length3 < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length3
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length3 = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length3 > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length3) {
                args.length = ary2;
              }
              if (this && this !== root21 && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object2, iteratee2) {
              return baseInverter(object2, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other2) {
              var result2;
              if (value === undefined2 && other2 === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other2 !== undefined2) {
                if (result2 === undefined2) {
                  return other2;
                }
                if (typeof value == "string" || typeof other2 == "string") {
                  value = baseToString(value);
                  other2 = baseToString(other2);
                } else {
                  value = baseToNumber(value);
                  other2 = baseToNumber(other2);
                }
                result2 = operator(value, other2);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply2(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length3, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length3) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length3 / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length3).join("") : result2.slice(0, length3);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root21 && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply2(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start2, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
                end = step = undefined2;
              }
              start2 = toFinite(start2);
              if (end === undefined2) {
                end = start2;
                start2 = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start2 < end ? 1 : -1 : toFinite(step);
              return baseRange(start2, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other2) {
              if (!(typeof value == "string" && typeof other2 == "string")) {
                value = toNumber(value);
                other2 = toNumber(other2);
              }
              return operator(value, other2);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number5, precision) {
              number5 = toNumber(number5);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number5)) {
                var pair2 = (toString(number5) + "e").split("e"), value = func(pair2[0] + "e" + (+pair2[1] + precision));
                pair2 = (toString(value) + "e").split("e");
                return +(pair2[0] + "e" + (+pair2[1] - precision));
              }
              return func(number5);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop4 : function(values3) {
            return new Set2(values3);
          };
          function createToPairs(keysFunc) {
            return function(object2) {
              var tag = getTag(object2);
              if (tag == mapTag) {
                return mapToArray(object2);
              }
              if (tag == setTag) {
                return setToPairs(object2);
              }
              return baseToPairs(object2, keysFunc(object2));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length3 = partials ? partials.length : 0;
            if (!length3) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length3 -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data2 = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data2) {
              mergeData(newData, data2);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length3, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data2 ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object2) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object2, source2, stack2) {
            if (isObject(objValue) && isObject(srcValue)) {
              stack2.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack2);
              stack2["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array4, other2, bitmask, customizer, equalFunc, stack2) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array4.length, othLength = other2.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack2.get(array4);
            var othStacked = stack2.get(other2);
            if (arrStacked && othStacked) {
              return arrStacked == other2 && othStacked == array4;
            }
            var index4 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack2.set(array4, other2);
            stack2.set(other2, array4);
            while (++index4 < arrLength) {
              var arrValue = array4[index4], othValue = other2[index4];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index4, other2, array4, stack2) : customizer(arrValue, othValue, index4, array4, other2, stack2);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other2, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
                result2 = false;
                break;
              }
            }
            stack2["delete"](array4);
            stack2["delete"](other2);
            return result2;
          }
          function equalByTag(object2, other2, tag, bitmask, customizer, equalFunc, stack2) {
            switch (tag) {
              case dataViewTag:
                if (object2.byteLength != other2.byteLength || object2.byteOffset != other2.byteOffset) {
                  return false;
                }
                object2 = object2.buffer;
                other2 = other2.buffer;
              case arrayBufferTag:
                if (object2.byteLength != other2.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other2))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object2, +other2);
              case errorTag:
                return object2.name == other2.name && object2.message == other2.message;
              case regexpTag:
              case stringTag:
                return object2 == other2 + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object2.size != other2.size && !isPartial) {
                  return false;
                }
                var stacked = stack2.get(object2);
                if (stacked) {
                  return stacked == other2;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack2.set(object2, other2);
                var result2 = equalArrays(convert(object2), convert(other2), bitmask, customizer, equalFunc, stack2);
                stack2["delete"](object2);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object2) == symbolValueOf.call(other2);
                }
            }
            return false;
          }
          function equalObjects(object2, other2, bitmask, customizer, equalFunc, stack2) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other2), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index4 = objLength;
            while (index4--) {
              var key = objProps[index4];
              if (!(isPartial ? key in other2 : hasOwnProperty.call(other2, key))) {
                return false;
              }
            }
            var objStacked = stack2.get(object2);
            var othStacked = stack2.get(other2);
            if (objStacked && othStacked) {
              return objStacked == other2 && othStacked == object2;
            }
            var result2 = true;
            stack2.set(object2, other2);
            stack2.set(other2, object2);
            var skipCtor = isPartial;
            while (++index4 < objLength) {
              key = objProps[index4];
              var objValue = object2[key], othValue = other2[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other2, object2, stack2) : customizer(objValue, othValue, key, object2, other2, stack2);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object2.constructor, othCtor = other2.constructor;
              if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other2) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack2["delete"](object2);
            stack2["delete"](other2);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten3), func + "");
          }
          function getAllKeys(object2) {
            return baseGetAllKeys(object2, keys, getSymbols);
          }
          function getAllKeysIn(object2) {
            return baseGetAllKeys(object2, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop4 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array4 = realNames[result2], length3 = hasOwnProperty.call(realNames, result2) ? array4.length : 0;
            while (length3--) {
              var data2 = array4[length3], otherFunc = data2.func;
              if (otherFunc == null || otherFunc == func) {
                return data2.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object2 = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object2.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map5, key) {
            var data2 = map5.__data__;
            return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
          }
          function getMatchData(object2) {
            var result2 = keys(object2), length3 = result2.length;
            while (length3--) {
              var key = result2[length3], value = object2[key];
              result2[length3] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object2, key) {
            var value = getValue(object2, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
            if (object2 == null) {
              return [];
            }
            object2 = Object2(object2);
            return arrayFilter(nativeGetSymbols(object2), function(symbol) {
              return propertyIsEnumerable.call(object2, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
            var result2 = [];
            while (object2) {
              arrayPush(result2, getSymbols(object2));
              object2 = getPrototype(object2);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start2, end, transforms) {
            var index4 = -1, length3 = transforms.length;
            while (++index4 < length3) {
              var data2 = transforms[index4], size3 = data2.size;
              switch (data2.type) {
                case "drop":
                  start2 += size3;
                  break;
                case "dropRight":
                  end -= size3;
                  break;
                case "take":
                  end = nativeMin(end, start2 + size3);
                  break;
                case "takeRight":
                  start2 = nativeMax(start2, end - size3);
                  break;
              }
            }
            return { "start": start2, "end": end };
          }
          function getWrapDetails(source2) {
            var match2 = source2.match(reWrapDetails);
            return match2 ? match2[1].split(reSplitDetails) : [];
          }
          function hasPath(object2, path2, hasFunc) {
            path2 = castPath(path2, object2);
            var index4 = -1, length3 = path2.length, result2 = false;
            while (++index4 < length3) {
              var key = toKey(path2[index4]);
              if (!(result2 = object2 != null && hasFunc(object2, key))) {
                break;
              }
              object2 = object2[key];
            }
            if (result2 || ++index4 != length3) {
              return result2;
            }
            length3 = object2 == null ? 0 : object2.length;
            return !!length3 && isLength(length3) && isIndex(key, length3) && (isArray(object2) || isArguments(object2));
          }
          function initCloneArray(array4) {
            var length3 = array4.length, result2 = new array4.constructor(length3);
            if (length3 && typeof array4[0] == "string" && hasOwnProperty.call(array4, "index")) {
              result2.index = array4.index;
              result2.input = array4.input;
            }
            return result2;
          }
          function initCloneObject(object2) {
            return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
          }
          function initCloneByTag(object2, tag, isDeep) {
            var Ctor = object2.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object2);
              case boolTag:
              case dateTag:
                return new Ctor(+object2);
              case dataViewTag:
                return cloneDataView(object2, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object2, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object2);
              case regexpTag:
                return cloneRegExp(object2);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object2);
            }
          }
          function insertWrapDetails(source2, details) {
            var length3 = details.length;
            if (!length3) {
              return source2;
            }
            var lastIndex = length3 - 1;
            details[lastIndex] = (length3 > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length3 > 2 ? ", " : " ");
            return source2.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length3) {
            var type2 = typeof value;
            length3 = length3 == null ? MAX_SAFE_INTEGER : length3;
            return !!length3 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
          }
          function isIterateeCall(value, index4, object2) {
            if (!isObject(object2)) {
              return false;
            }
            var type2 = typeof index4;
            if (type2 == "number" ? isArrayLike(object2) && isIndex(index4, object2.length) : type2 == "string" && index4 in object2) {
              return eq(object2[index4], value);
            }
            return false;
          }
          function isKey(value, object2) {
            if (isArray(value)) {
              return false;
            }
            var type2 = typeof value;
            if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
          }
          function isKeyable(value) {
            var type2 = typeof value;
            return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other2 = lodash[funcName];
            if (typeof other2 != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other2) {
              return true;
            }
            var data2 = getData(other2);
            return !!data2 && func === data2[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object2) {
              if (object2 == null) {
                return false;
              }
              return object2[key] === srcValue && (srcValue !== undefined2 || key in Object2(object2));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache2.size === MAX_MEMOIZE_SIZE) {
                cache2.clear();
              }
              return key;
            });
            var cache2 = result2.cache;
            return result2;
          }
          function mergeData(data2, source2) {
            var bitmask = data2[1], srcBitmask = source2[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source2[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source2[7].length <= source2[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data2;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data2[2] = source2[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source2[3];
            if (value) {
              var partials = data2[3];
              data2[3] = partials ? composeArgs(partials, value, source2[4]) : value;
              data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source2[4];
            }
            value = source2[5];
            if (value) {
              partials = data2[5];
              data2[5] = partials ? composeArgsRight(partials, value, source2[6]) : value;
              data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source2[6];
            }
            value = source2[7];
            if (value) {
              data2[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data2[8] = data2[8] == null ? source2[8] : nativeMin(data2[8], source2[8]);
            }
            if (data2[9] == null) {
              data2[9] = source2[9];
            }
            data2[0] = source2[0];
            data2[1] = newBitmask;
            return data2;
          }
          function nativeKeysIn(object2) {
            var result2 = [];
            if (object2 != null) {
              for (var key in Object2(object2)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start2, transform3) {
            start2 = nativeMax(start2 === undefined2 ? func.length - 1 : start2, 0);
            return function() {
              var args = arguments, index4 = -1, length3 = nativeMax(args.length - start2, 0), array4 = Array2(length3);
              while (++index4 < length3) {
                array4[index4] = args[start2 + index4];
              }
              index4 = -1;
              var otherArgs = Array2(start2 + 1);
              while (++index4 < start2) {
                otherArgs[index4] = args[index4];
              }
              otherArgs[start2] = transform3(array4);
              return apply2(func, this, otherArgs);
            };
          }
          function parent(object2, path2) {
            return path2.length < 2 ? object2 : baseGet(object2, baseSlice(path2, 0, -1));
          }
          function reorder(array4, indexes2) {
            var arrLength = array4.length, length3 = nativeMin(indexes2.length, arrLength), oldArray = copyArray(array4);
            while (length3--) {
              var index4 = indexes2[length3];
              array4[length3] = isIndex(index4, arrLength) ? oldArray[index4] : undefined2;
            }
            return array4;
          }
          function safeGet(object2, key) {
            if (key === "constructor" && typeof object2[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object2[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root21.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source2 = reference + "";
            return setToString(wrapper, insertWrapDetails(source2, updateWrapDetails(getWrapDetails(source2), bitmask)));
          }
          function shortOut(func) {
            var count3 = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count3 >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count3 = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array4, size3) {
            var index4 = -1, length3 = array4.length, lastIndex = length3 - 1;
            size3 = size3 === undefined2 ? length3 : size3;
            while (++index4 < size3) {
              var rand = baseRandom(index4, lastIndex), value = array4[rand];
              array4[rand] = array4[index4];
              array4[index4] = value;
            }
            array4.length = size3;
            return array4;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match2, number5, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number5 || match2);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair2) {
              var value = "_." + pair2[0];
              if (bitmask & pair2[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array4, size3, guard) {
            if (guard ? isIterateeCall(array4, size3, guard) : size3 === undefined2) {
              size3 = 1;
            } else {
              size3 = nativeMax(toInteger(size3), 0);
            }
            var length3 = array4 == null ? 0 : array4.length;
            if (!length3 || size3 < 1) {
              return [];
            }
            var index4 = 0, resIndex = 0, result2 = Array2(nativeCeil(length3 / size3));
            while (index4 < length3) {
              result2[resIndex++] = baseSlice(array4, index4, index4 += size3);
            }
            return result2;
          }
          function compact(array4) {
            var index4 = -1, length3 = array4 == null ? 0 : array4.length, resIndex = 0, result2 = [];
            while (++index4 < length3) {
              var value = array4[index4];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length3 = arguments.length;
            if (!length3) {
              return [];
            }
            var args = Array2(length3 - 1), array4 = arguments[0], index4 = length3;
            while (index4--) {
              args[index4 - 1] = arguments[index4];
            }
            return arrayPush(isArray(array4) ? copyArray(array4) : [array4], baseFlatten(args, 1));
          }
          var difference2 = baseRest(function(array4, values3) {
            return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array4, values3) {
            var iteratee2 = last(values3);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array4, values3) {
            var comparator = last(values3);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values3, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array4, n, guard) {
            var length3 = array4 == null ? 0 : array4.length;
            if (!length3) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array4, n < 0 ? 0 : n, length3);
          }
          function dropRight(array4, n, guard) {
            var length3 = array4 == null ? 0 : array4.length;
            if (!length3) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length3 - n;
            return baseSlice(array4, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array4, predicate) {
            return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array4, predicate) {
            return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), true) : [];
          }
          function fill(array4, value, start2, end) {
            var length3 = array4 == null ? 0 : array4.length;
            if (!length3) {
              return [];
            }
            if (start2 && typeof start2 != "number" && isIterateeCall(array4, value, start2)) {
              start2 = 0;
              end = length3;
            }
            return baseFill(array4, value, start2, end);
          }
          function findIndex(array4, predicate, fromIndex) {
            var length3 = array4 == null ? 0 : array4.length;
            if (!length3) {
              return -1;
            }
            var index4 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index4 < 0) {
              index4 = nativeMax(length3 + index4, 0);
            }
            return baseFindIndex(array4, getIteratee(predicate, 3), index4);
          }
          function findLastIndex(array4, predicate, fromIndex) {
            var length3 = array4 == null ? 0 : array4.length;
            if (!length3) {
              return -1;
            }
            var index4 = length3 - 1;
            if (fromIndex !== undefined2) {
              index4 = toInteger(fromIndex);
              index4 = fromIndex < 0 ? nativeMax(length3 + index4, 0) : nativeMin(index4, length3 - 1);
            }
            return baseFindIndex(array4, getIteratee(predicate, 3), index4, true);
          }
          function flatten3(array4) {
            var length3 = array4 == null ? 0 : array4.length;
            return length3 ? baseFlatten(array4, 1) : [];
          }
          function flattenDeep(array4) {
            var length3 = array4 == null ? 0 : array4.length;
            return length3 ? baseFlatten(array4, INFINITY) : [];
          }
          function flattenDepth(array4, depth) {
            var length3 = array4 == null ? 0 : array4.length;
            if (!length3) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array4, depth);
          }
          function fromPairs(pairs2) {
            var index4 = -1, length3 = pairs2 == null ? 0 : pairs2.length, result2 = {};
            while (++index4 < length3) {
              var pair2 = pairs2[index4];
              result2[pair2[0]] = pair2[1];
            }
            return result2;
          }
          function head2(array4) {
            return array4 && array4.length ? array4[0] : undefined2;
          }
          function indexOf(array4, value, fromIndex) {
            var length3 = array4 == null ? 0 : array4.length;
            if (!length3) {
              return -1;
            }
            var index4 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index4 < 0) {
              index4 = nativeMax(length3 + index4, 0);
            }
            return baseIndexOf(array4, value, index4);
          }
          function initial(array4) {
            var length3 = array4 == null ? 0 : array4.length;
            return length3 ? baseSlice(array4, 0, -1) : [];
          }
          var intersection2 = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array4, separator) {
            return array4 == null ? "" : nativeJoin.call(array4, separator);
          }
          function last(array4) {
            var length3 = array4 == null ? 0 : array4.length;
            return length3 ? array4[length3 - 1] : undefined2;
          }
          function lastIndexOf(array4, value, fromIndex) {
            var length3 = array4 == null ? 0 : array4.length;
            if (!length3) {
              return -1;
            }
            var index4 = length3;
            if (fromIndex !== undefined2) {
              index4 = toInteger(fromIndex);
              index4 = index4 < 0 ? nativeMax(length3 + index4, 0) : nativeMin(index4, length3 - 1);
            }
            return value === value ? strictLastIndexOf(array4, value, index4) : baseFindIndex(array4, baseIsNaN, index4, true);
          }
          function nth(array4, n) {
            return array4 && array4.length ? baseNth(array4, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array4, values3) {
            return array4 && array4.length && values3 && values3.length ? basePullAll(array4, values3) : array4;
          }
          function pullAllBy(array4, values3, iteratee2) {
            return array4 && array4.length && values3 && values3.length ? basePullAll(array4, values3, getIteratee(iteratee2, 2)) : array4;
          }
          function pullAllWith(array4, values3, comparator) {
            return array4 && array4.length && values3 && values3.length ? basePullAll(array4, values3, undefined2, comparator) : array4;
          }
          var pullAt = flatRest(function(array4, indexes2) {
            var length3 = array4 == null ? 0 : array4.length, result2 = baseAt(array4, indexes2);
            basePullAt(array4, arrayMap(indexes2, function(index4) {
              return isIndex(index4, length3) ? +index4 : index4;
            }).sort(compareAscending));
            return result2;
          });
          function remove2(array4, predicate) {
            var result2 = [];
            if (!(array4 && array4.length)) {
              return result2;
            }
            var index4 = -1, indexes2 = [], length3 = array4.length;
            predicate = getIteratee(predicate, 3);
            while (++index4 < length3) {
              var value = array4[index4];
              if (predicate(value, index4, array4)) {
                result2.push(value);
                indexes2.push(index4);
              }
            }
            basePullAt(array4, indexes2);
            return result2;
          }
          function reverse2(array4) {
            return array4 == null ? array4 : nativeReverse.call(array4);
          }
          function slice5(array4, start2, end) {
            var length3 = array4 == null ? 0 : array4.length;
            if (!length3) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array4, start2, end)) {
              start2 = 0;
              end = length3;
            } else {
              start2 = start2 == null ? 0 : toInteger(start2);
              end = end === undefined2 ? length3 : toInteger(end);
            }
            return baseSlice(array4, start2, end);
          }
          function sortedIndex(array4, value) {
            return baseSortedIndex(array4, value);
          }
          function sortedIndexBy(array4, value, iteratee2) {
            return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array4, value) {
            var length3 = array4 == null ? 0 : array4.length;
            if (length3) {
              var index4 = baseSortedIndex(array4, value);
              if (index4 < length3 && eq(array4[index4], value)) {
                return index4;
              }
            }
            return -1;
          }
          function sortedLastIndex(array4, value) {
            return baseSortedIndex(array4, value, true);
          }
          function sortedLastIndexBy(array4, value, iteratee2) {
            return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array4, value) {
            var length3 = array4 == null ? 0 : array4.length;
            if (length3) {
              var index4 = baseSortedIndex(array4, value, true) - 1;
              if (eq(array4[index4], value)) {
                return index4;
              }
            }
            return -1;
          }
          function sortedUniq(array4) {
            return array4 && array4.length ? baseSortedUniq(array4) : [];
          }
          function sortedUniqBy(array4, iteratee2) {
            return array4 && array4.length ? baseSortedUniq(array4, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array4) {
            var length3 = array4 == null ? 0 : array4.length;
            return length3 ? baseSlice(array4, 1, length3) : [];
          }
          function take(array4, n, guard) {
            if (!(array4 && array4.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array4, 0, n < 0 ? 0 : n);
          }
          function takeRight(array4, n, guard) {
            var length3 = array4 == null ? 0 : array4.length;
            if (!length3) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length3 - n;
            return baseSlice(array4, n < 0 ? 0 : n, length3);
          }
          function takeRightWhile(array4, predicate) {
            return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array4, predicate) {
            return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3)) : [];
          }
          var union2 = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array4) {
            return array4 && array4.length ? baseUniq(array4) : [];
          }
          function uniqBy(array4, iteratee2) {
            return array4 && array4.length ? baseUniq(array4, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array4, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array4 && array4.length ? baseUniq(array4, undefined2, comparator) : [];
          }
          function unzip(array4) {
            if (!(array4 && array4.length)) {
              return [];
            }
            var length3 = 0;
            array4 = arrayFilter(array4, function(group2) {
              if (isArrayLikeObject(group2)) {
                length3 = nativeMax(group2.length, length3);
                return true;
              }
            });
            return baseTimes(length3, function(index4) {
              return arrayMap(array4, baseProperty(index4));
            });
          }
          function unzipWith(array4, iteratee2) {
            if (!(array4 && array4.length)) {
              return [];
            }
            var result2 = unzip(array4);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group2) {
              return apply2(iteratee2, undefined2, group2);
            });
          }
          var without = baseRest(function(array4, values3) {
            return isArrayLikeObject(array4) ? baseDifference(array4, values3) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip3 = baseRest(unzip);
          function zipObject(props, values3) {
            return baseZipObject(props || [], values3 || [], assignValue);
          }
          function zipObjectDeep(props, values3) {
            return baseZipObject(props || [], values3 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length3 = arrays.length, iteratee2 = length3 > 1 ? arrays[length3 - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length3 = paths.length, start2 = length3 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
              return baseAt(object2, paths);
            };
            if (length3 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
              return this.thru(interceptor);
            }
            value = value.slice(start2, +start2 + (length3 ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array4) {
              if (length3 && !array4.length) {
                array4.push(undefined2);
              }
              return array4;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse2],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse2);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every2(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter3(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find3 = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map4(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map4(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map4(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values2(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length3 = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length3 + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length3 && collection.indexOf(value, fromIndex) > -1 : !!length3 && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path2, args) {
            var index4 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index4] = isFunc ? apply2(path2, value, args) : baseInvoke(value, path2, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map4(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce2(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate3(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle2(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size2(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some2(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length3 = iteratees.length;
            if (length3 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length3 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now2 = ctxNow || function() {
            return root21.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey2 = baseRest(function(object2, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey2));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object2, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time2) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time2;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time2) {
              lastInvokeTime = time2;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time2) : result2;
            }
            function remainingWait(time2) {
              var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time2) {
              var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time2 = now2();
              if (shouldInvoke(time2)) {
                return trailingEdge(time2);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time2));
            }
            function trailingEdge(time2) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time2);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now2());
            }
            function debounced() {
              var time2 = now2(), isInvoking = shouldInvoke(time2);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time2;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
              if (cache2.has(key)) {
                return cache2.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache2.set(key, result2) || cache2;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate3(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once2(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index4 = -1, length3 = nativeMin(args.length, funcsLength);
              while (++index4 < length3) {
                args[index4] = transforms[index4].call(this, args[index4]);
              }
              return apply2(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes2) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes2);
          });
          function rest(func, start2) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start2 = start2 === undefined2 ? start2 : toInteger(start2);
            return baseRest(func, start2);
          }
          function spread(func, start2) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
            return baseRest(function(args) {
              var array4 = args[start2], otherArgs = castSlice(args, 0, start2);
              if (array4) {
                arrayPush(otherArgs, array4);
              }
              return apply2(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object2, source2) {
            return source2 == null || baseConformsTo(object2, source2, keys(source2));
          }
          function eq(value, other2) {
            return value === other2 || value !== value && other2 !== other2;
          }
          var gt2 = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other2) {
            return value >= other2;
          });
          var isArguments = baseIsArguments(/* @__PURE__ */ function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other2) {
            return baseIsEqual(value, other2);
          }
          function isEqualWith(value, other2, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other2) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other2, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type2 = typeof value;
            return value != null && (type2 == "object" || type2 == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object2, source2) {
            return object2 === source2 || baseIsMatch(object2, source2, getMatchData(source2));
          }
          function isMatchWith(object2, source2, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object2, source2, getMatchData(source2), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt2 = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other2) {
            return value <= other2;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign3 = value < 0 ? -1 : 1;
              return sign3 * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other2 = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other2) ? other2 + "" : other2;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign2 = createAssigner(function(object2, source2) {
            if (isPrototype(source2) || isArrayLike(source2)) {
              copyObject(source2, keys(source2), object2);
              return;
            }
            for (var key in source2) {
              if (hasOwnProperty.call(source2, key)) {
                assignValue(object2, key, source2[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object2, source2) {
            copyObject(source2, keysIn(source2), object2);
          });
          var assignInWith = createAssigner(function(object2, source2, srcIndex, customizer) {
            copyObject(source2, keysIn(source2), object2, customizer);
          });
          var assignWith = createAssigner(function(object2, source2, srcIndex, customizer) {
            copyObject(source2, keys(source2), object2, customizer);
          });
          var at = flatRest(baseAt);
          function create2(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object2, sources) {
            object2 = Object2(object2);
            var index4 = -1;
            var length3 = sources.length;
            var guard = length3 > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length3 = 1;
            }
            while (++index4 < length3) {
              var source2 = sources[index4];
              var props = keysIn(source2);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object2[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
                  object2[key] = source2[key];
                }
              }
            }
            return object2;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply2(mergeWith, undefined2, args);
          });
          function findKey(object2, predicate) {
            return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object2, predicate) {
            return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object2, iteratee2) {
            return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object2, iteratee2) {
            return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object2, iteratee2) {
            return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object2, iteratee2) {
            return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
          }
          function functions(object2) {
            return object2 == null ? [] : baseFunctions(object2, keys(object2));
          }
          function functionsIn(object2) {
            return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
          }
          function get5(object2, path2, defaultValue) {
            var result2 = object2 == null ? undefined2 : baseGet(object2, path2);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object2, path2) {
            return object2 != null && hasPath(object2, path2, baseHas);
          }
          function hasIn(object2, path2) {
            return object2 != null && hasPath(object2, path2, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant2(identity6));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object2) {
            return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
          }
          function keysIn(object2) {
            return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
          }
          function mapKeys(object2, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object2, function(value, key, object3) {
              baseAssignValue(result2, iteratee2(value, key, object3), value);
            });
            return result2;
          }
          function mapValues(object2, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object2, function(value, key, object3) {
              baseAssignValue(result2, key, iteratee2(value, key, object3));
            });
            return result2;
          }
          var merge2 = createAssigner(function(object2, source2, srcIndex) {
            baseMerge(object2, source2, srcIndex);
          });
          var mergeWith = createAssigner(function(object2, source2, srcIndex, customizer) {
            baseMerge(object2, source2, srcIndex, customizer);
          });
          var omit = flatRest(function(object2, paths) {
            var result2 = {};
            if (object2 == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path2) {
              path2 = castPath(path2, object2);
              isDeep || (isDeep = path2.length > 1);
              return path2;
            });
            copyObject(object2, getAllKeysIn(object2), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length3 = paths.length;
            while (length3--) {
              baseUnset(result2, paths[length3]);
            }
            return result2;
          });
          function omitBy(object2, predicate) {
            return pickBy(object2, negate3(getIteratee(predicate)));
          }
          var pick = flatRest(function(object2, paths) {
            return object2 == null ? {} : basePick(object2, paths);
          });
          function pickBy(object2, predicate) {
            if (object2 == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object2), function(prop2) {
              return [prop2];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object2, props, function(value, path2) {
              return predicate(value, path2[0]);
            });
          }
          function result(object2, path2, defaultValue) {
            path2 = castPath(path2, object2);
            var index4 = -1, length3 = path2.length;
            if (!length3) {
              length3 = 1;
              object2 = undefined2;
            }
            while (++index4 < length3) {
              var value = object2 == null ? undefined2 : object2[toKey(path2[index4])];
              if (value === undefined2) {
                index4 = length3;
                value = defaultValue;
              }
              object2 = isFunction(value) ? value.call(object2) : value;
            }
            return object2;
          }
          function set5(object2, path2, value) {
            return object2 == null ? object2 : baseSet(object2, path2, value);
          }
          function setWith(object2, path2, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object2 == null ? object2 : baseSet(object2, path2, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform2(object2, iteratee2, accumulator) {
            var isArr = isArray(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray(object2);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object2 && object2.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object2)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object2)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index4, object3) {
              return iteratee2(accumulator, value, index4, object3);
            });
            return accumulator;
          }
          function unset(object2, path2) {
            return object2 == null ? true : baseUnset(object2, path2);
          }
          function update2(object2, path2, updater) {
            return object2 == null ? object2 : baseUpdate(object2, path2, castFunction(updater));
          }
          function updateWith(object2, path2, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object2 == null ? object2 : baseUpdate(object2, path2, castFunction(updater), customizer);
          }
          function values2(object2) {
            return object2 == null ? [] : baseValues(object2, keys(object2));
          }
          function valuesIn(object2) {
            return object2 == null ? [] : baseValues(object2, keysIn(object2));
          }
          function clamp(number5, lower2, upper) {
            if (upper === undefined2) {
              upper = lower2;
              lower2 = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower2 !== undefined2) {
              lower2 = toNumber(lower2);
              lower2 = lower2 === lower2 ? lower2 : 0;
            }
            return baseClamp(toNumber(number5), lower2, upper);
          }
          function inRange(number5, start2, end) {
            start2 = toFinite(start2);
            if (end === undefined2) {
              end = start2;
              start2 = 0;
            } else {
              end = toFinite(end);
            }
            number5 = toNumber(number5);
            return baseInRange(number5, start2, end);
          }
          function random(lower2, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower2 == "boolean") {
                floating = lower2;
                lower2 = undefined2;
              }
            }
            if (lower2 === undefined2 && upper === undefined2) {
              lower2 = 0;
              upper = 1;
            } else {
              lower2 = toFinite(lower2);
              if (upper === undefined2) {
                upper = lower2;
                lower2 = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower2 > upper) {
              var temp = lower2;
              lower2 = upper;
              upper = temp;
            }
            if (floating || lower2 % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower2 + rand * (upper - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower2, upper);
          }
          var camelCase = createCompounder(function(result2, word, index4) {
            word = word.toLowerCase();
            return result2 + (index4 ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length3 = string.length;
            position = position === undefined2 ? length3 : baseClamp(toInteger(position), 0, length3);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index4) {
            return result2 + (index4 ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index4) {
            return result2 + (index4 ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad3(string, length3, chars) {
            string = toString(string);
            length3 = toInteger(length3);
            var strLength = length3 ? stringSize(string) : 0;
            if (!length3 || strLength >= length3) {
              return string;
            }
            var mid = (length3 - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length3, chars) {
            string = toString(string);
            length3 = toInteger(length3);
            var strLength = length3 ? stringSize(string) : 0;
            return length3 && strLength < length3 ? string + createPadding(length3 - strLength, chars) : string;
          }
          function padStart(string, length3, chars) {
            string = toString(string);
            length3 = toInteger(length3);
            var strLength = length3 ? stringSize(string) : 0;
            return length3 && strLength < length3 ? createPadding(length3 - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString(string), n);
          }
          function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index4) {
            return result2 + (index4 ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index4) {
            return result2 + (index4 ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template2(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index4 = 0, interpolate = options.interpolate || reNoMatch, source2 = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source2 += string.slice(index4, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source2 += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source2 += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source2 += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index4 = offset + match2.length;
              return match2;
            });
            source2 += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source2 = "with (obj) {\n" + source2 + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source2 = (isEvaluating ? source2.replace(reEmptyStringLeading, "") : source2).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source2 = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source2 + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source2).apply(undefined2, importsValues);
            });
            result2.source = source2;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString(value).toLowerCase();
          }
          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start2, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start2).join("");
          }
          function truncate(string, options) {
            var length3 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length3 = "length" in options ? toInteger(options.length) : length3;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length3 >= strLength) {
              return string;
            }
            var end = length3 - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match2, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match2 = separator.exec(substring)) {
                  var newEnd = match2.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index4 = result2.lastIndexOf(separator);
              if (index4 > -1) {
                result2 = result2.slice(0, index4);
              }
            }
            return result2 + omission;
          }
          function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index4) {
            return result2 + (index4 ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply2(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object2, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object2, key, bind(object2[key], object2));
            });
            return object2;
          });
          function cond(pairs2) {
            var length3 = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
            pairs2 = !length3 ? [] : arrayMap(pairs2, function(pair2) {
              if (typeof pair2[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair2[0]), pair2[1]];
            });
            return baseRest(function(args) {
              var index4 = -1;
              while (++index4 < length3) {
                var pair2 = pairs2[index4];
                if (apply2(pair2[0], this, args)) {
                  return apply2(pair2[1], this, args);
                }
              }
            });
          }
          function conforms(source2) {
            return baseConforms(baseClone(source2, CLONE_DEEP_FLAG));
          }
          function constant2(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity6(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source2) {
            return baseMatches(baseClone(source2, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path2, srcValue) {
            return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path2, args) {
            return function(object2) {
              return baseInvoke(object2, path2, args);
            };
          });
          var methodOf = baseRest(function(object2, args) {
            return function(path2) {
              return baseInvoke(object2, path2, args);
            };
          });
          function mixin(object2, source2, options) {
            var props = keys(source2), methodNames = baseFunctions(source2, props);
            if (options == null && !(isObject(source2) && (methodNames.length || !props.length))) {
              options = source2;
              source2 = object2;
              object2 = this;
              methodNames = baseFunctions(source2, keys(source2));
            }
            var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object2);
            arrayEach(methodNames, function(methodName) {
              var func = source2[methodName];
              object2[methodName] = func;
              if (isFunc) {
                object2.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object2 });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object2, arrayPush([this.value()], arguments));
                };
              }
            });
            return object2;
          }
          function noConflict() {
            if (root21._ === this) {
              root21._ = oldDash;
            }
            return this;
          }
          function noop4() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path2) {
            return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
          }
          function propertyOf(object2) {
            return function(path2) {
              return object2 == null ? undefined2 : baseGet(object2, path2);
            };
          }
          var range6 = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index4 = MAX_ARRAY_LENGTH, length3 = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length3, iteratee2);
            while (++index4 < n) {
              iteratee2(index4);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }
          function uniqueId(prefix) {
            var id2 = ++idCounter;
            return toString(prefix) + id2;
          }
          var add2 = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil2 = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max5(array4) {
            return array4 && array4.length ? baseExtremum(array4, identity6, baseGt) : undefined2;
          }
          function maxBy(array4, iteratee2) {
            return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean2(array4) {
            return baseMean(array4, identity6);
          }
          function meanBy(array4, iteratee2) {
            return baseMean(array4, getIteratee(iteratee2, 2));
          }
          function min4(array4) {
            return array4 && array4.length ? baseExtremum(array4, identity6, baseLt) : undefined2;
          }
          function minBy(array4, iteratee2) {
            return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum4(array4) {
            return array4 && array4.length ? baseSum(array4, identity6) : 0;
          }
          function sumBy(array4, iteratee2) {
            return array4 && array4.length ? baseSum(array4, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign2;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey2;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant2;
          lodash.countBy = countBy;
          lodash.create = create2;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference2;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter3;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten3;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection2;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map4;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge2;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate3;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once2;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range6;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove2;
          lodash.rest = rest;
          lodash.reverse = reverse2;
          lodash.sampleSize = sampleSize;
          lodash.set = set5;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle2;
          lodash.slice = slice5;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform2;
          lodash.unary = unary;
          lodash.union = union2;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update2;
          lodash.updateWith = updateWith;
          lodash.values = values2;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip3;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add2;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil2;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every2;
          lodash.find = find3;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get5;
          lodash.gt = gt2;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head2;
          lodash.identity = identity6;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt2;
          lodash.lte = lte;
          lodash.max = max5;
          lodash.maxBy = maxBy;
          lodash.mean = mean2;
          lodash.meanBy = meanBy;
          lodash.min = min4;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop4;
          lodash.now = now2;
          lodash.pad = pad3;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce2;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size2;
          lodash.snakeCase = snakeCase;
          lodash.some = some2;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum4;
          lodash.sumBy = sumBy;
          lodash.template = template2;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head2;
          mixin(lodash, function() {
            var source2 = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source2[methodName] = func;
              }
            });
            return source2;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index4) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index4 ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index4) {
            var type2 = index4 + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type2
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index4) {
            var takeName = "take" + (index4 ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index4) {
            var dropName = "drop" + (index4 ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity6);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
            if (typeof path2 == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path2, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate3(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start2, end) {
            start2 = toInteger(start2);
            var result2 = this;
            if (result2.__filtered__ && (start2 > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start2 < 0) {
              result2 = result2.takeRight(-start2);
            } else if (start2) {
              result2 = result2.drop(start2);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _25 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root21._ = _25;
          define(function() {
            return _25;
          });
        } else if (freeModule) {
          (freeModule.exports = _25)._ = _25;
          freeExports._ = _25;
        } else {
          root21._ = _25;
        }
      }).call(exports);
    }
  });

  // node_modules/rainbowvis.js/rainbowvis.js
  var require_rainbowvis = __commonJS({
    "node_modules/rainbowvis.js/rainbowvis.js"(exports, module) {
      function Rainbow2() {
        "use strict";
        var gradients = null;
        var minNum = 0;
        var maxNum = 100;
        var colours = ["ff0000", "ffff00", "00ff00", "0000ff"];
        setColours(colours);
        function setColours(spectrum) {
          if (spectrum.length < 2) {
            throw new Error("Rainbow must have two or more colours.");
          } else {
            var increment2 = (maxNum - minNum) / (spectrum.length - 1);
            var firstGradient = new ColourGradient();
            firstGradient.setGradient(spectrum[0], spectrum[1]);
            firstGradient.setNumberRange(minNum, minNum + increment2);
            gradients = [firstGradient];
            for (var i = 1; i < spectrum.length - 1; i++) {
              var colourGradient = new ColourGradient();
              colourGradient.setGradient(spectrum[i], spectrum[i + 1]);
              colourGradient.setNumberRange(minNum + increment2 * i, minNum + increment2 * (i + 1));
              gradients[i] = colourGradient;
            }
            colours = spectrum;
          }
        }
        this.setSpectrum = function() {
          setColours(arguments);
          return this;
        };
        this.setSpectrumByArray = function(array4) {
          setColours(array4);
          return this;
        };
        this.colourAt = function(number5) {
          if (isNaN(number5)) {
            throw new TypeError(number5 + " is not a number");
          } else if (gradients.length === 1) {
            return gradients[0].colourAt(number5);
          } else {
            var segment = (maxNum - minNum) / gradients.length;
            var index4 = Math.min(Math.floor((Math.max(number5, minNum) - minNum) / segment), gradients.length - 1);
            return gradients[index4].colourAt(number5);
          }
        };
        this.colorAt = this.colourAt;
        this.setNumberRange = function(minNumber, maxNumber) {
          if (maxNumber > minNumber) {
            minNum = minNumber;
            maxNum = maxNumber;
            setColours(colours);
          } else {
            throw new RangeError("maxNumber (" + maxNumber + ") is not greater than minNumber (" + minNumber + ")");
          }
          return this;
        };
      }
      function ColourGradient() {
        "use strict";
        var startColour = "ff0000";
        var endColour = "0000ff";
        var minNum = 0;
        var maxNum = 100;
        this.setGradient = function(colourStart, colourEnd) {
          startColour = getHexColour(colourStart);
          endColour = getHexColour(colourEnd);
        };
        this.setNumberRange = function(minNumber, maxNumber) {
          if (maxNumber > minNumber) {
            minNum = minNumber;
            maxNum = maxNumber;
          } else {
            throw new RangeError("maxNumber (" + maxNumber + ") is not greater than minNumber (" + minNumber + ")");
          }
        };
        this.colourAt = function(number5) {
          return calcHex(number5, startColour.substring(0, 2), endColour.substring(0, 2)) + calcHex(number5, startColour.substring(2, 4), endColour.substring(2, 4)) + calcHex(number5, startColour.substring(4, 6), endColour.substring(4, 6));
        };
        function calcHex(number5, channelStart_Base16, channelEnd_Base16) {
          var num = number5;
          if (num < minNum) {
            num = minNum;
          }
          if (num > maxNum) {
            num = maxNum;
          }
          var numRange = maxNum - minNum;
          var cStart_Base10 = parseInt(channelStart_Base16, 16);
          var cEnd_Base10 = parseInt(channelEnd_Base16, 16);
          var cPerUnit = (cEnd_Base10 - cStart_Base10) / numRange;
          var c_Base10 = Math.round(cPerUnit * (num - minNum) + cStart_Base10);
          return formatHex(c_Base10.toString(16));
        }
        function formatHex(hex2) {
          if (hex2.length === 1) {
            return "0" + hex2;
          } else {
            return hex2;
          }
        }
        function isHexColour(string) {
          var regex = /^#?[0-9a-fA-F]{6}$/i;
          return regex.test(string);
        }
        function getHexColour(string) {
          if (isHexColour(string)) {
            return string.substring(string.length - 6, string.length);
          } else {
            var name = string.toLowerCase();
            if (colourNames.hasOwnProperty(name)) {
              return colourNames[name];
            }
            throw new Error(string + " is not a valid colour.");
          }
        }
        var colourNames = {
          aliceblue: "F0F8FF",
          antiquewhite: "FAEBD7",
          aqua: "00FFFF",
          aquamarine: "7FFFD4",
          azure: "F0FFFF",
          beige: "F5F5DC",
          bisque: "FFE4C4",
          black: "000000",
          blanchedalmond: "FFEBCD",
          blue: "0000FF",
          blueviolet: "8A2BE2",
          brown: "A52A2A",
          burlywood: "DEB887",
          cadetblue: "5F9EA0",
          chartreuse: "7FFF00",
          chocolate: "D2691E",
          coral: "FF7F50",
          cornflowerblue: "6495ED",
          cornsilk: "FFF8DC",
          crimson: "DC143C",
          cyan: "00FFFF",
          darkblue: "00008B",
          darkcyan: "008B8B",
          darkgoldenrod: "B8860B",
          darkgray: "A9A9A9",
          darkgreen: "006400",
          darkgrey: "A9A9A9",
          darkkhaki: "BDB76B",
          darkmagenta: "8B008B",
          darkolivegreen: "556B2F",
          darkorange: "FF8C00",
          darkorchid: "9932CC",
          darkred: "8B0000",
          darksalmon: "E9967A",
          darkseagreen: "8FBC8F",
          darkslateblue: "483D8B",
          darkslategray: "2F4F4F",
          darkslategrey: "2F4F4F",
          darkturquoise: "00CED1",
          darkviolet: "9400D3",
          deeppink: "FF1493",
          deepskyblue: "00BFFF",
          dimgray: "696969",
          dimgrey: "696969",
          dodgerblue: "1E90FF",
          firebrick: "B22222",
          floralwhite: "FFFAF0",
          forestgreen: "228B22",
          fuchsia: "FF00FF",
          gainsboro: "DCDCDC",
          ghostwhite: "F8F8FF",
          gold: "FFD700",
          goldenrod: "DAA520",
          gray: "808080",
          green: "008000",
          greenyellow: "ADFF2F",
          grey: "808080",
          honeydew: "F0FFF0",
          hotpink: "FF69B4",
          indianred: "CD5C5C",
          indigo: "4B0082",
          ivory: "FFFFF0",
          khaki: "F0E68C",
          lavender: "E6E6FA",
          lavenderblush: "FFF0F5",
          lawngreen: "7CFC00",
          lemonchiffon: "FFFACD",
          lightblue: "ADD8E6",
          lightcoral: "F08080",
          lightcyan: "E0FFFF",
          lightgoldenrodyellow: "FAFAD2",
          lightgray: "D3D3D3",
          lightgreen: "90EE90",
          lightgrey: "D3D3D3",
          lightpink: "FFB6C1",
          lightsalmon: "FFA07A",
          lightseagreen: "20B2AA",
          lightskyblue: "87CEFA",
          lightslategray: "778899",
          lightslategrey: "778899",
          lightsteelblue: "B0C4DE",
          lightyellow: "FFFFE0",
          lime: "00FF00",
          limegreen: "32CD32",
          linen: "FAF0E6",
          magenta: "FF00FF",
          maroon: "800000",
          mediumaquamarine: "66CDAA",
          mediumblue: "0000CD",
          mediumorchid: "BA55D3",
          mediumpurple: "9370DB",
          mediumseagreen: "3CB371",
          mediumslateblue: "7B68EE",
          mediumspringgreen: "00FA9A",
          mediumturquoise: "48D1CC",
          mediumvioletred: "C71585",
          midnightblue: "191970",
          mintcream: "F5FFFA",
          mistyrose: "FFE4E1",
          moccasin: "FFE4B5",
          navajowhite: "FFDEAD",
          navy: "000080",
          oldlace: "FDF5E6",
          olive: "808000",
          olivedrab: "6B8E23",
          orange: "FFA500",
          orangered: "FF4500",
          orchid: "DA70D6",
          palegoldenrod: "EEE8AA",
          palegreen: "98FB98",
          paleturquoise: "AFEEEE",
          palevioletred: "DB7093",
          papayawhip: "FFEFD5",
          peachpuff: "FFDAB9",
          peru: "CD853F",
          pink: "FFC0CB",
          plum: "DDA0DD",
          powderblue: "B0E0E6",
          purple: "800080",
          red: "FF0000",
          rosybrown: "BC8F8F",
          royalblue: "4169E1",
          saddlebrown: "8B4513",
          salmon: "FA8072",
          sandybrown: "F4A460",
          seagreen: "2E8B57",
          seashell: "FFF5EE",
          sienna: "A0522D",
          silver: "C0C0C0",
          skyblue: "87CEEB",
          slateblue: "6A5ACD",
          slategray: "708090",
          slategrey: "708090",
          snow: "FFFAFA",
          springgreen: "00FF7F",
          steelblue: "4682B4",
          tan: "D2B48C",
          teal: "008080",
          thistle: "D8BFD8",
          tomato: "FF6347",
          turquoise: "40E0D0",
          violet: "EE82EE",
          wheat: "F5DEB3",
          white: "FFFFFF",
          whitesmoke: "F5F5F5",
          yellow: "FFFF00",
          yellowgreen: "9ACD32"
        };
      }
      if (typeof module !== "undefined") {
        module.exports = Rainbow2;
      }
    }
  });

  // node_modules/cancelable-promise/umd/CancelablePromise.js
  var require_CancelablePromise = __commonJS({
    "node_modules/cancelable-promise/umd/CancelablePromise.js"(exports) {
      function _typeof(obj) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof(obj);
      }
      (function(global2, factory) {
        if (typeof define === "function" && define.amd) {
          define(["exports"], factory);
        } else if (typeof exports !== "undefined") {
          factory(exports);
        } else {
          var mod = {
            exports: {}
          };
          factory(mod.exports);
          global2.CancelablePromise = mod.exports;
        }
      })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : exports, function(_exports) {
        "use strict";
        Object.defineProperty(_exports, "__esModule", {
          value: true
        });
        _exports.CancelablePromise = void 0;
        _exports.cancelable = cancelable3;
        _exports.default = void 0;
        _exports.isCancelablePromise = isCancelablePromise;
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
          Object.defineProperty(subClass, "prototype", { writable: false });
          if (superClass) _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function _possibleConstructorReturn(self3, call) {
          if (call && (_typeof(call) === "object" || typeof call === "function")) {
            return call;
          } else if (call !== void 0) {
            throw new TypeError("Derived constructors may only return object or undefined");
          }
          return _assertThisInitialized(self3);
        }
        function _assertThisInitialized(self3) {
          if (self3 === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self3;
        }
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
            return true;
          } catch (e) {
            return false;
          }
        }
        function _getPrototypeOf(o) {
          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          };
          return _getPrototypeOf(o);
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
          var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it2) {
            if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it2) o = it2;
              var i = 0;
              var F2 = function F3() {
              };
              return { s: F2, n: function n() {
                if (i >= o.length) return { done: true };
                return { done: false, value: o[i++] };
              }, e: function e(_e) {
                throw _e;
              }, f: F2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true, didErr = false, err;
          return { s: function s2() {
            it2 = it2.call(o);
          }, n: function n() {
            var step = it2.next();
            normalCompletion = step.done;
            return step;
          }, e: function e(_e2) {
            didErr = true;
            err = _e2;
          }, f: function f() {
            try {
              if (!normalCompletion && it2.return != null) it2.return();
            } finally {
              if (didErr) throw err;
            }
          } };
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", { writable: false });
          return Constructor;
        }
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _classPrivateFieldInitSpec(obj, privateMap, value) {
          _checkPrivateRedeclaration(obj, privateMap);
          privateMap.set(obj, value);
        }
        function _checkPrivateRedeclaration(obj, privateCollection) {
          if (privateCollection.has(obj)) {
            throw new TypeError("Cannot initialize the same private elements twice on an object");
          }
        }
        function _classPrivateFieldGet(receiver, privateMap) {
          var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
          return _classApplyDescriptorGet(receiver, descriptor);
        }
        function _classApplyDescriptorGet(receiver, descriptor) {
          if (descriptor.get) {
            return descriptor.get.call(receiver);
          }
          return descriptor.value;
        }
        function _classPrivateFieldSet(receiver, privateMap, value) {
          var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
          _classApplyDescriptorSet(receiver, descriptor, value);
          return value;
        }
        function _classExtractFieldDescriptor(receiver, privateMap, action2) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to " + action2 + " private field on non-instance");
          }
          return privateMap.get(receiver);
        }
        function _classApplyDescriptorSet(receiver, descriptor, value) {
          if (descriptor.set) {
            descriptor.set.call(receiver, value);
          } else {
            if (!descriptor.writable) {
              throw new TypeError("attempted to set read only private field");
            }
            descriptor.value = value;
          }
        }
        var toStringTag = typeof Symbol !== "undefined" ? Symbol.toStringTag : "@@toStringTag";
        var _internals = /* @__PURE__ */ new WeakMap();
        var _promise = /* @__PURE__ */ new WeakMap();
        var CancelablePromiseInternal = /* @__PURE__ */ function() {
          function CancelablePromiseInternal2(_ref) {
            var _ref$executor = _ref.executor, executor = _ref$executor === void 0 ? function() {
            } : _ref$executor, _ref$internals = _ref.internals, internals = _ref$internals === void 0 ? defaultInternals() : _ref$internals, _ref$promise = _ref.promise, promise = _ref$promise === void 0 ? new Promise(function(resolve, reject) {
              return executor(resolve, reject, function(onCancel) {
                internals.onCancelList.push(onCancel);
              });
            }) : _ref$promise;
            _classCallCheck(this, CancelablePromiseInternal2);
            _classPrivateFieldInitSpec(this, _internals, {
              writable: true,
              value: void 0
            });
            _classPrivateFieldInitSpec(this, _promise, {
              writable: true,
              value: void 0
            });
            _defineProperty(this, toStringTag, "CancelablePromise");
            this.cancel = this.cancel.bind(this);
            _classPrivateFieldSet(this, _internals, internals);
            _classPrivateFieldSet(this, _promise, promise || new Promise(function(resolve, reject) {
              return executor(resolve, reject, function(onCancel) {
                internals.onCancelList.push(onCancel);
              });
            }));
          }
          _createClass(CancelablePromiseInternal2, [{
            key: "then",
            value: function then(onfulfilled, onrejected) {
              return makeCancelable(_classPrivateFieldGet(this, _promise).then(createCallback(onfulfilled, _classPrivateFieldGet(this, _internals)), createCallback(onrejected, _classPrivateFieldGet(this, _internals))), _classPrivateFieldGet(this, _internals));
            }
          }, {
            key: "catch",
            value: function _catch(onrejected) {
              return makeCancelable(_classPrivateFieldGet(this, _promise).catch(createCallback(onrejected, _classPrivateFieldGet(this, _internals))), _classPrivateFieldGet(this, _internals));
            }
          }, {
            key: "finally",
            value: function _finally(onfinally, runWhenCanceled) {
              var _this = this;
              if (runWhenCanceled) {
                _classPrivateFieldGet(this, _internals).onCancelList.push(onfinally);
              }
              return makeCancelable(_classPrivateFieldGet(this, _promise).finally(createCallback(function() {
                if (onfinally) {
                  if (runWhenCanceled) {
                    _classPrivateFieldGet(_this, _internals).onCancelList = _classPrivateFieldGet(_this, _internals).onCancelList.filter(function(callback) {
                      return callback !== onfinally;
                    });
                  }
                  return onfinally();
                }
              }, _classPrivateFieldGet(this, _internals))), _classPrivateFieldGet(this, _internals));
            }
          }, {
            key: "cancel",
            value: function cancel() {
              _classPrivateFieldGet(this, _internals).isCanceled = true;
              var callbacks = _classPrivateFieldGet(this, _internals).onCancelList;
              _classPrivateFieldGet(this, _internals).onCancelList = [];
              var _iterator = _createForOfIteratorHelper(callbacks), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var callback = _step.value;
                  if (typeof callback === "function") {
                    try {
                      callback();
                    } catch (err) {
                      console.error(err);
                    }
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }
          }, {
            key: "isCanceled",
            value: function isCanceled() {
              return _classPrivateFieldGet(this, _internals).isCanceled === true;
            }
          }]);
          return CancelablePromiseInternal2;
        }();
        var CancelablePromise3 = /* @__PURE__ */ function(_CancelablePromiseInt) {
          _inherits(CancelablePromise4, _CancelablePromiseInt);
          var _super = _createSuper(CancelablePromise4);
          function CancelablePromise4(executor) {
            _classCallCheck(this, CancelablePromise4);
            return _super.call(this, {
              executor
            });
          }
          return _createClass(CancelablePromise4);
        }(CancelablePromiseInternal);
        _exports.CancelablePromise = CancelablePromise3;
        _defineProperty(CancelablePromise3, "all", function all(iterable) {
          return makeAllCancelable(iterable, Promise.all(iterable));
        });
        _defineProperty(CancelablePromise3, "allSettled", function allSettled(iterable) {
          return makeAllCancelable(iterable, Promise.allSettled(iterable));
        });
        _defineProperty(CancelablePromise3, "any", function any(iterable) {
          return makeAllCancelable(iterable, Promise.any(iterable));
        });
        _defineProperty(CancelablePromise3, "race", function race(iterable) {
          return makeAllCancelable(iterable, Promise.race(iterable));
        });
        _defineProperty(CancelablePromise3, "resolve", function resolve(value) {
          return cancelable3(Promise.resolve(value));
        });
        _defineProperty(CancelablePromise3, "reject", function reject(reason) {
          return cancelable3(Promise.reject(reason));
        });
        _defineProperty(CancelablePromise3, "isCancelable", isCancelablePromise);
        var _default = CancelablePromise3;
        _exports.default = _default;
        function cancelable3(promise) {
          return makeCancelable(promise, defaultInternals());
        }
        function isCancelablePromise(promise) {
          return promise instanceof CancelablePromise3 || promise instanceof CancelablePromiseInternal;
        }
        function createCallback(onResult, internals) {
          if (onResult) {
            return function(arg) {
              if (!internals.isCanceled) {
                var result = onResult(arg);
                if (isCancelablePromise(result)) {
                  internals.onCancelList.push(result.cancel);
                }
                return result;
              }
              return arg;
            };
          }
        }
        function makeCancelable(promise, internals) {
          return new CancelablePromiseInternal({
            internals,
            promise
          });
        }
        function makeAllCancelable(iterable, promise) {
          var internals = defaultInternals();
          internals.onCancelList.push(function() {
            var _iterator2 = _createForOfIteratorHelper(iterable), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var resolvable = _step2.value;
                if (isCancelablePromise(resolvable)) {
                  resolvable.cancel();
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          });
          return new CancelablePromiseInternal({
            internals,
            promise
          });
        }
        function defaultInternals() {
          return {
            isCanceled: false,
            onCancelList: []
          };
        }
      });
    }
  });

  // node_modules/esm-env/dev-fallback.js
  var node_env = globalThis.process?.env?.NODE_ENV;
  var dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod");

  // node_modules/svelte/src/internal/shared/utils.js
  var is_array = Array.isArray;
  var index_of = Array.prototype.indexOf;
  var array_from = Array.from;
  var object_keys = Object.keys;
  var define_property = Object.defineProperty;
  var get_descriptor = Object.getOwnPropertyDescriptor;
  var get_descriptors = Object.getOwnPropertyDescriptors;
  var object_prototype = Object.prototype;
  var array_prototype = Array.prototype;
  var get_prototype_of = Object.getPrototypeOf;
  var noop = () => {
  };
  function is_promise(value) {
    return typeof value?.then === "function";
  }
  function run(fn) {
    return fn();
  }
  function run_all(arr) {
    for (var i = 0; i < arr.length; i++) {
      arr[i]();
    }
  }
  function fallback(value, fallback4, lazy = false) {
    return value === void 0 ? lazy ? (
      /** @type {() => V} */
      fallback4()
    ) : (
      /** @type {V} */
      fallback4
    ) : value;
  }

  // node_modules/svelte/src/internal/client/constants.js
  var DERIVED = 1 << 1;
  var EFFECT = 1 << 2;
  var RENDER_EFFECT = 1 << 3;
  var BLOCK_EFFECT = 1 << 4;
  var BRANCH_EFFECT = 1 << 5;
  var ROOT_EFFECT = 1 << 6;
  var BOUNDARY_EFFECT = 1 << 7;
  var UNOWNED = 1 << 8;
  var DISCONNECTED = 1 << 9;
  var CLEAN = 1 << 10;
  var DIRTY = 1 << 11;
  var MAYBE_DIRTY = 1 << 12;
  var INERT = 1 << 13;
  var DESTROYED = 1 << 14;
  var EFFECT_RAN = 1 << 15;
  var EFFECT_TRANSPARENT = 1 << 16;
  var LEGACY_DERIVED_PROP = 1 << 17;
  var INSPECT_EFFECT = 1 << 18;
  var HEAD_EFFECT = 1 << 19;
  var EFFECT_HAS_DERIVED = 1 << 20;
  var STATE_SYMBOL = Symbol("$state");
  var STATE_SYMBOL_METADATA = Symbol("$state metadata");
  var LEGACY_PROPS = Symbol("legacy props");
  var LOADING_ATTR_SYMBOL = Symbol("");

  // node_modules/svelte/src/internal/client/reactivity/equality.js
  function equals(value) {
    return value === this.v;
  }
  function safe_not_equal(a4, b10) {
    return a4 != a4 ? b10 == b10 : a4 !== b10 || a4 !== null && typeof a4 === "object" || typeof a4 === "function";
  }
  function safe_equals(value) {
    return !safe_not_equal(value, this.v);
  }

  // node_modules/svelte/src/internal/client/errors.js
  function bind_invalid_checkbox_value() {
    if (dev_fallback_default) {
      const error = new Error(`bind_invalid_checkbox_value
Using \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead
https://svelte.dev/e/bind_invalid_checkbox_value`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
    }
  }
  function derived_references_self() {
    if (dev_fallback_default) {
      const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/derived_references_self`);
    }
  }
  function effect_in_teardown(rune) {
    if (dev_fallback_default) {
      const error = new Error(`effect_in_teardown
\`${rune}\` cannot be used inside an effect cleanup function
https://svelte.dev/e/effect_in_teardown`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/effect_in_teardown`);
    }
  }
  function effect_in_unowned_derived() {
    if (dev_fallback_default) {
      const error = new Error(`effect_in_unowned_derived
Effect cannot be created inside a \`$derived\` value that was not itself created inside an effect
https://svelte.dev/e/effect_in_unowned_derived`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
    }
  }
  function effect_orphan(rune) {
    if (dev_fallback_default) {
      const error = new Error(`effect_orphan
\`${rune}\` can only be used inside an effect (e.g. during component initialisation)
https://svelte.dev/e/effect_orphan`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/effect_orphan`);
    }
  }
  function effect_update_depth_exceeded() {
    if (dev_fallback_default) {
      const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
https://svelte.dev/e/effect_update_depth_exceeded`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
    }
  }
  function hydration_failed() {
    if (dev_fallback_default) {
      const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/hydration_failed`);
    }
  }
  function props_invalid_value(key) {
    if (dev_fallback_default) {
      const error = new Error(`props_invalid_value
Cannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value
https://svelte.dev/e/props_invalid_value`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/props_invalid_value`);
    }
  }
  function rune_outside_svelte(rune) {
    if (dev_fallback_default) {
      const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
    }
  }
  function state_descriptors_fixed() {
    if (dev_fallback_default) {
      const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
    }
  }
  function state_prototype_fixed() {
    if (dev_fallback_default) {
      const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
    }
  }
  function state_unsafe_local_read() {
    if (dev_fallback_default) {
      const error = new Error(`state_unsafe_local_read
Reading state that was created inside the same derived is forbidden. Consider using \`untrack\` to read locally created state
https://svelte.dev/e/state_unsafe_local_read`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/state_unsafe_local_read`);
    }
  }
  function state_unsafe_mutation() {
    if (dev_fallback_default) {
      const error = new Error(`state_unsafe_mutation
Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
    }
  }

  // node_modules/svelte/src/internal/flags/index.js
  var legacy_mode_flag = false;
  var tracing_mode_flag = false;
  function enable_legacy_mode_flag() {
    legacy_mode_flag = true;
  }

  // node_modules/svelte/src/constants.js
  var EACH_ITEM_REACTIVE = 1;
  var EACH_INDEX_REACTIVE = 1 << 1;
  var EACH_IS_CONTROLLED = 1 << 2;
  var EACH_IS_ANIMATED = 1 << 3;
  var EACH_ITEM_IMMUTABLE = 1 << 4;
  var PROPS_IS_IMMUTABLE = 1;
  var PROPS_IS_RUNES = 1 << 1;
  var PROPS_IS_UPDATED = 1 << 2;
  var PROPS_IS_BINDABLE = 1 << 3;
  var PROPS_IS_LAZY_INITIAL = 1 << 4;
  var TRANSITION_OUT = 1 << 1;
  var TRANSITION_GLOBAL = 1 << 2;
  var TEMPLATE_FRAGMENT = 1;
  var TEMPLATE_USE_IMPORT_NODE = 1 << 1;
  var HYDRATION_START = "[";
  var HYDRATION_START_ELSE = "[!";
  var HYDRATION_END = "]";
  var HYDRATION_ERROR = {};
  var ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
  var UNINITIALIZED = Symbol();
  var FILENAME = Symbol("filename");
  var HMR = Symbol("hmr");

  // node_modules/svelte/src/internal/client/dev/tracing.js
  var tracing_expressions = null;
  function get_stack(label) {
    let error = Error();
    const stack2 = error.stack;
    if (stack2) {
      const lines = stack2.split("\n");
      const new_lines = ["\n"];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line === "Error") {
          continue;
        }
        if (line.includes("validate_each_keys")) {
          return null;
        }
        if (line.includes("svelte/src/internal")) {
          continue;
        }
        new_lines.push(line);
      }
      if (new_lines.length === 1) {
        return null;
      }
      define_property(error, "stack", {
        value: new_lines.join("\n")
      });
      define_property(error, "name", {
        // 'Error' suffix is required for stack traces to be rendered properly
        value: `${label}Error`
      });
    }
    return error;
  }

  // node_modules/svelte/src/internal/client/warnings.js
  var bold = "font-weight: bold";
  var normal = "font-weight: normal";
  function hydration_attribute_changed(attribute, html3, value) {
    if (dev_fallback_default) {
      console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${attribute}\` attribute on \`${html3}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`, bold, normal);
    } else {
      console.warn(`https://svelte.dev/e/hydration_attribute_changed`);
    }
  }
  function hydration_mismatch(location) {
    if (dev_fallback_default) {
      console.warn(`%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`, bold, normal);
    } else {
      console.warn(`https://svelte.dev/e/hydration_mismatch`);
    }
  }
  function lifecycle_double_unmount() {
    if (dev_fallback_default) {
      console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
    } else {
      console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
    }
  }
  function ownership_invalid_mutation(component2, owner) {
    if (dev_fallback_default) {
      console.warn(`%c[svelte] ownership_invalid_mutation
%c${component2 ? `${component2} mutated a value owned by ${owner}. This is strongly discouraged. Consider passing values to child components with \`bind:\`, or use a callback instead` : "Mutating a value outside the component that created it is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead"}
https://svelte.dev/e/ownership_invalid_mutation`, bold, normal);
    } else {
      console.warn(`https://svelte.dev/e/ownership_invalid_mutation`);
    }
  }
  function state_proxy_equality_mismatch(operator) {
    if (dev_fallback_default) {
      console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
    } else {
      console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
    }
  }

  // node_modules/svelte/src/internal/client/dev/ownership.js
  var boundaries = {};
  var chrome_pattern = /at (?:.+ \()?(.+):(\d+):(\d+)\)?$/;
  var firefox_pattern = /@(.+):(\d+):(\d+)$/;
  function get_stack2() {
    const stack2 = new Error().stack;
    if (!stack2) return null;
    const entries = [];
    for (const line of stack2.split("\n")) {
      let match2 = chrome_pattern.exec(line) ?? firefox_pattern.exec(line);
      if (match2) {
        entries.push({
          file: match2[1],
          line: +match2[2],
          column: +match2[3]
        });
      }
    }
    return entries;
  }
  function get_component() {
    const stack2 = get_stack2()?.slice(4);
    if (!stack2) return null;
    for (let i = 0; i < stack2.length; i++) {
      const entry = stack2[i];
      const modules = boundaries[entry.file];
      if (!modules) {
        if (i === 0) return null;
        continue;
      }
      for (const module of modules) {
        if (module.end == null) {
          return null;
        }
        if (module.start.line < entry.line && module.end.line > entry.line) {
          return module.component;
        }
      }
    }
    return null;
  }
  var ADD_OWNER = Symbol("ADD_OWNER");
  function widen_ownership(from, to) {
    if (to.owners === null) {
      return;
    }
    while (from) {
      if (from.owners === null) {
        to.owners = null;
        break;
      }
      for (const owner of from.owners) {
        to.owners.add(owner);
      }
      from = from.parent;
    }
  }
  function has_owner(metadata, component2) {
    if (metadata.owners === null) {
      return true;
    }
    return metadata.owners.has(component2) || // This helps avoid false positives when using HMR, where the component function is replaced
    FILENAME in component2 && [...metadata.owners].some(
      (owner) => (
        /** @type {any} */
        owner[FILENAME] === component2[FILENAME]
      )
    ) || metadata.parent !== null && has_owner(metadata.parent, component2);
  }
  function get_owner(metadata) {
    return metadata?.owners?.values().next().value ?? get_owner(
      /** @type {ProxyMetadata} */
      metadata.parent
    );
  }
  var skip = false;
  function check_ownership(metadata) {
    if (skip) return;
    const component2 = get_component();
    if (component2 && !has_owner(metadata, component2)) {
      let original = get_owner(metadata);
      if (original[FILENAME] !== component2[FILENAME]) {
        ownership_invalid_mutation(component2[FILENAME], original[FILENAME]);
      } else {
        ownership_invalid_mutation();
      }
    }
  }

  // node_modules/svelte/src/internal/shared/errors.js
  function lifecycle_outside_component(name) {
    if (dev_fallback_default) {
      const error = new Error(`lifecycle_outside_component
\`${name}(...)\` can only be used during component initialisation
https://svelte.dev/e/lifecycle_outside_component`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
    }
  }

  // node_modules/svelte/src/internal/client/context.js
  var component_context = null;
  function set_component_context(context) {
    component_context = context;
  }
  var dev_current_component_function = null;
  function set_dev_current_component_function(fn) {
    dev_current_component_function = fn;
  }
  function push(props, runes = false, fn) {
    component_context = {
      p: component_context,
      c: null,
      e: null,
      m: false,
      s: props,
      x: null,
      l: null
    };
    if (legacy_mode_flag && !runes) {
      component_context.l = {
        s: null,
        u: null,
        r1: [],
        r2: source(false)
      };
    }
    if (dev_fallback_default) {
      component_context.function = fn;
      dev_current_component_function = fn;
    }
  }
  function pop(component2) {
    const context_stack_item = component_context;
    if (context_stack_item !== null) {
      if (component2 !== void 0) {
        context_stack_item.x = component2;
      }
      const component_effects = context_stack_item.e;
      if (component_effects !== null) {
        var previous_effect = active_effect;
        var previous_reaction = active_reaction;
        context_stack_item.e = null;
        try {
          for (var i = 0; i < component_effects.length; i++) {
            var component_effect = component_effects[i];
            set_active_effect(component_effect.effect);
            set_active_reaction(component_effect.reaction);
            effect(component_effect.fn);
          }
        } finally {
          set_active_effect(previous_effect);
          set_active_reaction(previous_reaction);
        }
      }
      component_context = context_stack_item.p;
      if (dev_fallback_default) {
        dev_current_component_function = context_stack_item.p?.function ?? null;
      }
      context_stack_item.m = true;
    }
    return component2 || /** @type {T} */
    {};
  }
  function is_runes() {
    return !legacy_mode_flag || component_context !== null && component_context.l === null;
  }

  // node_modules/svelte/src/internal/client/reactivity/sources.js
  var inspect_effects = /* @__PURE__ */ new Set();
  function set_inspect_effects(v3) {
    inspect_effects = v3;
  }
  function source(v3, stack2) {
    var signal = {
      f: 0,
      // TODO ideally we could skip this altogether, but it causes type errors
      v: v3,
      reactions: null,
      equals,
      rv: 0,
      wv: 0
    };
    if (dev_fallback_default && tracing_mode_flag) {
      signal.created = stack2 ?? get_stack("CreatedAt");
      signal.debug = null;
    }
    return signal;
  }
  function state(v3) {
    return /* @__PURE__ */ push_derived_source(source(v3));
  }
  // @__NO_SIDE_EFFECTS__
  function mutable_source(initial_value, immutable = false) {
    const s2 = source(initial_value);
    if (!immutable) {
      s2.equals = safe_equals;
    }
    if (legacy_mode_flag && component_context !== null && component_context.l !== null) {
      (component_context.l.s ??= []).push(s2);
    }
    return s2;
  }
  function mutable_state(v3, immutable = false) {
    return /* @__PURE__ */ push_derived_source(/* @__PURE__ */ mutable_source(v3, immutable));
  }
  // @__NO_SIDE_EFFECTS__
  function push_derived_source(source2) {
    if (active_reaction !== null && !untracking && (active_reaction.f & DERIVED) !== 0) {
      if (derived_sources === null) {
        set_derived_sources([source2]);
      } else {
        derived_sources.push(source2);
      }
    }
    return source2;
  }
  function mutate(source2, value) {
    set(
      source2,
      untrack(() => get(source2))
    );
    return value;
  }
  function set(source2, value) {
    if (active_reaction !== null && !untracking && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 && // If the source was created locally within the current derived, then
    // we allow the mutation.
    (derived_sources === null || !derived_sources.includes(source2))) {
      state_unsafe_mutation();
    }
    return internal_set(source2, value);
  }
  function internal_set(source2, value) {
    if (!source2.equals(value)) {
      var old_value = source2.v;
      source2.v = value;
      source2.wv = increment_write_version();
      if (dev_fallback_default && tracing_mode_flag) {
        source2.updated = get_stack("UpdatedAt");
        if (active_effect != null) {
          source2.trace_need_increase = true;
          source2.trace_v ??= old_value;
        }
      }
      mark_reactions(source2, DIRTY);
      if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
        if (untracked_writes === null) {
          set_untracked_writes([source2]);
        } else {
          untracked_writes.push(source2);
        }
      }
      if (dev_fallback_default && inspect_effects.size > 0) {
        const inspects = Array.from(inspect_effects);
        for (const effect2 of inspects) {
          if ((effect2.f & CLEAN) !== 0) {
            set_signal_status(effect2, MAYBE_DIRTY);
          }
          if (check_dirtiness(effect2)) {
            update_effect(effect2);
          }
        }
        inspect_effects.clear();
      }
    }
    return value;
  }
  function mark_reactions(signal, status) {
    var reactions = signal.reactions;
    if (reactions === null) return;
    var runes = is_runes();
    var length3 = reactions.length;
    for (var i = 0; i < length3; i++) {
      var reaction = reactions[i];
      var flags = reaction.f;
      if ((flags & DIRTY) !== 0) continue;
      if (!runes && reaction === active_effect) continue;
      if (dev_fallback_default && (flags & INSPECT_EFFECT) !== 0) {
        inspect_effects.add(reaction);
        continue;
      }
      set_signal_status(reaction, status);
      if ((flags & (CLEAN | UNOWNED)) !== 0) {
        if ((flags & DERIVED) !== 0) {
          mark_reactions(
            /** @type {Derived} */
            reaction,
            MAYBE_DIRTY
          );
        } else {
          schedule_effect(
            /** @type {Effect} */
            reaction
          );
        }
      }
    }
  }

  // node_modules/svelte/src/internal/client/dom/hydration.js
  var hydrating = false;
  function set_hydrating(value) {
    hydrating = value;
  }
  var hydrate_node;
  function set_hydrate_node(node) {
    if (node === null) {
      hydration_mismatch();
      throw HYDRATION_ERROR;
    }
    return hydrate_node = node;
  }
  function hydrate_next() {
    return set_hydrate_node(
      /** @type {TemplateNode} */
      get_next_sibling(hydrate_node)
    );
  }
  function reset(node) {
    if (!hydrating) return;
    if (get_next_sibling(hydrate_node) !== null) {
      hydration_mismatch();
      throw HYDRATION_ERROR;
    }
    hydrate_node = node;
  }
  function next(count3 = 1) {
    if (hydrating) {
      var i = count3;
      var node = hydrate_node;
      while (i--) {
        node = /** @type {TemplateNode} */
        get_next_sibling(node);
      }
      hydrate_node = node;
    }
  }
  function remove_nodes() {
    var depth = 0;
    var node = hydrate_node;
    while (true) {
      if (node.nodeType === 8) {
        var data2 = (
          /** @type {Comment} */
          node.data
        );
        if (data2 === HYDRATION_END) {
          if (depth === 0) return node;
          depth -= 1;
        } else if (data2 === HYDRATION_START || data2 === HYDRATION_START_ELSE) {
          depth += 1;
        }
      }
      var next2 = (
        /** @type {TemplateNode} */
        get_next_sibling(node)
      );
      node.remove();
      node = next2;
    }
  }

  // node_modules/svelte/src/internal/client/proxy.js
  function proxy(value, parent = null, prev) {
    var stack2 = null;
    if (dev_fallback_default && tracing_mode_flag) {
      stack2 = get_stack("CreatedAt");
    }
    if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
      return value;
    }
    const prototype = get_prototype_of(value);
    if (prototype !== object_prototype && prototype !== array_prototype) {
      return value;
    }
    var sources = /* @__PURE__ */ new Map();
    var is_proxied_array = is_array(value);
    var version = source(0);
    if (is_proxied_array) {
      sources.set("length", source(
        /** @type {any[]} */
        value.length,
        stack2
      ));
    }
    var metadata;
    if (dev_fallback_default) {
      metadata = {
        parent,
        owners: null
      };
      if (prev) {
        const prev_owners = prev.v?.[STATE_SYMBOL_METADATA]?.owners;
        metadata.owners = prev_owners ? new Set(prev_owners) : null;
      } else {
        metadata.owners = parent === null ? component_context !== null ? /* @__PURE__ */ new Set([component_context.function]) : null : /* @__PURE__ */ new Set();
      }
    }
    return new Proxy(
      /** @type {any} */
      value,
      {
        defineProperty(_25, prop2, descriptor) {
          if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
            state_descriptors_fixed();
          }
          var s2 = sources.get(prop2);
          if (s2 === void 0) {
            s2 = source(descriptor.value, stack2);
            sources.set(prop2, s2);
          } else {
            set(s2, proxy(descriptor.value, metadata));
          }
          return true;
        },
        deleteProperty(target, prop2) {
          var s2 = sources.get(prop2);
          if (s2 === void 0) {
            if (prop2 in target) {
              sources.set(prop2, source(UNINITIALIZED, stack2));
            }
          } else {
            if (is_proxied_array && typeof prop2 === "string") {
              var ls = (
                /** @type {Source<number>} */
                sources.get("length")
              );
              var n = Number(prop2);
              if (Number.isInteger(n) && n < ls.v) {
                set(ls, n);
              }
            }
            set(s2, UNINITIALIZED);
            update_version(version);
          }
          return true;
        },
        get(target, prop2, receiver) {
          if (dev_fallback_default && prop2 === STATE_SYMBOL_METADATA) {
            return metadata;
          }
          if (prop2 === STATE_SYMBOL) {
            return value;
          }
          var s2 = sources.get(prop2);
          var exists = prop2 in target;
          if (s2 === void 0 && (!exists || get_descriptor(target, prop2)?.writable)) {
            s2 = source(proxy(exists ? target[prop2] : UNINITIALIZED, metadata), stack2);
            sources.set(prop2, s2);
          }
          if (s2 !== void 0) {
            var v3 = get(s2);
            if (dev_fallback_default) {
              var prop_metadata = v3?.[STATE_SYMBOL_METADATA];
              if (prop_metadata && prop_metadata?.parent !== metadata) {
                widen_ownership(metadata, prop_metadata);
              }
            }
            return v3 === UNINITIALIZED ? void 0 : v3;
          }
          return Reflect.get(target, prop2, receiver);
        },
        getOwnPropertyDescriptor(target, prop2) {
          var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
          if (descriptor && "value" in descriptor) {
            var s2 = sources.get(prop2);
            if (s2) descriptor.value = get(s2);
          } else if (descriptor === void 0) {
            var source2 = sources.get(prop2);
            var value2 = source2?.v;
            if (source2 !== void 0 && value2 !== UNINITIALIZED) {
              return {
                enumerable: true,
                configurable: true,
                value: value2,
                writable: true
              };
            }
          }
          return descriptor;
        },
        has(target, prop2) {
          if (dev_fallback_default && prop2 === STATE_SYMBOL_METADATA) {
            return true;
          }
          if (prop2 === STATE_SYMBOL) {
            return true;
          }
          var s2 = sources.get(prop2);
          var has = s2 !== void 0 && s2.v !== UNINITIALIZED || Reflect.has(target, prop2);
          if (s2 !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop2)?.writable)) {
            if (s2 === void 0) {
              s2 = source(has ? proxy(target[prop2], metadata) : UNINITIALIZED, stack2);
              sources.set(prop2, s2);
            }
            var value2 = get(s2);
            if (value2 === UNINITIALIZED) {
              return false;
            }
          }
          return has;
        },
        set(target, prop2, value2, receiver) {
          var s2 = sources.get(prop2);
          var has = prop2 in target;
          if (is_proxied_array && prop2 === "length") {
            for (var i = value2; i < /** @type {Source<number>} */
            s2.v; i += 1) {
              var other_s = sources.get(i + "");
              if (other_s !== void 0) {
                set(other_s, UNINITIALIZED);
              } else if (i in target) {
                other_s = source(UNINITIALIZED, stack2);
                sources.set(i + "", other_s);
              }
            }
          }
          if (s2 === void 0) {
            if (!has || get_descriptor(target, prop2)?.writable) {
              s2 = source(void 0, stack2);
              set(s2, proxy(value2, metadata));
              sources.set(prop2, s2);
            }
          } else {
            has = s2.v !== UNINITIALIZED;
            set(s2, proxy(value2, metadata));
          }
          if (dev_fallback_default) {
            var prop_metadata = value2?.[STATE_SYMBOL_METADATA];
            if (prop_metadata && prop_metadata?.parent !== metadata) {
              widen_ownership(metadata, prop_metadata);
            }
            check_ownership(metadata);
          }
          var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
          if (descriptor?.set) {
            descriptor.set.call(receiver, value2);
          }
          if (!has) {
            if (is_proxied_array && typeof prop2 === "string") {
              var ls = (
                /** @type {Source<number>} */
                sources.get("length")
              );
              var n = Number(prop2);
              if (Number.isInteger(n) && n >= ls.v) {
                set(ls, n + 1);
              }
            }
            update_version(version);
          }
          return true;
        },
        ownKeys(target) {
          get(version);
          var own_keys = Reflect.ownKeys(target).filter((key2) => {
            var source3 = sources.get(key2);
            return source3 === void 0 || source3.v !== UNINITIALIZED;
          });
          for (var [key, source2] of sources) {
            if (source2.v !== UNINITIALIZED && !(key in target)) {
              own_keys.push(key);
            }
          }
          return own_keys;
        },
        setPrototypeOf() {
          state_prototype_fixed();
        }
      }
    );
  }
  function update_version(signal, d = 1) {
    set(signal, signal.v + d);
  }
  function get_proxied_value(value) {
    if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
      return value[STATE_SYMBOL];
    }
    return value;
  }
  function is(a4, b10) {
    return Object.is(get_proxied_value(a4), get_proxied_value(b10));
  }

  // node_modules/svelte/src/internal/client/dev/equality.js
  function init_array_prototype_warnings() {
    const array_prototype2 = Array.prototype;
    const cleanup = Array.__svelte_cleanup;
    if (cleanup) {
      cleanup();
    }
    const { indexOf, lastIndexOf, includes } = array_prototype2;
    array_prototype2.indexOf = function(item, from_index) {
      const index4 = indexOf.call(this, item, from_index);
      if (index4 === -1) {
        for (let i = from_index ?? 0; i < this.length; i += 1) {
          if (get_proxied_value(this[i]) === item) {
            state_proxy_equality_mismatch("array.indexOf(...)");
            break;
          }
        }
      }
      return index4;
    };
    array_prototype2.lastIndexOf = function(item, from_index) {
      const index4 = lastIndexOf.call(this, item, from_index ?? this.length - 1);
      if (index4 === -1) {
        for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
          if (get_proxied_value(this[i]) === item) {
            state_proxy_equality_mismatch("array.lastIndexOf(...)");
            break;
          }
        }
      }
      return index4;
    };
    array_prototype2.includes = function(item, from_index) {
      const has = includes.call(this, item, from_index);
      if (!has) {
        for (let i = 0; i < this.length; i += 1) {
          if (get_proxied_value(this[i]) === item) {
            state_proxy_equality_mismatch("array.includes(...)");
            break;
          }
        }
      }
      return has;
    };
    Array.__svelte_cleanup = () => {
      array_prototype2.indexOf = indexOf;
      array_prototype2.lastIndexOf = lastIndexOf;
      array_prototype2.includes = includes;
    };
  }

  // node_modules/svelte/src/internal/client/dom/operations.js
  var $window;
  var $document;
  var is_firefox;
  var first_child_getter;
  var next_sibling_getter;
  function init_operations() {
    if ($window !== void 0) {
      return;
    }
    $window = window;
    $document = document;
    is_firefox = /Firefox/.test(navigator.userAgent);
    var element_prototype = Element.prototype;
    var node_prototype = Node.prototype;
    first_child_getter = get_descriptor(node_prototype, "firstChild").get;
    next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__styles = null;
    element_prototype.__e = void 0;
    Text.prototype.__t = void 0;
    if (dev_fallback_default) {
      element_prototype.__svelte_meta = null;
      init_array_prototype_warnings();
    }
  }
  function create_text(value = "") {
    return document.createTextNode(value);
  }
  // @__NO_SIDE_EFFECTS__
  function get_first_child(node) {
    return first_child_getter.call(node);
  }
  // @__NO_SIDE_EFFECTS__
  function get_next_sibling(node) {
    return next_sibling_getter.call(node);
  }
  function child(node, is_text) {
    if (!hydrating) {
      return /* @__PURE__ */ get_first_child(node);
    }
    var child2 = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_first_child(hydrate_node)
    );
    if (child2 === null) {
      child2 = hydrate_node.appendChild(create_text());
    } else if (is_text && child2.nodeType !== 3) {
      var text2 = create_text();
      child2?.before(text2);
      set_hydrate_node(text2);
      return text2;
    }
    set_hydrate_node(child2);
    return child2;
  }
  function first_child(fragment, is_text) {
    if (!hydrating) {
      var first = (
        /** @type {DocumentFragment} */
        /* @__PURE__ */ get_first_child(
          /** @type {Node} */
          fragment
        )
      );
      if (first instanceof Comment && first.data === "") return /* @__PURE__ */ get_next_sibling(first);
      return first;
    }
    if (is_text && hydrate_node?.nodeType !== 3) {
      var text2 = create_text();
      hydrate_node?.before(text2);
      set_hydrate_node(text2);
      return text2;
    }
    return hydrate_node;
  }
  function sibling(node, count3 = 1, is_text = false) {
    let next_sibling = hydrating ? hydrate_node : node;
    var last_sibling;
    while (count3--) {
      last_sibling = next_sibling;
      next_sibling = /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(next_sibling);
    }
    if (!hydrating) {
      return next_sibling;
    }
    var type2 = next_sibling?.nodeType;
    if (is_text && type2 !== 3) {
      var text2 = create_text();
      if (next_sibling === null) {
        last_sibling?.after(text2);
      } else {
        next_sibling.before(text2);
      }
      set_hydrate_node(text2);
      return text2;
    }
    set_hydrate_node(next_sibling);
    return (
      /** @type {TemplateNode} */
      next_sibling
    );
  }
  function clear_text_content(node) {
    node.textContent = "";
  }

  // node_modules/svelte/src/internal/client/reactivity/deriveds.js
  // @__NO_SIDE_EFFECTS__
  function derived(fn) {
    var flags = DERIVED | DIRTY;
    var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
      /** @type {Derived} */
      active_reaction
    ) : null;
    if (active_effect === null || parent_derived !== null && (parent_derived.f & UNOWNED) !== 0) {
      flags |= UNOWNED;
    } else {
      active_effect.f |= EFFECT_HAS_DERIVED;
    }
    const signal = {
      ctx: component_context,
      deps: null,
      effects: null,
      equals,
      f: flags,
      fn,
      reactions: null,
      rv: 0,
      v: (
        /** @type {V} */
        null
      ),
      wv: 0,
      parent: parent_derived ?? active_effect
    };
    if (dev_fallback_default && tracing_mode_flag) {
      signal.created = get_stack("CreatedAt");
    }
    return signal;
  }
  // @__NO_SIDE_EFFECTS__
  function derived_safe_equal(fn) {
    const signal = /* @__PURE__ */ derived(fn);
    signal.equals = safe_equals;
    return signal;
  }
  function destroy_derived_effects(derived3) {
    var effects = derived3.effects;
    if (effects !== null) {
      derived3.effects = null;
      for (var i = 0; i < effects.length; i += 1) {
        destroy_effect(
          /** @type {Effect} */
          effects[i]
        );
      }
    }
  }
  var stack = [];
  function get_derived_parent_effect(derived3) {
    var parent = derived3.parent;
    while (parent !== null) {
      if ((parent.f & DERIVED) === 0) {
        return (
          /** @type {Effect} */
          parent
        );
      }
      parent = parent.parent;
    }
    return null;
  }
  function execute_derived(derived3) {
    var value;
    var prev_active_effect = active_effect;
    set_active_effect(get_derived_parent_effect(derived3));
    if (dev_fallback_default) {
      let prev_inspect_effects = inspect_effects;
      set_inspect_effects(/* @__PURE__ */ new Set());
      try {
        if (stack.includes(derived3)) {
          derived_references_self();
        }
        stack.push(derived3);
        destroy_derived_effects(derived3);
        value = update_reaction(derived3);
      } finally {
        set_active_effect(prev_active_effect);
        set_inspect_effects(prev_inspect_effects);
        stack.pop();
      }
    } else {
      try {
        destroy_derived_effects(derived3);
        value = update_reaction(derived3);
      } finally {
        set_active_effect(prev_active_effect);
      }
    }
    return value;
  }
  function update_derived(derived3) {
    var value = execute_derived(derived3);
    var status = (skip_reaction || (derived3.f & UNOWNED) !== 0) && derived3.deps !== null ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived3, status);
    if (!derived3.equals(value)) {
      derived3.v = value;
      derived3.wv = increment_write_version();
    }
  }

  // node_modules/svelte/src/internal/client/reactivity/effects.js
  function validate_effect(rune) {
    if (active_effect === null && active_reaction === null) {
      effect_orphan(rune);
    }
    if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
      effect_in_unowned_derived();
    }
    if (is_destroying_effect) {
      effect_in_teardown(rune);
    }
  }
  function push_effect(effect2, parent_effect) {
    var parent_last = parent_effect.last;
    if (parent_last === null) {
      parent_effect.last = parent_effect.first = effect2;
    } else {
      parent_last.next = effect2;
      effect2.prev = parent_last;
      parent_effect.last = effect2;
    }
  }
  function create_effect(type2, fn, sync, push2 = true) {
    var is_root = (type2 & ROOT_EFFECT) !== 0;
    var parent_effect = active_effect;
    if (dev_fallback_default) {
      while (parent_effect !== null && (parent_effect.f & INSPECT_EFFECT) !== 0) {
        parent_effect = parent_effect.parent;
      }
    }
    var effect2 = {
      ctx: component_context,
      deps: null,
      nodes_start: null,
      nodes_end: null,
      f: type2 | DIRTY,
      first: null,
      fn,
      last: null,
      next: null,
      parent: is_root ? null : parent_effect,
      prev: null,
      teardown: null,
      transitions: null,
      wv: 0
    };
    if (dev_fallback_default) {
      effect2.component_function = dev_current_component_function;
    }
    if (sync) {
      try {
        update_effect(effect2);
        effect2.f |= EFFECT_RAN;
      } catch (e) {
        destroy_effect(effect2);
        throw e;
      }
    } else if (fn !== null) {
      schedule_effect(effect2);
    }
    var inert = sync && effect2.deps === null && effect2.first === null && effect2.nodes_start === null && effect2.teardown === null && (effect2.f & (EFFECT_HAS_DERIVED | BOUNDARY_EFFECT)) === 0;
    if (!inert && !is_root && push2) {
      if (parent_effect !== null) {
        push_effect(effect2, parent_effect);
      }
      if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
        var derived3 = (
          /** @type {Derived} */
          active_reaction
        );
        (derived3.effects ??= []).push(effect2);
      }
    }
    return effect2;
  }
  function teardown(fn) {
    const effect2 = create_effect(RENDER_EFFECT, null, false);
    set_signal_status(effect2, CLEAN);
    effect2.teardown = fn;
    return effect2;
  }
  function user_effect(fn) {
    validate_effect("$effect");
    var defer = active_effect !== null && (active_effect.f & BRANCH_EFFECT) !== 0 && component_context !== null && !component_context.m;
    if (dev_fallback_default) {
      define_property(fn, "name", {
        value: "$effect"
      });
    }
    if (defer) {
      var context = (
        /** @type {ComponentContext} */
        component_context
      );
      (context.e ??= []).push({
        fn,
        effect: active_effect,
        reaction: active_reaction
      });
    } else {
      var signal = effect(fn);
      return signal;
    }
  }
  function user_pre_effect(fn) {
    validate_effect("$effect.pre");
    if (dev_fallback_default) {
      define_property(fn, "name", {
        value: "$effect.pre"
      });
    }
    return render_effect(fn);
  }
  function effect_root(fn) {
    const effect2 = create_effect(ROOT_EFFECT, fn, true);
    return () => {
      destroy_effect(effect2);
    };
  }
  function component_root(fn) {
    const effect2 = create_effect(ROOT_EFFECT, fn, true);
    return (options = {}) => {
      return new Promise((fulfil) => {
        if (options.outro) {
          pause_effect(effect2, () => {
            destroy_effect(effect2);
            fulfil(void 0);
          });
        } else {
          destroy_effect(effect2);
          fulfil(void 0);
        }
      });
    };
  }
  function effect(fn) {
    return create_effect(EFFECT, fn, false);
  }
  function legacy_pre_effect(deps, fn) {
    var context = (
      /** @type {ComponentContextLegacy} */
      component_context
    );
    var token = { effect: null, ran: false };
    context.l.r1.push(token);
    token.effect = render_effect(() => {
      deps();
      if (token.ran) return;
      token.ran = true;
      set(context.l.r2, true);
      untrack(fn);
    });
  }
  function legacy_pre_effect_reset() {
    var context = (
      /** @type {ComponentContextLegacy} */
      component_context
    );
    render_effect(() => {
      if (!get(context.l.r2)) return;
      for (var token of context.l.r1) {
        var effect2 = token.effect;
        if ((effect2.f & CLEAN) !== 0) {
          set_signal_status(effect2, MAYBE_DIRTY);
        }
        if (check_dirtiness(effect2)) {
          update_effect(effect2);
        }
        token.ran = false;
      }
      context.l.r2.v = false;
    });
  }
  function render_effect(fn) {
    return create_effect(RENDER_EFFECT, fn, true);
  }
  function template_effect(fn, thunks = [], d = derived) {
    const deriveds = thunks.map(d);
    const effect2 = () => fn(...deriveds.map(get));
    if (dev_fallback_default) {
      define_property(effect2, "name", {
        value: "{expression}"
      });
    }
    return block(effect2);
  }
  function block(fn, flags = 0) {
    return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
  }
  function branch(fn, push2 = true) {
    return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push2);
  }
  function execute_effect_teardown(effect2) {
    var teardown2 = effect2.teardown;
    if (teardown2 !== null) {
      const previously_destroying_effect = is_destroying_effect;
      const previous_reaction = active_reaction;
      set_is_destroying_effect(true);
      set_active_reaction(null);
      try {
        teardown2.call(null);
      } finally {
        set_is_destroying_effect(previously_destroying_effect);
        set_active_reaction(previous_reaction);
      }
    }
  }
  function destroy_effect_children(signal, remove_dom = false) {
    var effect2 = signal.first;
    signal.first = signal.last = null;
    while (effect2 !== null) {
      var next2 = effect2.next;
      destroy_effect(effect2, remove_dom);
      effect2 = next2;
    }
  }
  function destroy_block_effect_children(signal) {
    var effect2 = signal.first;
    while (effect2 !== null) {
      var next2 = effect2.next;
      if ((effect2.f & BRANCH_EFFECT) === 0) {
        destroy_effect(effect2);
      }
      effect2 = next2;
    }
  }
  function destroy_effect(effect2, remove_dom = true) {
    var removed = false;
    if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes_start !== null) {
      var node = effect2.nodes_start;
      var end = effect2.nodes_end;
      while (node !== null) {
        var next2 = node === end ? null : (
          /** @type {TemplateNode} */
          get_next_sibling(node)
        );
        node.remove();
        node = next2;
      }
      removed = true;
    }
    destroy_effect_children(effect2, remove_dom && !removed);
    remove_reactions(effect2, 0);
    set_signal_status(effect2, DESTROYED);
    var transitions = effect2.transitions;
    if (transitions !== null) {
      for (const transition3 of transitions) {
        transition3.stop();
      }
    }
    execute_effect_teardown(effect2);
    var parent = effect2.parent;
    if (parent !== null && parent.first !== null) {
      unlink_effect(effect2);
    }
    if (dev_fallback_default) {
      effect2.component_function = null;
    }
    effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes_start = effect2.nodes_end = null;
  }
  function unlink_effect(effect2) {
    var parent = effect2.parent;
    var prev = effect2.prev;
    var next2 = effect2.next;
    if (prev !== null) prev.next = next2;
    if (next2 !== null) next2.prev = prev;
    if (parent !== null) {
      if (parent.first === effect2) parent.first = next2;
      if (parent.last === effect2) parent.last = prev;
    }
  }
  function pause_effect(effect2, callback) {
    var transitions = [];
    pause_children(effect2, transitions, true);
    run_out_transitions(transitions, () => {
      destroy_effect(effect2);
      if (callback) callback();
    });
  }
  function run_out_transitions(transitions, fn) {
    var remaining = transitions.length;
    if (remaining > 0) {
      var check = () => --remaining || fn();
      for (var transition3 of transitions) {
        transition3.out(check);
      }
    } else {
      fn();
    }
  }
  function pause_children(effect2, transitions, local3) {
    if ((effect2.f & INERT) !== 0) return;
    effect2.f ^= INERT;
    if (effect2.transitions !== null) {
      for (const transition3 of effect2.transitions) {
        if (transition3.is_global || local3) {
          transitions.push(transition3);
        }
      }
    }
    var child2 = effect2.first;
    while (child2 !== null) {
      var sibling2 = child2.next;
      var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
      pause_children(child2, transitions, transparent ? local3 : false);
      child2 = sibling2;
    }
  }
  function resume_effect(effect2) {
    resume_children(effect2, true);
  }
  function resume_children(effect2, local3) {
    if ((effect2.f & INERT) === 0) return;
    effect2.f ^= INERT;
    if ((effect2.f & CLEAN) === 0) {
      effect2.f ^= CLEAN;
    }
    if (check_dirtiness(effect2)) {
      set_signal_status(effect2, DIRTY);
      schedule_effect(effect2);
    }
    var child2 = effect2.first;
    while (child2 !== null) {
      var sibling2 = child2.next;
      var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
      resume_children(child2, transparent ? local3 : false);
      child2 = sibling2;
    }
    if (effect2.transitions !== null) {
      for (const transition3 of effect2.transitions) {
        if (transition3.is_global || local3) {
          transition3.in();
        }
      }
    }
  }

  // node_modules/svelte/src/internal/client/dom/task.js
  var request_idle_callback = typeof requestIdleCallback === "undefined" ? (cb) => setTimeout(cb, 1) : requestIdleCallback;
  var micro_tasks = [];
  var idle_tasks = [];
  function run_micro_tasks() {
    var tasks = micro_tasks;
    micro_tasks = [];
    run_all(tasks);
  }
  function run_idle_tasks() {
    var tasks = idle_tasks;
    idle_tasks = [];
    run_all(tasks);
  }
  function queue_micro_task(fn) {
    if (micro_tasks.length === 0) {
      queueMicrotask(run_micro_tasks);
    }
    micro_tasks.push(fn);
  }
  function queue_idle_task(fn) {
    if (idle_tasks.length === 0) {
      request_idle_callback(run_idle_tasks);
    }
    idle_tasks.push(fn);
  }
  function flush_tasks() {
    if (micro_tasks.length > 0) {
      run_micro_tasks();
    }
    if (idle_tasks.length > 0) {
      run_idle_tasks();
    }
  }

  // node_modules/svelte/src/internal/client/runtime.js
  var handled_errors = /* @__PURE__ */ new WeakSet();
  var is_throwing_error = false;
  var is_flushing = false;
  var last_scheduled_effect = null;
  var is_updating_effect = false;
  var is_destroying_effect = false;
  function set_is_destroying_effect(value) {
    is_destroying_effect = value;
  }
  var queued_root_effects = [];
  var dev_effect_stack = [];
  var active_reaction = null;
  var untracking = false;
  function set_active_reaction(reaction) {
    active_reaction = reaction;
  }
  var active_effect = null;
  function set_active_effect(effect2) {
    active_effect = effect2;
  }
  var derived_sources = null;
  function set_derived_sources(sources) {
    derived_sources = sources;
  }
  var new_deps = null;
  var skipped_deps = 0;
  var untracked_writes = null;
  function set_untracked_writes(value) {
    untracked_writes = value;
  }
  var write_version = 1;
  var read_version = 0;
  var skip_reaction = false;
  var captured_signals = null;
  function increment_write_version() {
    return ++write_version;
  }
  function check_dirtiness(reaction) {
    var flags = reaction.f;
    if ((flags & DIRTY) !== 0) {
      return true;
    }
    if ((flags & MAYBE_DIRTY) !== 0) {
      var dependencies = reaction.deps;
      var is_unowned = (flags & UNOWNED) !== 0;
      if (dependencies !== null) {
        var i;
        var dependency;
        var is_disconnected = (flags & DISCONNECTED) !== 0;
        var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
        var length3 = dependencies.length;
        if (is_disconnected || is_unowned_connected) {
          var derived3 = (
            /** @type {Derived} */
            reaction
          );
          var parent = derived3.parent;
          for (i = 0; i < length3; i++) {
            dependency = dependencies[i];
            if (is_disconnected || !dependency?.reactions?.includes(derived3)) {
              (dependency.reactions ??= []).push(derived3);
            }
          }
          if (is_disconnected) {
            derived3.f ^= DISCONNECTED;
          }
          if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
            derived3.f ^= UNOWNED;
          }
        }
        for (i = 0; i < length3; i++) {
          dependency = dependencies[i];
          if (check_dirtiness(
            /** @type {Derived} */
            dependency
          )) {
            update_derived(
              /** @type {Derived} */
              dependency
            );
          }
          if (dependency.wv > reaction.wv) {
            return true;
          }
        }
      }
      if (!is_unowned || active_effect !== null && !skip_reaction) {
        set_signal_status(reaction, CLEAN);
      }
    }
    return false;
  }
  function propagate_error(error, effect2) {
    var current = effect2;
    while (current !== null) {
      if ((current.f & BOUNDARY_EFFECT) !== 0) {
        try {
          current.fn(error);
          return;
        } catch {
          current.f ^= BOUNDARY_EFFECT;
        }
      }
      current = current.parent;
    }
    is_throwing_error = false;
    throw error;
  }
  function should_rethrow_error(effect2) {
    return (effect2.f & DESTROYED) === 0 && (effect2.parent === null || (effect2.parent.f & BOUNDARY_EFFECT) === 0);
  }
  function handle_error(error, effect2, previous_effect, component_context2) {
    if (is_throwing_error) {
      if (previous_effect === null) {
        is_throwing_error = false;
      }
      if (should_rethrow_error(effect2)) {
        throw error;
      }
      return;
    }
    if (previous_effect !== null) {
      is_throwing_error = true;
    }
    if (!dev_fallback_default || component_context2 === null || !(error instanceof Error) || handled_errors.has(error)) {
      propagate_error(error, effect2);
      return;
    }
    handled_errors.add(error);
    const component_stack = [];
    const effect_name = effect2.fn?.name;
    if (effect_name) {
      component_stack.push(effect_name);
    }
    let current_context = component_context2;
    while (current_context !== null) {
      if (dev_fallback_default) {
        var filename = current_context.function?.[FILENAME];
        if (filename) {
          const file = filename.split("/").pop();
          component_stack.push(file);
        }
      }
      current_context = current_context.p;
    }
    const indent = is_firefox ? "  " : "	";
    define_property(error, "message", {
      value: error.message + `
${component_stack.map((name) => `
${indent}in ${name}`).join("")}
`
    });
    define_property(error, "component_stack", {
      value: component_stack
    });
    const stack2 = error.stack;
    if (stack2) {
      const lines = stack2.split("\n");
      const new_lines = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.includes("svelte/src/internal")) {
          continue;
        }
        new_lines.push(line);
      }
      define_property(error, "stack", {
        value: new_lines.join("\n")
      });
    }
    propagate_error(error, effect2);
    if (should_rethrow_error(effect2)) {
      throw error;
    }
  }
  function schedule_possible_effect_self_invalidation(signal, effect2, root21 = true) {
    var reactions = signal.reactions;
    if (reactions === null) return;
    for (var i = 0; i < reactions.length; i++) {
      var reaction = reactions[i];
      if ((reaction.f & DERIVED) !== 0) {
        schedule_possible_effect_self_invalidation(
          /** @type {Derived} */
          reaction,
          effect2,
          false
        );
      } else if (effect2 === reaction) {
        if (root21) {
          set_signal_status(reaction, DIRTY);
        } else if ((reaction.f & CLEAN) !== 0) {
          set_signal_status(reaction, MAYBE_DIRTY);
        }
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
  function update_reaction(reaction) {
    var previous_deps = new_deps;
    var previous_skipped_deps = skipped_deps;
    var previous_untracked_writes = untracked_writes;
    var previous_reaction = active_reaction;
    var previous_skip_reaction = skip_reaction;
    var prev_derived_sources = derived_sources;
    var previous_component_context = component_context;
    var previous_untracking = untracking;
    var flags = reaction.f;
    new_deps = /** @type {null | Value[]} */
    null;
    skipped_deps = 0;
    untracked_writes = null;
    skip_reaction = (flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
    active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
    derived_sources = null;
    set_component_context(reaction.ctx);
    untracking = false;
    read_version++;
    try {
      var result = (
        /** @type {Function} */
        (0, reaction.fn)()
      );
      var deps = reaction.deps;
      if (new_deps !== null) {
        var i;
        remove_reactions(reaction, skipped_deps);
        if (deps !== null && skipped_deps > 0) {
          deps.length = skipped_deps + new_deps.length;
          for (i = 0; i < new_deps.length; i++) {
            deps[skipped_deps + i] = new_deps[i];
          }
        } else {
          reaction.deps = deps = new_deps;
        }
        if (!skip_reaction) {
          for (i = skipped_deps; i < deps.length; i++) {
            (deps[i].reactions ??= []).push(reaction);
          }
        }
      } else if (deps !== null && skipped_deps < deps.length) {
        remove_reactions(reaction, skipped_deps);
        deps.length = skipped_deps;
      }
      if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
        for (i = 0; i < /** @type {Source[]} */
        untracked_writes.length; i++) {
          schedule_possible_effect_self_invalidation(
            untracked_writes[i],
            /** @type {Effect} */
            reaction
          );
        }
      }
      if (previous_reaction !== null) {
        read_version++;
      }
      return result;
    } finally {
      new_deps = previous_deps;
      skipped_deps = previous_skipped_deps;
      untracked_writes = previous_untracked_writes;
      active_reaction = previous_reaction;
      skip_reaction = previous_skip_reaction;
      derived_sources = prev_derived_sources;
      set_component_context(previous_component_context);
      untracking = previous_untracking;
    }
  }
  function remove_reaction(signal, dependency) {
    let reactions = dependency.reactions;
    if (reactions !== null) {
      var index4 = index_of.call(reactions, signal);
      if (index4 !== -1) {
        var new_length = reactions.length - 1;
        if (new_length === 0) {
          reactions = dependency.reactions = null;
        } else {
          reactions[index4] = reactions[new_length];
          reactions.pop();
        }
      }
    }
    if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
    // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
    // allows us to skip the expensive work of disconnecting and immediately reconnecting it
    (new_deps === null || !new_deps.includes(dependency))) {
      set_signal_status(dependency, MAYBE_DIRTY);
      if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
        dependency.f ^= DISCONNECTED;
      }
      destroy_derived_effects(
        /** @type {Derived} **/
        dependency
      );
      remove_reactions(
        /** @type {Derived} **/
        dependency,
        0
      );
    }
  }
  function remove_reactions(signal, start_index) {
    var dependencies = signal.deps;
    if (dependencies === null) return;
    for (var i = start_index; i < dependencies.length; i++) {
      remove_reaction(signal, dependencies[i]);
    }
  }
  function update_effect(effect2) {
    var flags = effect2.f;
    if ((flags & DESTROYED) !== 0) {
      return;
    }
    set_signal_status(effect2, CLEAN);
    var previous_effect = active_effect;
    var previous_component_context = component_context;
    var was_updating_effect = is_updating_effect;
    active_effect = effect2;
    is_updating_effect = true;
    if (dev_fallback_default) {
      var previous_component_fn = dev_current_component_function;
      set_dev_current_component_function(effect2.component_function);
    }
    try {
      if ((flags & BLOCK_EFFECT) !== 0) {
        destroy_block_effect_children(effect2);
      } else {
        destroy_effect_children(effect2);
      }
      execute_effect_teardown(effect2);
      var teardown2 = update_reaction(effect2);
      effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
      effect2.wv = write_version;
      var deps = effect2.deps;
      if (dev_fallback_default && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && deps !== null) {
        for (let i = 0; i < deps.length; i++) {
          var dep = deps[i];
          if (dep.trace_need_increase) {
            dep.wv = increment_write_version();
            dep.trace_need_increase = void 0;
            dep.trace_v = void 0;
          }
        }
      }
      if (dev_fallback_default) {
        dev_effect_stack.push(effect2);
      }
    } catch (error) {
      handle_error(error, effect2, previous_effect, previous_component_context || effect2.ctx);
    } finally {
      is_updating_effect = was_updating_effect;
      active_effect = previous_effect;
      if (dev_fallback_default) {
        set_dev_current_component_function(previous_component_fn);
      }
    }
  }
  function log_effect_stack() {
    console.error(
      "Last ten effects were: ",
      dev_effect_stack.slice(-10).map((d) => d.fn)
    );
    dev_effect_stack = [];
  }
  function infinite_loop_guard() {
    try {
      effect_update_depth_exceeded();
    } catch (error) {
      if (dev_fallback_default) {
        define_property(error, "stack", {
          value: ""
        });
      }
      if (last_scheduled_effect !== null) {
        if (dev_fallback_default) {
          try {
            handle_error(error, last_scheduled_effect, null, null);
          } catch (e) {
            log_effect_stack();
            throw e;
          }
        } else {
          handle_error(error, last_scheduled_effect, null, null);
        }
      } else {
        if (dev_fallback_default) {
          log_effect_stack();
        }
        throw error;
      }
    }
  }
  function flush_queued_root_effects() {
    try {
      var flush_count = 0;
      while (queued_root_effects.length > 0) {
        if (flush_count++ > 1e3) {
          infinite_loop_guard();
        }
        var root_effects = queued_root_effects;
        var length3 = root_effects.length;
        queued_root_effects = [];
        for (var i = 0; i < length3; i++) {
          var root21 = root_effects[i];
          if ((root21.f & CLEAN) === 0) {
            root21.f ^= CLEAN;
          }
          var collected_effects = process_effects(root21);
          flush_queued_effects(collected_effects);
        }
      }
    } finally {
      is_flushing = false;
      last_scheduled_effect = null;
      if (dev_fallback_default) {
        dev_effect_stack = [];
      }
    }
  }
  function flush_queued_effects(effects) {
    var length3 = effects.length;
    if (length3 === 0) return;
    for (var i = 0; i < length3; i++) {
      var effect2 = effects[i];
      if ((effect2.f & (DESTROYED | INERT)) === 0) {
        try {
          if (check_dirtiness(effect2)) {
            update_effect(effect2);
            if (effect2.deps === null && effect2.first === null && effect2.nodes_start === null) {
              if (effect2.teardown === null) {
                unlink_effect(effect2);
              } else {
                effect2.fn = null;
              }
            }
          }
        } catch (error) {
          handle_error(error, effect2, null, effect2.ctx);
        }
      }
    }
  }
  function schedule_effect(signal) {
    if (!is_flushing) {
      is_flushing = true;
      queueMicrotask(flush_queued_root_effects);
    }
    var effect2 = last_scheduled_effect = signal;
    while (effect2.parent !== null) {
      effect2 = effect2.parent;
      var flags = effect2.f;
      if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
        if ((flags & CLEAN) === 0) return;
        effect2.f ^= CLEAN;
      }
    }
    queued_root_effects.push(effect2);
  }
  function process_effects(root21) {
    var effects = [];
    var effect2 = root21.first;
    while (effect2 !== null) {
      var flags = effect2.f;
      var is_branch = (flags & BRANCH_EFFECT) !== 0;
      var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;
      if (!is_skippable_branch && (flags & INERT) === 0) {
        if ((flags & EFFECT) !== 0) {
          effects.push(effect2);
        } else if (is_branch) {
          effect2.f ^= CLEAN;
        } else {
          var previous_active_reaction = active_reaction;
          try {
            active_reaction = effect2;
            if (check_dirtiness(effect2)) {
              update_effect(effect2);
            }
          } catch (error) {
            handle_error(error, effect2, null, effect2.ctx);
          } finally {
            active_reaction = previous_active_reaction;
          }
        }
        var child2 = effect2.first;
        if (child2 !== null) {
          effect2 = child2;
          continue;
        }
      }
      var parent = effect2.parent;
      effect2 = effect2.next;
      while (effect2 === null && parent !== null) {
        effect2 = parent.next;
        parent = parent.parent;
      }
    }
    return effects;
  }
  function flushSync(fn) {
    var result;
    if (fn) {
      is_flushing = true;
      flush_queued_root_effects();
      result = fn();
    }
    flush_tasks();
    while (queued_root_effects.length > 0) {
      is_flushing = true;
      flush_queued_root_effects();
      flush_tasks();
    }
    return (
      /** @type {T} */
      result
    );
  }
  function get(signal) {
    var flags = signal.f;
    var is_derived = (flags & DERIVED) !== 0;
    if (captured_signals !== null) {
      captured_signals.add(signal);
    }
    if (active_reaction !== null && !untracking) {
      if (derived_sources !== null && derived_sources.includes(signal)) {
        state_unsafe_local_read();
      }
      var deps = active_reaction.deps;
      if (signal.rv < read_version) {
        signal.rv = read_version;
        if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
          skipped_deps++;
        } else if (new_deps === null) {
          new_deps = [signal];
        } else if (!skip_reaction || !new_deps.includes(signal)) {
          new_deps.push(signal);
        }
      }
    } else if (is_derived && /** @type {Derived} */
    signal.deps === null && /** @type {Derived} */
    signal.effects === null) {
      var derived3 = (
        /** @type {Derived} */
        signal
      );
      var parent = derived3.parent;
      if (parent !== null && (parent.f & UNOWNED) === 0) {
        derived3.f ^= UNOWNED;
      }
    }
    if (is_derived) {
      derived3 = /** @type {Derived} */
      signal;
      if (check_dirtiness(derived3)) {
        update_derived(derived3);
      }
    }
    if (dev_fallback_default && tracing_mode_flag && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
      if (signal.debug) {
        signal.debug();
      } else if (signal.created) {
        var entry = tracing_expressions.entries.get(signal);
        if (entry === void 0) {
          entry = { read: [] };
          tracing_expressions.entries.set(signal, entry);
        }
        entry.read.push(get_stack("TracedAt"));
      }
    }
    return signal.v;
  }
  function safe_get(signal) {
    return signal && get(signal);
  }
  function untrack(fn) {
    var previous_untracking = untracking;
    try {
      untracking = true;
      return fn();
    } finally {
      untracking = previous_untracking;
    }
  }
  var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
  function set_signal_status(signal, status) {
    signal.f = signal.f & STATUS_MASK | status;
  }
  function deep_read_state(value) {
    if (typeof value !== "object" || !value || value instanceof EventTarget) {
      return;
    }
    if (STATE_SYMBOL in value) {
      deep_read(value);
    } else if (!Array.isArray(value)) {
      for (let key in value) {
        const prop2 = value[key];
        if (typeof prop2 === "object" && prop2 && STATE_SYMBOL in prop2) {
          deep_read(prop2);
        }
      }
    }
  }
  function deep_read(value, visited = /* @__PURE__ */ new Set()) {
    if (typeof value === "object" && value !== null && // We don't want to traverse DOM elements
    !(value instanceof EventTarget) && !visited.has(value)) {
      visited.add(value);
      if (value instanceof Date) {
        value.getTime();
      }
      for (let key in value) {
        try {
          deep_read(value[key], visited);
        } catch (e) {
        }
      }
      const proto = get_prototype_of(value);
      if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
        const descriptors = get_descriptors(proto);
        for (let key in descriptors) {
          const get5 = descriptors[key].get;
          if (get5) {
            try {
              get5.call(value);
            } catch (e) {
            }
          }
        }
      }
    }
  }

  // node_modules/svelte/src/utils.js
  var DOM_BOOLEAN_ATTRIBUTES = [
    "allowfullscreen",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "disabled",
    "formnovalidate",
    "hidden",
    "indeterminate",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "seamless",
    "selected",
    "webkitdirectory",
    "defer",
    "disablepictureinpicture",
    "disableremoteplayback"
  ];
  var DOM_PROPERTIES = [
    ...DOM_BOOLEAN_ATTRIBUTES,
    "formNoValidate",
    "isMap",
    "noModule",
    "playsInline",
    "readOnly",
    "value",
    "volume",
    "defaultValue",
    "defaultChecked",
    "srcObject",
    "noValidate",
    "allowFullscreen",
    "disablePictureInPicture",
    "disableRemotePlayback"
  ];
  var PASSIVE_EVENTS = ["touchstart", "touchmove"];
  function is_passive_event(name) {
    return PASSIVE_EVENTS.includes(name);
  }

  // node_modules/svelte/src/internal/client/dom/elements/misc.js
  var listening_to_form_reset = false;
  function add_form_reset_listener() {
    if (!listening_to_form_reset) {
      listening_to_form_reset = true;
      document.addEventListener(
        "reset",
        (evt) => {
          Promise.resolve().then(() => {
            if (!evt.defaultPrevented) {
              for (
                const e of
                /**@type {HTMLFormElement} */
                evt.target.elements
              ) {
                e.__on_r?.();
              }
            }
          });
        },
        // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
        { capture: true }
      );
    }
  }

  // node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
  function without_reactive_context(fn) {
    var previous_reaction = active_reaction;
    var previous_effect = active_effect;
    set_active_reaction(null);
    set_active_effect(null);
    try {
      return fn();
    } finally {
      set_active_reaction(previous_reaction);
      set_active_effect(previous_effect);
    }
  }
  function listen_to_event_and_reset_event(element2, event2, handler, on_reset = handler) {
    element2.addEventListener(event2, () => without_reactive_context(handler));
    const prev = element2.__on_r;
    if (prev) {
      element2.__on_r = () => {
        prev();
        on_reset(true);
      };
    } else {
      element2.__on_r = () => on_reset(true);
    }
    add_form_reset_listener();
  }

  // node_modules/svelte/src/internal/client/dom/elements/events.js
  var all_registered_events = /* @__PURE__ */ new Set();
  var root_event_handles = /* @__PURE__ */ new Set();
  function create_event(event_name, dom, handler, options = {}) {
    function target_handler(event2) {
      if (!options.capture) {
        handle_event_propagation.call(dom, event2);
      }
      if (!event2.cancelBubble) {
        return without_reactive_context(() => {
          return handler?.call(this, event2);
        });
      }
    }
    if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
      queue_micro_task(() => {
        dom.addEventListener(event_name, target_handler, options);
      });
    } else {
      dom.addEventListener(event_name, target_handler, options);
    }
    return target_handler;
  }
  function event(event_name, dom, handler, capture, passive2) {
    var options = { capture, passive: passive2 };
    var target_handler = create_event(event_name, dom, handler, options);
    if (dom === document.body || dom === window || dom === document) {
      teardown(() => {
        dom.removeEventListener(event_name, target_handler, options);
      });
    }
  }
  function delegate(events) {
    for (var i = 0; i < events.length; i++) {
      all_registered_events.add(events[i]);
    }
    for (var fn of root_event_handles) {
      fn(events);
    }
  }
  function handle_event_propagation(event2) {
    var handler_element = this;
    var owner_document = (
      /** @type {Node} */
      handler_element.ownerDocument
    );
    var event_name = event2.type;
    var path2 = event2.composedPath?.() || [];
    var current_target = (
      /** @type {null | Element} */
      path2[0] || event2.target
    );
    var path_idx = 0;
    var handled_at = event2.__root;
    if (handled_at) {
      var at_idx = path2.indexOf(handled_at);
      if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
      window)) {
        event2.__root = handler_element;
        return;
      }
      var handler_idx = path2.indexOf(handler_element);
      if (handler_idx === -1) {
        return;
      }
      if (at_idx <= handler_idx) {
        path_idx = at_idx;
      }
    }
    current_target = /** @type {Element} */
    path2[path_idx] || event2.target;
    if (current_target === handler_element) return;
    define_property(event2, "currentTarget", {
      configurable: true,
      get() {
        return current_target || owner_document;
      }
    });
    var previous_reaction = active_reaction;
    var previous_effect = active_effect;
    set_active_reaction(null);
    set_active_effect(null);
    try {
      var throw_error;
      var other_errors = [];
      while (current_target !== null) {
        var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
        current_target.host || null;
        try {
          var delegated = current_target["__" + event_name];
          if (delegated !== void 0 && (!/** @type {any} */
          current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          event2.target === current_target)) {
            if (is_array(delegated)) {
              var [fn, ...data2] = delegated;
              fn.apply(current_target, [event2, ...data2]);
            } else {
              delegated.call(current_target, event2);
            }
          }
        } catch (error) {
          if (throw_error) {
            other_errors.push(error);
          } else {
            throw_error = error;
          }
        }
        if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
          break;
        }
        current_target = parent_element;
      }
      if (throw_error) {
        for (let error of other_errors) {
          queueMicrotask(() => {
            throw error;
          });
        }
        throw throw_error;
      }
    } finally {
      event2.__root = handler_element;
      delete event2.currentTarget;
      set_active_reaction(previous_reaction);
      set_active_effect(previous_effect);
    }
  }

  // node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
  var head_anchor;
  function reset_head_anchor() {
    head_anchor = void 0;
  }

  // node_modules/svelte/src/internal/client/dom/reconciler.js
  function create_fragment_from_html(html3) {
    var elem = document.createElement("template");
    elem.innerHTML = html3;
    return elem.content;
  }

  // node_modules/svelte/src/internal/client/dom/template.js
  function assign_nodes(start2, end) {
    var effect2 = (
      /** @type {Effect} */
      active_effect
    );
    if (effect2.nodes_start === null) {
      effect2.nodes_start = start2;
      effect2.nodes_end = end;
    }
  }
  // @__NO_SIDE_EFFECTS__
  function template(content, flags) {
    var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
    var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;
    var node;
    var has_start = !content.startsWith("<!>");
    return () => {
      if (hydrating) {
        assign_nodes(hydrate_node, null);
        return hydrate_node;
      }
      if (node === void 0) {
        node = create_fragment_from_html(has_start ? content : "<!>" + content);
        if (!is_fragment) node = /** @type {Node} */
        get_first_child(node);
      }
      var clone = (
        /** @type {TemplateNode} */
        use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
      );
      if (is_fragment) {
        var start2 = (
          /** @type {TemplateNode} */
          get_first_child(clone)
        );
        var end = (
          /** @type {TemplateNode} */
          clone.lastChild
        );
        assign_nodes(start2, end);
      } else {
        assign_nodes(clone, clone);
      }
      return clone;
    };
  }
  // @__NO_SIDE_EFFECTS__
  function ns_template(content, flags, ns = "svg") {
    var has_start = !content.startsWith("<!>");
    var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
    var wrapped = `<${ns}>${has_start ? content : "<!>" + content}</${ns}>`;
    var node;
    return () => {
      if (hydrating) {
        assign_nodes(hydrate_node, null);
        return hydrate_node;
      }
      if (!node) {
        var fragment = (
          /** @type {DocumentFragment} */
          create_fragment_from_html(wrapped)
        );
        var root21 = (
          /** @type {Element} */
          get_first_child(fragment)
        );
        if (is_fragment) {
          node = document.createDocumentFragment();
          while (get_first_child(root21)) {
            node.appendChild(
              /** @type {Node} */
              get_first_child(root21)
            );
          }
        } else {
          node = /** @type {Element} */
          get_first_child(root21);
        }
      }
      var clone = (
        /** @type {TemplateNode} */
        node.cloneNode(true)
      );
      if (is_fragment) {
        var start2 = (
          /** @type {TemplateNode} */
          get_first_child(clone)
        );
        var end = (
          /** @type {TemplateNode} */
          clone.lastChild
        );
        assign_nodes(start2, end);
      } else {
        assign_nodes(clone, clone);
      }
      return clone;
    };
  }
  function text(value = "") {
    if (!hydrating) {
      var t = create_text(value + "");
      assign_nodes(t, t);
      return t;
    }
    var node = hydrate_node;
    if (node.nodeType !== 3) {
      node.before(node = create_text());
      set_hydrate_node(node);
    }
    assign_nodes(node, node);
    return node;
  }
  function comment() {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    var frag = document.createDocumentFragment();
    var start2 = document.createComment("");
    var anchor = create_text();
    frag.append(start2, anchor);
    assign_nodes(start2, anchor);
    return frag;
  }
  function append(anchor, dom) {
    if (hydrating) {
      active_effect.nodes_end = hydrate_node;
      hydrate_next();
      return;
    }
    if (anchor === null) {
      return;
    }
    anchor.before(
      /** @type {Node} */
      dom
    );
  }

  // node_modules/svelte/src/internal/client/render.js
  var should_intro = true;
  function set_text(text2, value) {
    var str = value == null ? "" : typeof value === "object" ? value + "" : value;
    if (str !== (text2.__t ??= text2.nodeValue)) {
      text2.__t = str;
      text2.nodeValue = str + "";
    }
  }
  function mount(component2, options) {
    return _mount(component2, options);
  }
  function hydrate(component2, options) {
    init_operations();
    options.intro = options.intro ?? false;
    const target = options.target;
    const was_hydrating = hydrating;
    const previous_hydrate_node = hydrate_node;
    try {
      var anchor = (
        /** @type {TemplateNode} */
        get_first_child(target)
      );
      while (anchor && (anchor.nodeType !== 8 || /** @type {Comment} */
      anchor.data !== HYDRATION_START)) {
        anchor = /** @type {TemplateNode} */
        get_next_sibling(anchor);
      }
      if (!anchor) {
        throw HYDRATION_ERROR;
      }
      set_hydrating(true);
      set_hydrate_node(
        /** @type {Comment} */
        anchor
      );
      hydrate_next();
      const instance = _mount(component2, { ...options, anchor });
      if (hydrate_node === null || hydrate_node.nodeType !== 8 || /** @type {Comment} */
      hydrate_node.data !== HYDRATION_END) {
        hydration_mismatch();
        throw HYDRATION_ERROR;
      }
      set_hydrating(false);
      return (
        /**  @type {Exports} */
        instance
      );
    } catch (error) {
      if (error === HYDRATION_ERROR) {
        if (options.recover === false) {
          hydration_failed();
        }
        init_operations();
        clear_text_content(target);
        set_hydrating(false);
        return mount(component2, options);
      }
      throw error;
    } finally {
      set_hydrating(was_hydrating);
      set_hydrate_node(previous_hydrate_node);
      reset_head_anchor();
    }
  }
  var document_listeners = /* @__PURE__ */ new Map();
  function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
    init_operations();
    var registered_events = /* @__PURE__ */ new Set();
    var event_handle = (events2) => {
      for (var i = 0; i < events2.length; i++) {
        var event_name = events2[i];
        if (registered_events.has(event_name)) continue;
        registered_events.add(event_name);
        var passive2 = is_passive_event(event_name);
        target.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
        var n = document_listeners.get(event_name);
        if (n === void 0) {
          document.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
          document_listeners.set(event_name, 1);
        } else {
          document_listeners.set(event_name, n + 1);
        }
      }
    };
    event_handle(array_from(all_registered_events));
    root_event_handles.add(event_handle);
    var component2 = void 0;
    var unmount2 = component_root(() => {
      var anchor_node = anchor ?? target.appendChild(create_text());
      branch(() => {
        if (context) {
          push({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node,
            null
          );
        }
        should_intro = intro;
        component2 = Component(anchor_node, props) || {};
        should_intro = true;
        if (hydrating) {
          active_effect.nodes_end = hydrate_node;
        }
        if (context) {
          pop();
        }
      });
      return () => {
        for (var event_name of registered_events) {
          target.removeEventListener(event_name, handle_event_propagation);
          var n = (
            /** @type {number} */
            document_listeners.get(event_name)
          );
          if (--n === 0) {
            document.removeEventListener(event_name, handle_event_propagation);
            document_listeners.delete(event_name);
          } else {
            document_listeners.set(event_name, n);
          }
        }
        root_event_handles.delete(event_handle);
        if (anchor_node !== anchor) {
          anchor_node.parentNode?.removeChild(anchor_node);
        }
      };
    });
    mounted_components.set(component2, unmount2);
    return component2;
  }
  var mounted_components = /* @__PURE__ */ new WeakMap();
  function unmount(component2, options) {
    const fn = mounted_components.get(component2);
    if (fn) {
      mounted_components.delete(component2);
      return fn(options);
    }
    if (dev_fallback_default) {
      lifecycle_double_unmount();
    }
    return Promise.resolve();
  }

  // node_modules/svelte/src/internal/client/dom/blocks/await.js
  var PENDING = 0;
  var THEN = 1;
  var CATCH = 2;
  function await_block(node, get_input, pending_fn, then_fn, catch_fn) {
    if (hydrating) {
      hydrate_next();
    }
    var anchor = node;
    var runes = is_runes();
    var active_component_context = component_context;
    var component_function = dev_fallback_default ? component_context?.function : null;
    var input = UNINITIALIZED;
    var pending_effect;
    var then_effect;
    var catch_effect;
    var input_source = (runes ? source : mutable_source)(
      /** @type {V} */
      void 0
    );
    var error_source = (runes ? source : mutable_source)(void 0);
    var resolved = false;
    function update2(state2, restore) {
      resolved = true;
      if (restore) {
        set_active_effect(effect2);
        set_active_reaction(effect2);
        set_component_context(active_component_context);
        if (dev_fallback_default) set_dev_current_component_function(component_function);
      }
      try {
        if (state2 === PENDING && pending_fn) {
          if (pending_effect) resume_effect(pending_effect);
          else pending_effect = branch(() => pending_fn(anchor));
        }
        if (state2 === THEN && then_fn) {
          if (then_effect) resume_effect(then_effect);
          else then_effect = branch(() => then_fn(anchor, input_source));
        }
        if (state2 === CATCH && catch_fn) {
          if (catch_effect) resume_effect(catch_effect);
          else catch_effect = branch(() => catch_fn(anchor, error_source));
        }
        if (state2 !== PENDING && pending_effect) {
          pause_effect(pending_effect, () => pending_effect = null);
        }
        if (state2 !== THEN && then_effect) {
          pause_effect(then_effect, () => then_effect = null);
        }
        if (state2 !== CATCH && catch_effect) {
          pause_effect(catch_effect, () => catch_effect = null);
        }
      } finally {
        if (restore) {
          if (dev_fallback_default) set_dev_current_component_function(null);
          set_component_context(null);
          set_active_reaction(null);
          set_active_effect(null);
          flushSync();
        }
      }
    }
    var effect2 = block(() => {
      if (input === (input = get_input())) return;
      if (is_promise(input)) {
        var promise = input;
        resolved = false;
        promise.then(
          (value) => {
            if (promise !== input) return;
            internal_set(input_source, value);
            update2(THEN, true);
          },
          (error) => {
            if (promise !== input) return;
            internal_set(error_source, error);
            update2(CATCH, true);
            if (!catch_fn) {
              throw error_source.v;
            }
          }
        );
        if (hydrating) {
          if (pending_fn) {
            pending_effect = branch(() => pending_fn(anchor));
          }
        } else {
          queue_micro_task(() => {
            if (!resolved) update2(PENDING, true);
          });
        }
      } else {
        internal_set(input_source, input);
        update2(THEN, false);
      }
      return () => input = UNINITIALIZED;
    });
    if (hydrating) {
      anchor = hydrate_node;
    }
  }

  // node_modules/svelte/src/internal/client/dom/blocks/if.js
  function if_block(node, fn, [root_index, hydrate_index] = [0, 0]) {
    if (hydrating && root_index === 0) {
      hydrate_next();
    }
    var anchor = node;
    var consequent_effect = null;
    var alternate_effect = null;
    var condition = UNINITIALIZED;
    var flags = root_index > 0 ? EFFECT_TRANSPARENT : 0;
    var has_branch = false;
    const set_branch = (fn2, flag = true) => {
      has_branch = true;
      update_branch(flag, fn2);
    };
    const update_branch = (new_condition, fn2) => {
      if (condition === (condition = new_condition)) return;
      let mismatch = false;
      if (hydrating && hydrate_index !== -1) {
        if (root_index === 0) {
          const data2 = (
            /** @type {Comment} */
            anchor.data
          );
          if (data2 === HYDRATION_START) {
            hydrate_index = 0;
          } else if (data2 === HYDRATION_START_ELSE) {
            hydrate_index = Infinity;
          } else {
            hydrate_index = parseInt(data2.substring(1));
            if (hydrate_index !== hydrate_index) {
              hydrate_index = condition ? Infinity : -1;
            }
          }
        }
        const is_else = hydrate_index > root_index;
        if (!!condition === is_else) {
          anchor = remove_nodes();
          set_hydrate_node(anchor);
          set_hydrating(false);
          mismatch = true;
          hydrate_index = -1;
        }
      }
      if (condition) {
        if (consequent_effect) {
          resume_effect(consequent_effect);
        } else if (fn2) {
          consequent_effect = branch(() => fn2(anchor));
        }
        if (alternate_effect) {
          pause_effect(alternate_effect, () => {
            alternate_effect = null;
          });
        }
      } else {
        if (alternate_effect) {
          resume_effect(alternate_effect);
        } else if (fn2) {
          alternate_effect = branch(() => fn2(anchor, [root_index + 1, hydrate_index]));
        }
        if (consequent_effect) {
          pause_effect(consequent_effect, () => {
            consequent_effect = null;
          });
        }
      }
      if (mismatch) {
        set_hydrating(true);
      }
    };
    block(() => {
      has_branch = false;
      fn(set_branch);
      if (!has_branch) {
        update_branch(null, null);
      }
    }, flags);
    if (hydrating) {
      anchor = hydrate_node;
    }
  }

  // node_modules/svelte/src/internal/client/dom/blocks/each.js
  var current_each_item = null;
  function index(_25, i) {
    return i;
  }
  function pause_effects(state2, items, controlled_anchor, items_map) {
    var transitions = [];
    var length3 = items.length;
    for (var i = 0; i < length3; i++) {
      pause_children(items[i].e, transitions, true);
    }
    var is_controlled = length3 > 0 && transitions.length === 0 && controlled_anchor !== null;
    if (is_controlled) {
      var parent_node = (
        /** @type {Element} */
        /** @type {Element} */
        controlled_anchor.parentNode
      );
      clear_text_content(parent_node);
      parent_node.append(
        /** @type {Element} */
        controlled_anchor
      );
      items_map.clear();
      link(state2, items[0].prev, items[length3 - 1].next);
    }
    run_out_transitions(transitions, () => {
      for (var i2 = 0; i2 < length3; i2++) {
        var item = items[i2];
        if (!is_controlled) {
          items_map.delete(item.k);
          link(state2, item.prev, item.next);
        }
        destroy_effect(item.e, !is_controlled);
      }
    });
  }
  function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
    var anchor = node;
    var state2 = { flags, items: /* @__PURE__ */ new Map(), first: null };
    var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;
    if (is_controlled) {
      var parent_node = (
        /** @type {Element} */
        node
      );
      anchor = hydrating ? set_hydrate_node(
        /** @type {Comment | Text} */
        get_first_child(parent_node)
      ) : parent_node.appendChild(create_text());
    }
    if (hydrating) {
      hydrate_next();
    }
    var fallback4 = null;
    var was_empty = false;
    var each_array = derived_safe_equal(() => {
      var collection = get_collection();
      return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
    });
    block(() => {
      var array4 = get(each_array);
      var length3 = array4.length;
      if (was_empty && length3 === 0) {
        return;
      }
      was_empty = length3 === 0;
      let mismatch = false;
      if (hydrating) {
        var is_else = (
          /** @type {Comment} */
          anchor.data === HYDRATION_START_ELSE
        );
        if (is_else !== (length3 === 0)) {
          anchor = remove_nodes();
          set_hydrate_node(anchor);
          set_hydrating(false);
          mismatch = true;
        }
      }
      if (hydrating) {
        var prev = null;
        var item;
        for (var i = 0; i < length3; i++) {
          if (hydrate_node.nodeType === 8 && /** @type {Comment} */
          hydrate_node.data === HYDRATION_END) {
            anchor = /** @type {Comment} */
            hydrate_node;
            mismatch = true;
            set_hydrating(false);
            break;
          }
          var value = array4[i];
          var key = get_key(value, i);
          item = create_item(
            hydrate_node,
            state2,
            prev,
            null,
            value,
            key,
            i,
            render_fn,
            flags,
            get_collection
          );
          state2.items.set(key, item);
          prev = item;
        }
        if (length3 > 0) {
          set_hydrate_node(remove_nodes());
        }
      }
      if (!hydrating) {
        reconcile(array4, state2, anchor, render_fn, flags, get_key, get_collection);
      }
      if (fallback_fn !== null) {
        if (length3 === 0) {
          if (fallback4) {
            resume_effect(fallback4);
          } else {
            fallback4 = branch(() => fallback_fn(anchor));
          }
        } else if (fallback4 !== null) {
          pause_effect(fallback4, () => {
            fallback4 = null;
          });
        }
      }
      if (mismatch) {
        set_hydrating(true);
      }
      get(each_array);
    });
    if (hydrating) {
      anchor = hydrate_node;
    }
  }
  function reconcile(array4, state2, anchor, render_fn, flags, get_key, get_collection) {
    var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
    var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;
    var length3 = array4.length;
    var items = state2.items;
    var first = state2.first;
    var current = first;
    var seen;
    var prev = null;
    var to_animate;
    var matched = [];
    var stashed = [];
    var value;
    var key;
    var item;
    var i;
    if (is_animated) {
      for (i = 0; i < length3; i += 1) {
        value = array4[i];
        key = get_key(value, i);
        item = items.get(key);
        if (item !== void 0) {
          item.a?.measure();
          (to_animate ??= /* @__PURE__ */ new Set()).add(item);
        }
      }
    }
    for (i = 0; i < length3; i += 1) {
      value = array4[i];
      key = get_key(value, i);
      item = items.get(key);
      if (item === void 0) {
        var child_anchor = current ? (
          /** @type {TemplateNode} */
          current.e.nodes_start
        ) : anchor;
        prev = create_item(
          child_anchor,
          state2,
          prev,
          prev === null ? state2.first : prev.next,
          value,
          key,
          i,
          render_fn,
          flags,
          get_collection
        );
        items.set(key, prev);
        matched = [];
        stashed = [];
        current = prev.next;
        continue;
      }
      if (should_update) {
        update_item(item, value, i, flags);
      }
      if ((item.e.f & INERT) !== 0) {
        resume_effect(item.e);
        if (is_animated) {
          item.a?.unfix();
          (to_animate ??= /* @__PURE__ */ new Set()).delete(item);
        }
      }
      if (item !== current) {
        if (seen !== void 0 && seen.has(item)) {
          if (matched.length < stashed.length) {
            var start2 = stashed[0];
            var j2;
            prev = start2.prev;
            var a4 = matched[0];
            var b10 = matched[matched.length - 1];
            for (j2 = 0; j2 < matched.length; j2 += 1) {
              move(matched[j2], start2, anchor);
            }
            for (j2 = 0; j2 < stashed.length; j2 += 1) {
              seen.delete(stashed[j2]);
            }
            link(state2, a4.prev, b10.next);
            link(state2, prev, a4);
            link(state2, b10, start2);
            current = start2;
            prev = b10;
            i -= 1;
            matched = [];
            stashed = [];
          } else {
            seen.delete(item);
            move(item, current, anchor);
            link(state2, item.prev, item.next);
            link(state2, item, prev === null ? state2.first : prev.next);
            link(state2, prev, item);
            prev = item;
          }
          continue;
        }
        matched = [];
        stashed = [];
        while (current !== null && current.k !== key) {
          if ((current.e.f & INERT) === 0) {
            (seen ??= /* @__PURE__ */ new Set()).add(current);
          }
          stashed.push(current);
          current = current.next;
        }
        if (current === null) {
          continue;
        }
        item = current;
      }
      matched.push(item);
      prev = item;
      current = item.next;
    }
    if (current !== null || seen !== void 0) {
      var to_destroy = seen === void 0 ? [] : array_from(seen);
      while (current !== null) {
        if ((current.e.f & INERT) === 0) {
          to_destroy.push(current);
        }
        current = current.next;
      }
      var destroy_length = to_destroy.length;
      if (destroy_length > 0) {
        var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length3 === 0 ? anchor : null;
        if (is_animated) {
          for (i = 0; i < destroy_length; i += 1) {
            to_destroy[i].a?.measure();
          }
          for (i = 0; i < destroy_length; i += 1) {
            to_destroy[i].a?.fix();
          }
        }
        pause_effects(state2, to_destroy, controlled_anchor, items);
      }
    }
    if (is_animated) {
      queue_micro_task(() => {
        if (to_animate === void 0) return;
        for (item of to_animate) {
          item.a?.apply();
        }
      });
    }
    active_effect.first = state2.first && state2.first.e;
    active_effect.last = prev && prev.e;
  }
  function update_item(item, value, index4, type2) {
    if ((type2 & EACH_ITEM_REACTIVE) !== 0) {
      internal_set(item.v, value);
    }
    if ((type2 & EACH_INDEX_REACTIVE) !== 0) {
      internal_set(
        /** @type {Value<number>} */
        item.i,
        index4
      );
    } else {
      item.i = index4;
    }
  }
  function create_item(anchor, state2, prev, next2, value, key, index4, render_fn, flags, get_collection) {
    var previous_each_item = current_each_item;
    var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
    var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;
    var v3 = reactive ? mutable ? mutable_source(value) : source(value) : value;
    var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index4 : source(index4);
    if (dev_fallback_default && reactive) {
      v3.debug = () => {
        var collection_index = typeof i === "number" ? index4 : i.v;
        get_collection()[collection_index];
      };
    }
    var item = {
      i,
      v: v3,
      k: key,
      a: null,
      // @ts-expect-error
      e: null,
      prev,
      next: next2
    };
    current_each_item = item;
    try {
      item.e = branch(() => render_fn(anchor, v3, i, get_collection), hydrating);
      item.e.prev = prev && prev.e;
      item.e.next = next2 && next2.e;
      if (prev === null) {
        state2.first = item;
      } else {
        prev.next = item;
        prev.e.next = item.e;
      }
      if (next2 !== null) {
        next2.prev = item;
        next2.e.prev = item.e;
      }
      return item;
    } finally {
      current_each_item = previous_each_item;
    }
  }
  function move(item, next2, anchor) {
    var end = item.next ? (
      /** @type {TemplateNode} */
      item.next.e.nodes_start
    ) : anchor;
    var dest = next2 ? (
      /** @type {TemplateNode} */
      next2.e.nodes_start
    ) : anchor;
    var node = (
      /** @type {TemplateNode} */
      item.e.nodes_start
    );
    while (node !== end) {
      var next_node = (
        /** @type {TemplateNode} */
        get_next_sibling(node)
      );
      dest.before(node);
      node = next_node;
    }
  }
  function link(state2, prev, next2) {
    if (prev === null) {
      state2.first = next2;
    } else {
      prev.next = next2;
      prev.e.next = next2 && next2.e;
    }
    if (next2 !== null) {
      next2.prev = prev;
      next2.e.prev = prev && prev.e;
    }
  }

  // node_modules/svelte/src/internal/client/dom/blocks/slot.js
  function slot(anchor, $$props, name, slot_props, fallback_fn) {
    if (hydrating) {
      hydrate_next();
    }
    var slot_fn = $$props.$$slots?.[name];
    var is_interop = false;
    if (slot_fn === true) {
      slot_fn = $$props[name === "default" ? "children" : name];
      is_interop = true;
    }
    if (slot_fn === void 0) {
      if (fallback_fn !== null) {
        fallback_fn(anchor);
      }
    } else {
      slot_fn(anchor, is_interop ? () => slot_props : slot_props);
    }
  }

  // node_modules/svelte/src/internal/shared/attributes.js
  var whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
  function to_class(value, hash2, directives) {
    var classname = value == null ? "" : "" + value;
    if (hash2) {
      classname = classname ? classname + " " + hash2 : hash2;
    }
    if (directives) {
      for (var key in directives) {
        if (directives[key]) {
          classname = classname ? classname + " " + key : key;
        } else if (classname.length) {
          var len = key.length;
          var a4 = 0;
          while ((a4 = classname.indexOf(key, a4)) >= 0) {
            var b10 = a4 + len;
            if ((a4 === 0 || whitespace.includes(classname[a4 - 1])) && (b10 === classname.length || whitespace.includes(classname[b10]))) {
              classname = (a4 === 0 ? "" : classname.substring(0, a4)) + classname.substring(b10 + 1);
            } else {
              a4 = b10;
            }
          }
        }
      }
    }
    return classname === "" ? null : classname;
  }

  // node_modules/svelte/src/internal/client/dom/elements/class.js
  function set_class(dom, is_html, value, hash2, prev_classes, next_classes) {
    var prev = dom.__className;
    if (hydrating || prev !== value) {
      var next_class_name = to_class(value, hash2, next_classes);
      if (!hydrating || next_class_name !== dom.getAttribute("class")) {
        if (next_class_name == null) {
          dom.removeAttribute("class");
        } else if (is_html) {
          dom.className = next_class_name;
        } else {
          dom.setAttribute("class", next_class_name);
        }
      }
      dom.__className = value;
    } else if (next_classes) {
      for (var key in next_classes) {
        var is_present = !!next_classes[key];
        if (prev_classes == null || is_present !== !!prev_classes[key]) {
          dom.classList.toggle(key, is_present);
        }
      }
    }
    return next_classes;
  }

  // node_modules/svelte/src/internal/client/dom/elements/attributes.js
  var CLASS = Symbol("class");
  var STYLE = Symbol("style");
  function remove_input_defaults(input) {
    if (!hydrating) return;
    var already_removed = false;
    var remove_defaults = () => {
      if (already_removed) return;
      already_removed = true;
      if (input.hasAttribute("value")) {
        var value = input.value;
        set_attribute(input, "value", null);
        input.value = value;
      }
      if (input.hasAttribute("checked")) {
        var checked = input.checked;
        set_attribute(input, "checked", null);
        input.checked = checked;
      }
    };
    input.__on_r = remove_defaults;
    queue_idle_task(remove_defaults);
    add_form_reset_listener();
  }
  function set_value(element2, value) {
    var attributes = element2.__attributes ??= {};
    if (attributes.value === (attributes.value = // treat null and undefined the same for the initial value
    value ?? void 0) || // @ts-expect-error
    // `progress` elements always need their value set when it's `0`
    element2.value === value && (value !== 0 || element2.nodeName !== "PROGRESS")) {
      return;
    }
    element2.value = value ?? "";
  }
  function set_attribute(element2, attribute, value, skip_warning) {
    var attributes = element2.__attributes ??= {};
    if (hydrating) {
      attributes[attribute] = element2.getAttribute(attribute);
      if (attribute === "src" || attribute === "srcset" || attribute === "href" && element2.nodeName === "LINK") {
        if (!skip_warning) {
          check_src_in_dev_hydration(element2, attribute, value ?? "");
        }
        return;
      }
    }
    if (attributes[attribute] === (attributes[attribute] = value)) return;
    if (attribute === "style" && "__styles" in element2) {
      element2.__styles = {};
    }
    if (attribute === "loading") {
      element2[LOADING_ATTR_SYMBOL] = value;
    }
    if (value == null) {
      element2.removeAttribute(attribute);
    } else if (typeof value !== "string" && get_setters(element2).includes(attribute)) {
      element2[attribute] = value;
    } else {
      element2.setAttribute(attribute, value);
    }
  }
  var setters_cache = /* @__PURE__ */ new Map();
  function get_setters(element2) {
    var setters = setters_cache.get(element2.nodeName);
    if (setters) return setters;
    setters_cache.set(element2.nodeName, setters = []);
    var descriptors;
    var proto = element2;
    var element_proto = Element.prototype;
    while (element_proto !== proto) {
      descriptors = get_descriptors(proto);
      for (var key in descriptors) {
        if (descriptors[key].set) {
          setters.push(key);
        }
      }
      proto = get_prototype_of(proto);
    }
    return setters;
  }
  function check_src_in_dev_hydration(element2, attribute, value) {
    if (!dev_fallback_default) return;
    if (attribute === "srcset" && srcset_url_equal(element2, value)) return;
    if (src_url_equal(element2.getAttribute(attribute) ?? "", value)) return;
    hydration_attribute_changed(
      attribute,
      element2.outerHTML.replace(element2.innerHTML, element2.innerHTML && "..."),
      String(value)
    );
  }
  function src_url_equal(element_src, url) {
    if (element_src === url) return true;
    return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
  }
  function split_srcset(srcset) {
    return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
  }
  function srcset_url_equal(element2, srcset) {
    var element_urls = split_srcset(element2.srcset);
    var urls = split_srcset(srcset);
    return urls.length === element_urls.length && urls.every(
      ([url, width2], i) => width2 === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
      // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
      // relative URLs inside srcset are not automatically resolved to absolute URLs by
      // browsers (in contrast to img.src). This means both SSR and DOM code could
      // contain relative or absolute URLs.
      (src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
    );
  }

  // node_modules/svelte/src/internal/client/dom/elements/style.js
  function set_style(dom, key, value, important) {
    var styles = dom.__styles ??= {};
    if (styles[key] === value) {
      return;
    }
    styles[key] = value;
    if (value == null) {
      dom.style.removeProperty(key);
    } else {
      dom.style.setProperty(key, value, important ? "important" : "");
    }
  }

  // node_modules/svelte/src/internal/client/dom/elements/bindings/input.js
  function bind_value(input, get5, set5 = get5) {
    var runes = is_runes();
    listen_to_event_and_reset_event(input, "input", (is_reset) => {
      if (dev_fallback_default && input.type === "checkbox") {
        bind_invalid_checkbox_value();
      }
      var value = is_reset ? input.defaultValue : input.value;
      value = is_numberlike_input(input) ? to_number(value) : value;
      set5(value);
      if (runes && value !== (value = get5())) {
        var start2 = input.selectionStart;
        var end = input.selectionEnd;
        input.value = value ?? "";
        if (end !== null) {
          input.selectionStart = start2;
          input.selectionEnd = Math.min(end, input.value.length);
        }
      }
    });
    if (
      // If we are hydrating and the value has since changed,
      // then use the updated value from the input instead.
      hydrating && input.defaultValue !== input.value || // If defaultValue is set, then value == defaultValue
      // TODO Svelte 6: remove input.value check and set to empty string?
      untrack(get5) == null && input.value
    ) {
      set5(is_numberlike_input(input) ? to_number(input.value) : input.value);
    }
    render_effect(() => {
      if (dev_fallback_default && input.type === "checkbox") {
        bind_invalid_checkbox_value();
      }
      var value = get5();
      if (is_numberlike_input(input) && value === to_number(input.value)) {
        return;
      }
      if (input.type === "date" && !value && !input.value) {
        return;
      }
      if (value !== input.value) {
        input.value = value ?? "";
      }
    });
  }
  var pending = /* @__PURE__ */ new Set();
  function bind_group(inputs, group_index, input, get5, set5 = get5) {
    var is_checkbox = input.getAttribute("type") === "checkbox";
    var binding_group = inputs;
    let hydration_mismatch2 = false;
    if (group_index !== null) {
      for (var index4 of group_index) {
        binding_group = binding_group[index4] ??= [];
      }
    }
    binding_group.push(input);
    listen_to_event_and_reset_event(
      input,
      "change",
      () => {
        var value = input.__value;
        if (is_checkbox) {
          value = get_binding_group_value(binding_group, value, input.checked);
        }
        set5(value);
      },
      // TODO better default value handling
      () => set5(is_checkbox ? [] : null)
    );
    render_effect(() => {
      var value = get5();
      if (hydrating && input.defaultChecked !== input.checked) {
        hydration_mismatch2 = true;
        return;
      }
      if (is_checkbox) {
        value = value || [];
        input.checked = value.includes(input.__value);
      } else {
        input.checked = is(input.__value, value);
      }
    });
    teardown(() => {
      var index5 = binding_group.indexOf(input);
      if (index5 !== -1) {
        binding_group.splice(index5, 1);
      }
    });
    if (!pending.has(binding_group)) {
      pending.add(binding_group);
      queue_micro_task(() => {
        binding_group.sort((a4, b10) => a4.compareDocumentPosition(b10) === 4 ? -1 : 1);
        pending.delete(binding_group);
      });
    }
    queue_micro_task(() => {
      if (hydration_mismatch2) {
        var value;
        if (is_checkbox) {
          value = get_binding_group_value(binding_group, value, input.checked);
        } else {
          var hydration_input = binding_group.find((input2) => input2.checked);
          value = hydration_input?.__value;
        }
        set5(value);
      }
    });
  }
  function bind_checked(input, get5, set5 = get5) {
    listen_to_event_and_reset_event(input, "change", (is_reset) => {
      var value = is_reset ? input.defaultChecked : input.checked;
      set5(value);
    });
    if (
      // If we are hydrating and the value has since changed,
      // then use the update value from the input instead.
      hydrating && input.defaultChecked !== input.checked || // If defaultChecked is set, then checked == defaultChecked
      untrack(get5) == null
    ) {
      set5(input.checked);
    }
    render_effect(() => {
      var value = get5();
      input.checked = Boolean(value);
    });
  }
  function get_binding_group_value(group2, __value, checked) {
    var value = /* @__PURE__ */ new Set();
    for (var i = 0; i < group2.length; i += 1) {
      if (group2[i].checked) {
        value.add(group2[i].__value);
      }
    }
    if (!checked) {
      value.delete(__value);
    }
    return Array.from(value);
  }
  function is_numberlike_input(input) {
    var type2 = input.type;
    return type2 === "number" || type2 === "range";
  }
  function to_number(value) {
    return value === "" ? null : +value;
  }

  // node_modules/svelte/src/internal/client/dom/elements/bindings/select.js
  function select_option(select, value, mounting) {
    if (select.multiple) {
      return select_options(select, value);
    }
    for (var option of select.options) {
      var option_value = get_option_value(option);
      if (is(option_value, value)) {
        option.selected = true;
        return;
      }
    }
    if (!mounting || value !== void 0) {
      select.selectedIndex = -1;
    }
  }
  function init_select(select, get_value) {
    let mounting = true;
    effect(() => {
      if (get_value) {
        select_option(select, untrack(get_value), mounting);
      }
      mounting = false;
      var observer = new MutationObserver(() => {
        var value = select.__value;
        select_option(select, value);
      });
      observer.observe(select, {
        // Listen to option element changes
        childList: true,
        subtree: true,
        // because of <optgroup>
        // Listen to option element value attribute changes
        // (doesn't get notified of select value changes,
        // because that property is not reflected as an attribute)
        attributes: true,
        attributeFilter: ["value"]
      });
      return () => {
        observer.disconnect();
      };
    });
  }
  function bind_select_value(select, get5, set5 = get5) {
    var mounting = true;
    listen_to_event_and_reset_event(select, "change", (is_reset) => {
      var query = is_reset ? "[selected]" : ":checked";
      var value;
      if (select.multiple) {
        value = [].map.call(select.querySelectorAll(query), get_option_value);
      } else {
        var selected_option = select.querySelector(query) ?? // will fall back to first non-disabled option if no option is selected
        select.querySelector("option:not([disabled])");
        value = selected_option && get_option_value(selected_option);
      }
      set5(value);
    });
    effect(() => {
      var value = get5();
      select_option(select, value, mounting);
      if (mounting && value === void 0) {
        var selected_option = select.querySelector(":checked");
        if (selected_option !== null) {
          value = get_option_value(selected_option);
          set5(value);
        }
      }
      select.__value = value;
      mounting = false;
    });
    init_select(select);
  }
  function select_options(select, value) {
    for (var option of select.options) {
      option.selected = ~value.indexOf(get_option_value(option));
    }
  }
  function get_option_value(option) {
    if ("__value" in option) {
      return option.__value;
    } else {
      return option.value;
    }
  }

  // node_modules/svelte/src/internal/client/dom/elements/bindings/this.js
  function is_bound_this(bound_value, element_or_component) {
    return bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component;
  }
  function bind_this(element_or_component = {}, update2, get_value, get_parts) {
    effect(() => {
      var old_parts;
      var parts;
      render_effect(() => {
        old_parts = parts;
        parts = get_parts?.() || [];
        untrack(() => {
          if (element_or_component !== get_value(...parts)) {
            update2(element_or_component, ...parts);
            if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
              update2(null, ...old_parts);
            }
          }
        });
      });
      return () => {
        queue_micro_task(() => {
          if (parts && is_bound_this(get_value(...parts), element_or_component)) {
            update2(null, ...parts);
          }
        });
      };
    });
    return element_or_component;
  }

  // node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js
  function init(immutable = false) {
    const context = (
      /** @type {ComponentContextLegacy} */
      component_context
    );
    const callbacks = context.l.u;
    if (!callbacks) return;
    let props = () => deep_read_state(context.s);
    if (immutable) {
      let version = 0;
      let prev = (
        /** @type {Record<string, any>} */
        {}
      );
      const d = derived(() => {
        let changed = false;
        const props2 = context.s;
        for (const key in props2) {
          if (props2[key] !== prev[key]) {
            prev[key] = props2[key];
            changed = true;
          }
        }
        if (changed) version++;
        return version;
      });
      props = () => get(d);
    }
    if (callbacks.b.length) {
      user_pre_effect(() => {
        observe_all(context, props);
        run_all(callbacks.b);
      });
    }
    user_effect(() => {
      const fns = untrack(() => callbacks.m.map(run));
      return () => {
        for (const fn of fns) {
          if (typeof fn === "function") {
            fn();
          }
        }
      };
    });
    if (callbacks.a.length) {
      user_effect(() => {
        observe_all(context, props);
        run_all(callbacks.a);
      });
    }
  }
  function observe_all(context, props) {
    if (context.l.s) {
      for (const signal of context.l.s) get(signal);
    }
    props();
  }

  // node_modules/svelte/src/store/utils.js
  function subscribe_to_store(store, run2, invalidate) {
    if (store == null) {
      run2(void 0);
      if (invalidate) invalidate(void 0);
      return noop;
    }
    const unsub = untrack(
      () => store.subscribe(
        run2,
        // @ts-expect-error
        invalidate
      )
    );
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
  }

  // node_modules/svelte/src/store/shared/index.js
  var subscriber_queue = [];
  function readable(value, start2) {
    return {
      subscribe: writable(value, start2).subscribe
    };
  }
  function writable(value, start2 = noop) {
    let stop = null;
    const subscribers = /* @__PURE__ */ new Set();
    function set5(new_value) {
      if (safe_not_equal(value, new_value)) {
        value = new_value;
        if (stop) {
          const run_queue = !subscriber_queue.length;
          for (const subscriber of subscribers) {
            subscriber[1]();
            subscriber_queue.push(subscriber, value);
          }
          if (run_queue) {
            for (let i = 0; i < subscriber_queue.length; i += 2) {
              subscriber_queue[i][0](subscriber_queue[i + 1]);
            }
            subscriber_queue.length = 0;
          }
        }
      }
    }
    function update2(fn) {
      set5(fn(
        /** @type {T} */
        value
      ));
    }
    function subscribe(run2, invalidate = noop) {
      const subscriber = [run2, invalidate];
      subscribers.add(subscriber);
      if (subscribers.size === 1) {
        stop = start2(set5, update2) || noop;
      }
      run2(
        /** @type {T} */
        value
      );
      return () => {
        subscribers.delete(subscriber);
        if (subscribers.size === 0 && stop) {
          stop();
          stop = null;
        }
      };
    }
    return { set: set5, update: update2, subscribe };
  }
  function derived2(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single ? [stores] : stores;
    if (!stores_array.every(Boolean)) {
      throw new Error("derived() expects stores as input, got a falsy value");
    }
    const auto = fn.length < 2;
    return readable(initial_value, (set5, update2) => {
      let started = false;
      const values2 = [];
      let pending2 = 0;
      let cleanup = noop;
      const sync = () => {
        if (pending2) {
          return;
        }
        cleanup();
        const result = fn(single ? values2[0] : values2, set5, update2);
        if (auto) {
          set5(result);
        } else {
          cleanup = typeof result === "function" ? result : noop;
        }
      };
      const unsubscribers = stores_array.map(
        (store, i) => subscribe_to_store(
          store,
          (value) => {
            values2[i] = value;
            pending2 &= ~(1 << i);
            if (started) {
              sync();
            }
          },
          () => {
            pending2 |= 1 << i;
          }
        )
      );
      started = true;
      sync();
      return function stop() {
        run_all(unsubscribers);
        cleanup();
        started = false;
      };
    });
  }
  function get2(store) {
    let value;
    subscribe_to_store(store, (_25) => value = _25)();
    return value;
  }

  // node_modules/svelte/src/internal/client/reactivity/store.js
  var is_store_binding = false;
  var IS_UNMOUNTED = Symbol();
  function store_get(store, store_name, stores) {
    const entry = stores[store_name] ??= {
      store: null,
      source: mutable_source(void 0),
      unsubscribe: noop
    };
    if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
      entry.unsubscribe();
      entry.store = store ?? null;
      if (store == null) {
        entry.source.v = void 0;
        entry.unsubscribe = noop;
      } else {
        var is_synchronous_callback = true;
        entry.unsubscribe = subscribe_to_store(store, (v3) => {
          if (is_synchronous_callback) {
            entry.source.v = v3;
          } else {
            set(entry.source, v3);
          }
        });
        is_synchronous_callback = false;
      }
    }
    if (store && IS_UNMOUNTED in stores) {
      return get2(store);
    }
    return get(entry.source);
  }
  function store_unsub(store, store_name, stores) {
    let entry = stores[store_name];
    if (entry && entry.store !== store) {
      entry.unsubscribe();
      entry.unsubscribe = noop;
    }
    return store;
  }
  function store_set(store, value) {
    store.set(value);
    return value;
  }
  function setup_stores() {
    const stores = {};
    function cleanup() {
      teardown(() => {
        for (var store_name in stores) {
          const ref = stores[store_name];
          ref.unsubscribe();
        }
        define_property(stores, IS_UNMOUNTED, {
          enumerable: false,
          value: true
        });
      });
    }
    return [stores, cleanup];
  }
  function store_mutate(store, expression, new_value) {
    store.set(new_value);
    return expression;
  }
  function mark_store_binding() {
    is_store_binding = true;
  }
  function capture_store_binding(fn) {
    var previous_is_store_binding = is_store_binding;
    try {
      is_store_binding = false;
      return [fn(), is_store_binding];
    } finally {
      is_store_binding = previous_is_store_binding;
    }
  }

  // node_modules/svelte/src/internal/client/reactivity/props.js
  function prop(props, key, flags, fallback4) {
    var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
    var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
    var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
    var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;
    var is_store_sub = false;
    var prop_value;
    if (bindable) {
      [prop_value, is_store_sub] = capture_store_binding(() => (
        /** @type {V} */
        props[key]
      ));
    } else {
      prop_value = /** @type {V} */
      props[key];
    }
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    var setter = bindable && (get_descriptor(props, key)?.set ?? (is_entry_props && key in props && ((v3) => props[key] = v3))) || void 0;
    var fallback_value = (
      /** @type {V} */
      fallback4
    );
    var fallback_dirty = true;
    var fallback_used = false;
    var get_fallback = () => {
      fallback_used = true;
      if (fallback_dirty) {
        fallback_dirty = false;
        if (lazy) {
          fallback_value = untrack(
            /** @type {() => V} */
            fallback4
          );
        } else {
          fallback_value = /** @type {V} */
          fallback4;
        }
      }
      return fallback_value;
    };
    if (prop_value === void 0 && fallback4 !== void 0) {
      if (setter && runes) {
        props_invalid_value(key);
      }
      prop_value = get_fallback();
      if (setter) setter(prop_value);
    }
    var getter;
    if (runes) {
      getter = () => {
        var value = (
          /** @type {V} */
          props[key]
        );
        if (value === void 0) return get_fallback();
        fallback_dirty = true;
        fallback_used = false;
        return value;
      };
    } else {
      var derived_getter = (immutable ? derived : derived_safe_equal)(
        () => (
          /** @type {V} */
          props[key]
        )
      );
      derived_getter.f |= LEGACY_DERIVED_PROP;
      getter = () => {
        var value = get(derived_getter);
        if (value !== void 0) fallback_value = /** @type {V} */
        void 0;
        return value === void 0 ? fallback_value : value;
      };
    }
    if ((flags & PROPS_IS_UPDATED) === 0) {
      return getter;
    }
    if (setter) {
      var legacy_parent = props.$$legacy;
      return function(value, mutation) {
        if (arguments.length > 0) {
          if (!runes || !mutation || legacy_parent || is_store_sub) {
            setter(mutation ? getter() : value);
          }
          return value;
        } else {
          return getter();
        }
      };
    }
    var from_child = false;
    var was_from_child = false;
    var inner_current_value = mutable_source(prop_value);
    var current_value = derived(() => {
      var parent_value = getter();
      var child_value = get(inner_current_value);
      if (from_child) {
        from_child = false;
        was_from_child = true;
        return child_value;
      }
      was_from_child = false;
      return inner_current_value.v = parent_value;
    });
    if (!immutable) current_value.equals = safe_equals;
    return function(value, mutation) {
      if (captured_signals !== null) {
        from_child = was_from_child;
        getter();
        get(inner_current_value);
      }
      if (arguments.length > 0) {
        const new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;
        if (!current_value.equals(new_value)) {
          from_child = true;
          set(inner_current_value, new_value);
          if (fallback_used && fallback_value !== void 0) {
            fallback_value = new_value;
          }
          untrack(() => get(current_value));
        }
        return value;
      }
      return get(current_value);
    };
  }

  // node_modules/svelte/src/legacy/legacy-client.js
  function createClassComponent(options) {
    return new Svelte4Component(options);
  }
  var Svelte4Component = class {
    /** @type {any} */
    #events;
    /** @type {Record<string, any>} */
    #instance;
    /**
     * @param {ComponentConstructorOptions & {
     *  component: any;
     * }} options
     */
    constructor(options) {
      var sources = /* @__PURE__ */ new Map();
      var add_source = (key, value) => {
        var s2 = mutable_source(value);
        sources.set(key, s2);
        return s2;
      };
      const props = new Proxy(
        { ...options.props || {}, $$events: {} },
        {
          get(target, prop2) {
            return get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
          },
          has(target, prop2) {
            if (prop2 === LEGACY_PROPS) return true;
            get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
            return Reflect.has(target, prop2);
          },
          set(target, prop2, value) {
            set(sources.get(prop2) ?? add_source(prop2, value), value);
            return Reflect.set(target, prop2, value);
          }
        }
      );
      this.#instance = (options.hydrate ? hydrate : mount)(options.component, {
        target: options.target,
        anchor: options.anchor,
        props,
        context: options.context,
        intro: options.intro ?? false,
        recover: options.recover
      });
      if (!options?.props?.$$host || options.sync === false) {
        flushSync();
      }
      this.#events = props.$$events;
      for (const key of Object.keys(this.#instance)) {
        if (key === "$set" || key === "$destroy" || key === "$on") continue;
        define_property(this, key, {
          get() {
            return this.#instance[key];
          },
          /** @param {any} value */
          set(value) {
            this.#instance[key] = value;
          },
          enumerable: true
        });
      }
      this.#instance.$set = /** @param {Record<string, any>} next */
      (next2) => {
        Object.assign(props, next2);
      };
      this.#instance.$destroy = () => {
        unmount(this.#instance);
      };
    }
    /** @param {Record<string, any>} props */
    $set(props) {
      this.#instance.$set(props);
    }
    /**
     * @param {string} event
     * @param {(...args: any[]) => any} callback
     * @returns {any}
     */
    $on(event2, callback) {
      this.#events[event2] = this.#events[event2] || [];
      const cb = (...args) => callback.call(this, ...args);
      this.#events[event2].push(cb);
      return () => {
        this.#events[event2] = this.#events[event2].filter(
          /** @param {any} fn */
          (fn) => fn !== cb
        );
      };
    }
    $destroy() {
      this.#instance.$destroy();
    }
  };

  // node_modules/svelte/src/internal/client/dom/elements/custom-element.js
  var SvelteElement;
  if (typeof HTMLElement === "function") {
    SvelteElement = class extends HTMLElement {
      /** The Svelte component constructor */
      $$ctor;
      /** Slots */
      $$s;
      /** @type {any} The Svelte component instance */
      $$c;
      /** Whether or not the custom element is connected */
      $$cn = false;
      /** @type {Record<string, any>} Component props data */
      $$d = {};
      /** `true` if currently in the process of reflecting component props back to attributes */
      $$r = false;
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      $$p_d = {};
      /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
      $$l = {};
      /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
      $$l_u = /* @__PURE__ */ new Map();
      /** @type {any} The managed render effect for reflecting attributes */
      $$me;
      /**
       * @param {*} $$componentCtor
       * @param {*} $$slots
       * @param {*} use_shadow_dom
       */
      constructor($$componentCtor, $$slots, use_shadow_dom) {
        super();
        this.$$ctor = $$componentCtor;
        this.$$s = $$slots;
        if (use_shadow_dom) {
          this.attachShadow({ mode: "open" });
        }
      }
      /**
       * @param {string} type
       * @param {EventListenerOrEventListenerObject} listener
       * @param {boolean | AddEventListenerOptions} [options]
       */
      addEventListener(type2, listener, options) {
        this.$$l[type2] = this.$$l[type2] || [];
        this.$$l[type2].push(listener);
        if (this.$$c) {
          const unsub = this.$$c.$on(type2, listener);
          this.$$l_u.set(listener, unsub);
        }
        super.addEventListener(type2, listener, options);
      }
      /**
       * @param {string} type
       * @param {EventListenerOrEventListenerObject} listener
       * @param {boolean | AddEventListenerOptions} [options]
       */
      removeEventListener(type2, listener, options) {
        super.removeEventListener(type2, listener, options);
        if (this.$$c) {
          const unsub = this.$$l_u.get(listener);
          if (unsub) {
            unsub();
            this.$$l_u.delete(listener);
          }
        }
      }
      async connectedCallback() {
        this.$$cn = true;
        if (!this.$$c) {
          let create_slot = function(name) {
            return (anchor) => {
              const slot2 = document.createElement("slot");
              if (name !== "default") slot2.name = name;
              append(anchor, slot2);
            };
          };
          await Promise.resolve();
          if (!this.$$cn || this.$$c) {
            return;
          }
          const $$slots = {};
          const existing_slots = get_custom_elements_slots(this);
          for (const name of this.$$s) {
            if (name in existing_slots) {
              if (name === "default" && !this.$$d.children) {
                this.$$d.children = create_slot(name);
                $$slots.default = true;
              } else {
                $$slots[name] = create_slot(name);
              }
            }
          }
          for (const attribute of this.attributes) {
            const name = this.$$g_p(attribute.name);
            if (!(name in this.$$d)) {
              this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
            }
          }
          for (const key in this.$$p_d) {
            if (!(key in this.$$d) && this[key] !== void 0) {
              this.$$d[key] = this[key];
              delete this[key];
            }
          }
          this.$$c = createClassComponent({
            component: this.$$ctor,
            target: this.shadowRoot || this,
            props: {
              ...this.$$d,
              $$slots,
              $$host: this
            }
          });
          this.$$me = effect_root(() => {
            render_effect(() => {
              this.$$r = true;
              for (const key of object_keys(this.$$c)) {
                if (!this.$$p_d[key]?.reflect) continue;
                this.$$d[key] = this.$$c[key];
                const attribute_value = get_custom_element_value(
                  key,
                  this.$$d[key],
                  this.$$p_d,
                  "toAttribute"
                );
                if (attribute_value == null) {
                  this.removeAttribute(this.$$p_d[key].attribute || key);
                } else {
                  this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
                }
              }
              this.$$r = false;
            });
          });
          for (const type2 in this.$$l) {
            for (const listener of this.$$l[type2]) {
              const unsub = this.$$c.$on(type2, listener);
              this.$$l_u.set(listener, unsub);
            }
          }
          this.$$l = {};
        }
      }
      // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
      // and setting attributes through setAttribute etc, this is helpful
      /**
       * @param {string} attr
       * @param {string} _oldValue
       * @param {string} newValue
       */
      attributeChangedCallback(attr2, _oldValue, newValue) {
        if (this.$$r) return;
        attr2 = this.$$g_p(attr2);
        this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
        this.$$c?.$set({ [attr2]: this.$$d[attr2] });
      }
      disconnectedCallback() {
        this.$$cn = false;
        Promise.resolve().then(() => {
          if (!this.$$cn && this.$$c) {
            this.$$c.$destroy();
            this.$$me();
            this.$$c = void 0;
          }
        });
      }
      /**
       * @param {string} attribute_name
       */
      $$g_p(attribute_name) {
        return object_keys(this.$$p_d).find(
          (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
        ) || attribute_name;
      }
    };
  }
  function get_custom_element_value(prop2, value, props_definition, transform2) {
    const type2 = props_definition[prop2]?.type;
    value = type2 === "Boolean" && typeof value !== "boolean" ? value != null : value;
    if (!transform2 || !props_definition[prop2]) {
      return value;
    } else if (transform2 === "toAttribute") {
      switch (type2) {
        case "Object":
        case "Array":
          return value == null ? null : JSON.stringify(value);
        case "Boolean":
          return value ? "" : null;
        case "Number":
          return value == null ? null : value;
        default:
          return value;
      }
    } else {
      switch (type2) {
        case "Object":
        case "Array":
          return value && JSON.parse(value);
        case "Boolean":
          return value;
        // conversion already handled above
        case "Number":
          return value != null ? +value : value;
        default:
          return value;
      }
    }
  }
  function get_custom_elements_slots(element2) {
    const result = {};
    element2.childNodes.forEach((node) => {
      result[
        /** @type {Element} node */
        node.slot || "default"
      ] = true;
    });
    return result;
  }

  // node_modules/svelte/src/index-client.js
  if (dev_fallback_default) {
    let throw_rune_error = function(rune) {
      if (!(rune in globalThis)) {
        let value;
        Object.defineProperty(globalThis, rune, {
          configurable: true,
          // eslint-disable-next-line getter-return
          get: () => {
            if (value !== void 0) {
              return value;
            }
            rune_outside_svelte(rune);
          },
          set: (v3) => {
            value = v3;
          }
        });
      }
    };
    throw_rune_error("$state");
    throw_rune_error("$effect");
    throw_rune_error("$derived");
    throw_rune_error("$inspect");
    throw_rune_error("$props");
    throw_rune_error("$bindable");
  }
  function onMount(fn) {
    if (component_context === null) {
      lifecycle_outside_component("onMount");
    }
    if (legacy_mode_flag && component_context.l !== null) {
      init_update_callbacks(component_context).m.push(fn);
    } else {
      user_effect(() => {
        const cleanup = untrack(fn);
        if (typeof cleanup === "function") return (
          /** @type {() => void} */
          cleanup
        );
      });
    }
  }
  function onDestroy(fn) {
    if (component_context === null) {
      lifecycle_outside_component("onDestroy");
    }
    onMount(() => () => untrack(fn));
  }
  function init_update_callbacks(context) {
    var l2 = (
      /** @type {ComponentContextLegacy} */
      context.l
    );
    return l2.u ??= { a: [], b: [], m: [] };
  }

  // node_modules/svelte/src/version.js
  var PUBLIC_VERSION = "5";

  // node_modules/svelte/src/internal/disclose-version.js
  if (typeof window !== "undefined")
    (window.__svelte ||= { v: /* @__PURE__ */ new Set() }).v.add(PUBLIC_VERSION);

  // node_modules/svelte/src/internal/flags/legacy.js
  enable_legacy_mode_flag();

  // src/ts/DueBar.svelte
  var import_lodash4 = __toESM(require_lodash());

  // src/ts/Bar.svelte
  var import_lodash3 = __toESM(require_lodash());

  // node_modules/d3/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Adder: () => Adder,
    Delaunay: () => Delaunay,
    FormatSpecifier: () => FormatSpecifier,
    InternMap: () => InternMap,
    InternSet: () => InternSet,
    Node: () => Node2,
    Path: () => Path,
    Voronoi: () => Voronoi,
    ZoomTransform: () => Transform,
    active: () => active_default,
    arc: () => arc_default,
    area: () => area_default5,
    areaRadial: () => areaRadial_default,
    ascending: () => ascending,
    autoType: () => autoType,
    axisBottom: () => axisBottom,
    axisLeft: () => axisLeft,
    axisRight: () => axisRight,
    axisTop: () => axisTop,
    bin: () => bin,
    bisect: () => bisect_default,
    bisectCenter: () => bisectCenter,
    bisectLeft: () => bisectLeft,
    bisectRight: () => bisectRight,
    bisector: () => bisector,
    blob: () => blob_default,
    blur: () => blur,
    blur2: () => blur2,
    blurImage: () => blurImage,
    brush: () => brush_default,
    brushSelection: () => brushSelection,
    brushX: () => brushX,
    brushY: () => brushY,
    buffer: () => buffer_default,
    chord: () => chord_default,
    chordDirected: () => chordDirected,
    chordTranspose: () => chordTranspose,
    cluster: () => cluster_default,
    color: () => color,
    contourDensity: () => density_default,
    contours: () => contours_default,
    count: () => count,
    create: () => create_default,
    creator: () => creator_default,
    cross: () => cross,
    csv: () => csv2,
    csvFormat: () => csvFormat,
    csvFormatBody: () => csvFormatBody,
    csvFormatRow: () => csvFormatRow,
    csvFormatRows: () => csvFormatRows,
    csvFormatValue: () => csvFormatValue,
    csvParse: () => csvParse,
    csvParseRows: () => csvParseRows,
    cubehelix: () => cubehelix,
    cumsum: () => cumsum,
    curveBasis: () => basis_default2,
    curveBasisClosed: () => basisClosed_default2,
    curveBasisOpen: () => basisOpen_default,
    curveBumpX: () => bumpX,
    curveBumpY: () => bumpY,
    curveBundle: () => bundle_default,
    curveCardinal: () => cardinal_default,
    curveCardinalClosed: () => cardinalClosed_default,
    curveCardinalOpen: () => cardinalOpen_default,
    curveCatmullRom: () => catmullRom_default,
    curveCatmullRomClosed: () => catmullRomClosed_default,
    curveCatmullRomOpen: () => catmullRomOpen_default,
    curveLinear: () => linear_default,
    curveLinearClosed: () => linearClosed_default,
    curveMonotoneX: () => monotoneX,
    curveMonotoneY: () => monotoneY,
    curveNatural: () => natural_default,
    curveStep: () => step_default,
    curveStepAfter: () => stepAfter,
    curveStepBefore: () => stepBefore,
    descending: () => descending,
    deviation: () => deviation,
    difference: () => difference,
    disjoint: () => disjoint,
    dispatch: () => dispatch_default,
    drag: () => drag_default,
    dragDisable: () => nodrag_default,
    dragEnable: () => yesdrag,
    dsv: () => dsv,
    dsvFormat: () => dsv_default,
    easeBack: () => backInOut,
    easeBackIn: () => backIn,
    easeBackInOut: () => backInOut,
    easeBackOut: () => backOut,
    easeBounce: () => bounceOut,
    easeBounceIn: () => bounceIn,
    easeBounceInOut: () => bounceInOut,
    easeBounceOut: () => bounceOut,
    easeCircle: () => circleInOut,
    easeCircleIn: () => circleIn,
    easeCircleInOut: () => circleInOut,
    easeCircleOut: () => circleOut,
    easeCubic: () => cubicInOut,
    easeCubicIn: () => cubicIn,
    easeCubicInOut: () => cubicInOut,
    easeCubicOut: () => cubicOut,
    easeElastic: () => elasticOut,
    easeElasticIn: () => elasticIn,
    easeElasticInOut: () => elasticInOut,
    easeElasticOut: () => elasticOut,
    easeExp: () => expInOut,
    easeExpIn: () => expIn,
    easeExpInOut: () => expInOut,
    easeExpOut: () => expOut,
    easeLinear: () => linear2,
    easePoly: () => polyInOut,
    easePolyIn: () => polyIn,
    easePolyInOut: () => polyInOut,
    easePolyOut: () => polyOut,
    easeQuad: () => quadInOut,
    easeQuadIn: () => quadIn,
    easeQuadInOut: () => quadInOut,
    easeQuadOut: () => quadOut,
    easeSin: () => sinInOut,
    easeSinIn: () => sinIn,
    easeSinInOut: () => sinInOut,
    easeSinOut: () => sinOut,
    every: () => every,
    extent: () => extent,
    fcumsum: () => fcumsum,
    filter: () => filter,
    flatGroup: () => flatGroup,
    flatRollup: () => flatRollup,
    forceCenter: () => center_default,
    forceCollide: () => collide_default,
    forceLink: () => link_default,
    forceManyBody: () => manyBody_default,
    forceRadial: () => radial_default,
    forceSimulation: () => simulation_default,
    forceX: () => x_default2,
    forceY: () => y_default2,
    format: () => format,
    formatDefaultLocale: () => defaultLocale,
    formatLocale: () => locale_default,
    formatPrefix: () => formatPrefix,
    formatSpecifier: () => formatSpecifier,
    fsum: () => fsum,
    geoAlbers: () => albers_default,
    geoAlbersUsa: () => albersUsa_default,
    geoArea: () => area_default2,
    geoAzimuthalEqualArea: () => azimuthalEqualArea_default,
    geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,
    geoAzimuthalEquidistant: () => azimuthalEquidistant_default,
    geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,
    geoBounds: () => bounds_default,
    geoCentroid: () => centroid_default,
    geoCircle: () => circle_default,
    geoClipAntimeridian: () => antimeridian_default,
    geoClipCircle: () => circle_default2,
    geoClipExtent: () => extent_default2,
    geoClipRectangle: () => clipRectangle,
    geoConicConformal: () => conicConformal_default,
    geoConicConformalRaw: () => conicConformalRaw,
    geoConicEqualArea: () => conicEqualArea_default,
    geoConicEqualAreaRaw: () => conicEqualAreaRaw,
    geoConicEquidistant: () => conicEquidistant_default,
    geoConicEquidistantRaw: () => conicEquidistantRaw,
    geoContains: () => contains_default2,
    geoDistance: () => distance_default,
    geoEqualEarth: () => equalEarth_default,
    geoEqualEarthRaw: () => equalEarthRaw,
    geoEquirectangular: () => equirectangular_default,
    geoEquirectangularRaw: () => equirectangularRaw,
    geoGnomonic: () => gnomonic_default,
    geoGnomonicRaw: () => gnomonicRaw,
    geoGraticule: () => graticule,
    geoGraticule10: () => graticule10,
    geoIdentity: () => identity_default4,
    geoInterpolate: () => interpolate_default2,
    geoLength: () => length_default,
    geoMercator: () => mercator_default,
    geoMercatorRaw: () => mercatorRaw,
    geoNaturalEarth1: () => naturalEarth1_default,
    geoNaturalEarth1Raw: () => naturalEarth1Raw,
    geoOrthographic: () => orthographic_default,
    geoOrthographicRaw: () => orthographicRaw,
    geoPath: () => path_default,
    geoProjection: () => projection,
    geoProjectionMutator: () => projectionMutator,
    geoRotation: () => rotation_default,
    geoStereographic: () => stereographic_default,
    geoStereographicRaw: () => stereographicRaw,
    geoStream: () => stream_default,
    geoTransform: () => transform_default,
    geoTransverseMercator: () => transverseMercator_default,
    geoTransverseMercatorRaw: () => transverseMercatorRaw,
    gray: () => gray,
    greatest: () => greatest,
    greatestIndex: () => greatestIndex,
    group: () => group,
    groupSort: () => groupSort,
    groups: () => groups,
    hcl: () => hcl,
    hierarchy: () => hierarchy,
    histogram: () => bin,
    hsl: () => hsl,
    html: () => html2,
    image: () => image_default,
    index: () => index2,
    indexes: () => indexes,
    interpolate: () => value_default,
    interpolateArray: () => array_default,
    interpolateBasis: () => basis_default,
    interpolateBasisClosed: () => basisClosed_default,
    interpolateBlues: () => Blues_default,
    interpolateBrBG: () => BrBG_default,
    interpolateBuGn: () => BuGn_default,
    interpolateBuPu: () => BuPu_default,
    interpolateCividis: () => cividis_default,
    interpolateCool: () => cool,
    interpolateCubehelix: () => cubehelix_default,
    interpolateCubehelixDefault: () => cubehelix_default2,
    interpolateCubehelixLong: () => cubehelixLong,
    interpolateDate: () => date_default,
    interpolateDiscrete: () => discrete_default,
    interpolateGnBu: () => GnBu_default,
    interpolateGreens: () => Greens_default,
    interpolateGreys: () => Greys_default,
    interpolateHcl: () => hcl_default,
    interpolateHclLong: () => hclLong,
    interpolateHsl: () => hsl_default,
    interpolateHslLong: () => hslLong,
    interpolateHue: () => hue_default,
    interpolateInferno: () => inferno,
    interpolateLab: () => lab2,
    interpolateMagma: () => magma,
    interpolateNumber: () => number_default,
    interpolateNumberArray: () => numberArray_default,
    interpolateObject: () => object_default,
    interpolateOrRd: () => OrRd_default,
    interpolateOranges: () => Oranges_default,
    interpolatePRGn: () => PRGn_default,
    interpolatePiYG: () => PiYG_default,
    interpolatePlasma: () => plasma,
    interpolatePuBu: () => PuBu_default,
    interpolatePuBuGn: () => PuBuGn_default,
    interpolatePuOr: () => PuOr_default,
    interpolatePuRd: () => PuRd_default,
    interpolatePurples: () => Purples_default,
    interpolateRainbow: () => rainbow_default,
    interpolateRdBu: () => RdBu_default,
    interpolateRdGy: () => RdGy_default,
    interpolateRdPu: () => RdPu_default,
    interpolateRdYlBu: () => RdYlBu_default,
    interpolateRdYlGn: () => RdYlGn_default,
    interpolateReds: () => Reds_default,
    interpolateRgb: () => rgb_default,
    interpolateRgbBasis: () => rgbBasis,
    interpolateRgbBasisClosed: () => rgbBasisClosed,
    interpolateRound: () => round_default,
    interpolateSinebow: () => sinebow_default,
    interpolateSpectral: () => Spectral_default,
    interpolateString: () => string_default,
    interpolateTransformCss: () => interpolateTransformCss,
    interpolateTransformSvg: () => interpolateTransformSvg,
    interpolateTurbo: () => turbo_default,
    interpolateViridis: () => viridis_default,
    interpolateWarm: () => warm,
    interpolateYlGn: () => YlGn_default,
    interpolateYlGnBu: () => YlGnBu_default,
    interpolateYlOrBr: () => YlOrBr_default,
    interpolateYlOrRd: () => YlOrRd_default,
    interpolateZoom: () => zoom_default,
    interrupt: () => interrupt_default,
    intersection: () => intersection,
    interval: () => interval_default,
    isoFormat: () => isoFormat_default,
    isoParse: () => isoParse_default,
    json: () => json_default,
    lab: () => lab,
    lch: () => lch,
    least: () => least,
    leastIndex: () => leastIndex,
    line: () => line_default2,
    lineRadial: () => lineRadial_default,
    link: () => link3,
    linkHorizontal: () => linkHorizontal,
    linkRadial: () => linkRadial,
    linkVertical: () => linkVertical,
    local: () => local,
    map: () => map2,
    matcher: () => matcher_default,
    max: () => max,
    maxIndex: () => maxIndex,
    mean: () => mean,
    median: () => median,
    medianIndex: () => medianIndex,
    merge: () => merge,
    min: () => min,
    minIndex: () => minIndex,
    mode: () => mode,
    namespace: () => namespace_default,
    namespaces: () => namespaces_default,
    nice: () => nice,
    now: () => now,
    pack: () => pack_default,
    packEnclose: () => enclose_default,
    packSiblings: () => siblings_default,
    pairs: () => pairs,
    partition: () => partition_default,
    path: () => path,
    pathRound: () => pathRound,
    permute: () => permute,
    pie: () => pie_default,
    piecewise: () => piecewise,
    pointRadial: () => pointRadial_default,
    pointer: () => pointer_default,
    pointers: () => pointers_default,
    polygonArea: () => area_default4,
    polygonCentroid: () => centroid_default3,
    polygonContains: () => contains_default3,
    polygonHull: () => hull_default,
    polygonLength: () => length_default2,
    precisionFixed: () => precisionFixed_default,
    precisionPrefix: () => precisionPrefix_default,
    precisionRound: () => precisionRound_default,
    quadtree: () => quadtree,
    quantile: () => quantile,
    quantileIndex: () => quantileIndex,
    quantileSorted: () => quantileSorted,
    quantize: () => quantize_default,
    quickselect: () => quickselect,
    radialArea: () => areaRadial_default,
    radialLine: () => lineRadial_default,
    randomBates: () => bates_default,
    randomBernoulli: () => bernoulli_default,
    randomBeta: () => beta_default,
    randomBinomial: () => binomial_default,
    randomCauchy: () => cauchy_default,
    randomExponential: () => exponential_default,
    randomGamma: () => gamma_default,
    randomGeometric: () => geometric_default,
    randomInt: () => int_default,
    randomIrwinHall: () => irwinHall_default,
    randomLcg: () => lcg,
    randomLogNormal: () => logNormal_default,
    randomLogistic: () => logistic_default,
    randomNormal: () => normal_default,
    randomPareto: () => pareto_default,
    randomPoisson: () => poisson_default,
    randomUniform: () => uniform_default,
    randomWeibull: () => weibull_default,
    range: () => range,
    rank: () => rank,
    reduce: () => reduce,
    reverse: () => reverse,
    rgb: () => rgb,
    ribbon: () => ribbon_default,
    ribbonArrow: () => ribbonArrow,
    rollup: () => rollup,
    rollups: () => rollups,
    scaleBand: () => band,
    scaleDiverging: () => diverging,
    scaleDivergingLog: () => divergingLog,
    scaleDivergingPow: () => divergingPow,
    scaleDivergingSqrt: () => divergingSqrt,
    scaleDivergingSymlog: () => divergingSymlog,
    scaleIdentity: () => identity4,
    scaleImplicit: () => implicit,
    scaleLinear: () => linear3,
    scaleLog: () => log2,
    scaleOrdinal: () => ordinal,
    scalePoint: () => point,
    scalePow: () => pow3,
    scaleQuantile: () => quantile2,
    scaleQuantize: () => quantize,
    scaleRadial: () => radial,
    scaleSequential: () => sequential,
    scaleSequentialLog: () => sequentialLog,
    scaleSequentialPow: () => sequentialPow,
    scaleSequentialQuantile: () => sequentialQuantile,
    scaleSequentialSqrt: () => sequentialSqrt,
    scaleSequentialSymlog: () => sequentialSymlog,
    scaleSqrt: () => sqrt2,
    scaleSymlog: () => symlog,
    scaleThreshold: () => threshold,
    scaleTime: () => time,
    scaleUtc: () => utcTime,
    scan: () => scan,
    schemeAccent: () => Accent_default,
    schemeBlues: () => scheme22,
    schemeBrBG: () => scheme,
    schemeBuGn: () => scheme10,
    schemeBuPu: () => scheme11,
    schemeCategory10: () => category10_default,
    schemeDark2: () => Dark2_default,
    schemeGnBu: () => scheme12,
    schemeGreens: () => scheme23,
    schemeGreys: () => scheme24,
    schemeObservable10: () => observable10_default,
    schemeOrRd: () => scheme13,
    schemeOranges: () => scheme27,
    schemePRGn: () => scheme2,
    schemePaired: () => Paired_default,
    schemePastel1: () => Pastel1_default,
    schemePastel2: () => Pastel2_default,
    schemePiYG: () => scheme3,
    schemePuBu: () => scheme15,
    schemePuBuGn: () => scheme14,
    schemePuOr: () => scheme4,
    schemePuRd: () => scheme16,
    schemePurples: () => scheme25,
    schemeRdBu: () => scheme5,
    schemeRdGy: () => scheme6,
    schemeRdPu: () => scheme17,
    schemeRdYlBu: () => scheme7,
    schemeRdYlGn: () => scheme8,
    schemeReds: () => scheme26,
    schemeSet1: () => Set1_default,
    schemeSet2: () => Set2_default,
    schemeSet3: () => Set3_default,
    schemeSpectral: () => scheme9,
    schemeTableau10: () => Tableau10_default,
    schemeYlGn: () => scheme19,
    schemeYlGnBu: () => scheme18,
    schemeYlOrBr: () => scheme20,
    schemeYlOrRd: () => scheme21,
    select: () => select_default2,
    selectAll: () => selectAll_default2,
    selection: () => selection_default,
    selector: () => selector_default,
    selectorAll: () => selectorAll_default,
    shuffle: () => shuffle_default,
    shuffler: () => shuffler,
    some: () => some,
    sort: () => sort,
    stack: () => stack_default,
    stackOffsetDiverging: () => diverging_default,
    stackOffsetExpand: () => expand_default,
    stackOffsetNone: () => none_default,
    stackOffsetSilhouette: () => silhouette_default,
    stackOffsetWiggle: () => wiggle_default,
    stackOrderAppearance: () => appearance_default,
    stackOrderAscending: () => ascending_default2,
    stackOrderDescending: () => descending_default2,
    stackOrderInsideOut: () => insideOut_default,
    stackOrderNone: () => none_default2,
    stackOrderReverse: () => reverse_default,
    stratify: () => stratify_default,
    style: () => styleValue,
    subset: () => subset,
    sum: () => sum,
    superset: () => superset,
    svg: () => svg,
    symbol: () => Symbol2,
    symbolAsterisk: () => asterisk_default,
    symbolCircle: () => circle_default3,
    symbolCross: () => cross_default2,
    symbolDiamond: () => diamond_default,
    symbolDiamond2: () => diamond2_default,
    symbolPlus: () => plus_default,
    symbolSquare: () => square_default,
    symbolSquare2: () => square2_default,
    symbolStar: () => star_default,
    symbolTimes: () => times_default,
    symbolTriangle: () => triangle_default,
    symbolTriangle2: () => triangle2_default,
    symbolWye: () => wye_default,
    symbolX: () => times_default,
    symbols: () => symbolsFill,
    symbolsFill: () => symbolsFill,
    symbolsStroke: () => symbolsStroke,
    text: () => text_default3,
    thresholdFreedmanDiaconis: () => thresholdFreedmanDiaconis,
    thresholdScott: () => thresholdScott,
    thresholdSturges: () => thresholdSturges,
    tickFormat: () => tickFormat,
    tickIncrement: () => tickIncrement,
    tickStep: () => tickStep,
    ticks: () => ticks,
    timeDay: () => timeDay,
    timeDays: () => timeDays,
    timeFormat: () => timeFormat,
    timeFormatDefaultLocale: () => defaultLocale2,
    timeFormatLocale: () => formatLocale,
    timeFriday: () => timeFriday,
    timeFridays: () => timeFridays,
    timeHour: () => timeHour,
    timeHours: () => timeHours,
    timeInterval: () => timeInterval,
    timeMillisecond: () => millisecond,
    timeMilliseconds: () => milliseconds,
    timeMinute: () => timeMinute,
    timeMinutes: () => timeMinutes,
    timeMonday: () => timeMonday,
    timeMondays: () => timeMondays,
    timeMonth: () => timeMonth,
    timeMonths: () => timeMonths,
    timeParse: () => timeParse,
    timeSaturday: () => timeSaturday,
    timeSaturdays: () => timeSaturdays,
    timeSecond: () => second,
    timeSeconds: () => seconds,
    timeSunday: () => timeSunday,
    timeSundays: () => timeSundays,
    timeThursday: () => timeThursday,
    timeThursdays: () => timeThursdays,
    timeTickInterval: () => timeTickInterval,
    timeTicks: () => timeTicks,
    timeTuesday: () => timeTuesday,
    timeTuesdays: () => timeTuesdays,
    timeWednesday: () => timeWednesday,
    timeWednesdays: () => timeWednesdays,
    timeWeek: () => timeSunday,
    timeWeeks: () => timeSundays,
    timeYear: () => timeYear,
    timeYears: () => timeYears,
    timeout: () => timeout_default,
    timer: () => timer,
    timerFlush: () => timerFlush,
    transition: () => transition2,
    transpose: () => transpose,
    tree: () => tree_default,
    treemap: () => treemap_default,
    treemapBinary: () => binary_default,
    treemapDice: () => dice_default,
    treemapResquarify: () => resquarify_default,
    treemapSlice: () => slice_default,
    treemapSliceDice: () => sliceDice_default,
    treemapSquarify: () => squarify_default,
    tsv: () => tsv2,
    tsvFormat: () => tsvFormat,
    tsvFormatBody: () => tsvFormatBody,
    tsvFormatRow: () => tsvFormatRow,
    tsvFormatRows: () => tsvFormatRows,
    tsvFormatValue: () => tsvFormatValue,
    tsvParse: () => tsvParse,
    tsvParseRows: () => tsvParseRows,
    union: () => union,
    unixDay: () => unixDay,
    unixDays: () => unixDays,
    utcDay: () => utcDay,
    utcDays: () => utcDays,
    utcFormat: () => utcFormat,
    utcFriday: () => utcFriday,
    utcFridays: () => utcFridays,
    utcHour: () => utcHour,
    utcHours: () => utcHours,
    utcMillisecond: () => millisecond,
    utcMilliseconds: () => milliseconds,
    utcMinute: () => utcMinute,
    utcMinutes: () => utcMinutes,
    utcMonday: () => utcMonday,
    utcMondays: () => utcMondays,
    utcMonth: () => utcMonth,
    utcMonths: () => utcMonths,
    utcParse: () => utcParse,
    utcSaturday: () => utcSaturday,
    utcSaturdays: () => utcSaturdays,
    utcSecond: () => second,
    utcSeconds: () => seconds,
    utcSunday: () => utcSunday,
    utcSundays: () => utcSundays,
    utcThursday: () => utcThursday,
    utcThursdays: () => utcThursdays,
    utcTickInterval: () => utcTickInterval,
    utcTicks: () => utcTicks,
    utcTuesday: () => utcTuesday,
    utcTuesdays: () => utcTuesdays,
    utcWednesday: () => utcWednesday,
    utcWednesdays: () => utcWednesdays,
    utcWeek: () => utcSunday,
    utcWeeks: () => utcSundays,
    utcYear: () => utcYear,
    utcYears: () => utcYears,
    variance: () => variance,
    window: () => window_default,
    xml: () => xml_default,
    zip: () => zip,
    zoom: () => zoom_default2,
    zoomIdentity: () => identity5,
    zoomTransform: () => transform
  });

  // node_modules/d3-array/src/ascending.js
  function ascending(a4, b10) {
    return a4 == null || b10 == null ? NaN : a4 < b10 ? -1 : a4 > b10 ? 1 : a4 >= b10 ? 0 : NaN;
  }

  // node_modules/d3-array/src/descending.js
  function descending(a4, b10) {
    return a4 == null || b10 == null ? NaN : b10 < a4 ? -1 : b10 > a4 ? 1 : b10 >= a4 ? 0 : NaN;
  }

  // node_modules/d3-array/src/bisector.js
  function bisector(f) {
    let compare1, compare2, delta;
    if (f.length !== 2) {
      compare1 = ascending;
      compare2 = (d, x5) => ascending(f(d), x5);
      delta = (d, x5) => f(d) - x5;
    } else {
      compare1 = f === ascending || f === descending ? f : zero;
      compare2 = f;
      delta = f;
    }
    function left2(a4, x5, lo = 0, hi = a4.length) {
      if (lo < hi) {
        if (compare1(x5, x5) !== 0) return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a4[mid], x5) < 0) lo = mid + 1;
          else hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function right2(a4, x5, lo = 0, hi = a4.length) {
      if (lo < hi) {
        if (compare1(x5, x5) !== 0) return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a4[mid], x5) <= 0) lo = mid + 1;
          else hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function center2(a4, x5, lo = 0, hi = a4.length) {
      const i = left2(a4, x5, lo, hi - 1);
      return i > lo && delta(a4[i - 1], x5) > -delta(a4[i], x5) ? i - 1 : i;
    }
    return { left: left2, center: center2, right: right2 };
  }
  function zero() {
    return 0;
  }

  // node_modules/d3-array/src/number.js
  function number(x5) {
    return x5 === null ? NaN : +x5;
  }
  function* numbers(values2, valueof) {
    if (valueof === void 0) {
      for (let value of values2) {
        if (value != null && (value = +value) >= value) {
          yield value;
        }
      }
    } else {
      let index4 = -1;
      for (let value of values2) {
        if ((value = valueof(value, ++index4, values2)) != null && (value = +value) >= value) {
          yield value;
        }
      }
    }
  }

  // node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;
  var bisectCenter = bisector(number).center;
  var bisect_default = bisectRight;

  // node_modules/d3-array/src/blur.js
  function blur(values2, r) {
    if (!((r = +r) >= 0)) throw new RangeError("invalid r");
    let length3 = values2.length;
    if (!((length3 = Math.floor(length3)) >= 0)) throw new RangeError("invalid length");
    if (!length3 || !r) return values2;
    const blur3 = blurf(r);
    const temp = values2.slice();
    blur3(values2, temp, 0, length3, 1);
    blur3(temp, values2, 0, length3, 1);
    blur3(values2, temp, 0, length3, 1);
    return values2;
  }
  var blur2 = Blur2(blurf);
  var blurImage = Blur2(blurfImage);
  function Blur2(blur3) {
    return function(data2, rx, ry = rx) {
      if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
      if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
      let { data: values2, width: width2, height: height2 } = data2;
      if (!((width2 = Math.floor(width2)) >= 0)) throw new RangeError("invalid width");
      if (!((height2 = Math.floor(height2 !== void 0 ? height2 : values2.length / width2)) >= 0)) throw new RangeError("invalid height");
      if (!width2 || !height2 || !rx && !ry) return data2;
      const blurx = rx && blur3(rx);
      const blury = ry && blur3(ry);
      const temp = values2.slice();
      if (blurx && blury) {
        blurh(blurx, temp, values2, width2, height2);
        blurh(blurx, values2, temp, width2, height2);
        blurh(blurx, temp, values2, width2, height2);
        blurv(blury, values2, temp, width2, height2);
        blurv(blury, temp, values2, width2, height2);
        blurv(blury, values2, temp, width2, height2);
      } else if (blurx) {
        blurh(blurx, values2, temp, width2, height2);
        blurh(blurx, temp, values2, width2, height2);
        blurh(blurx, values2, temp, width2, height2);
      } else if (blury) {
        blurv(blury, values2, temp, width2, height2);
        blurv(blury, temp, values2, width2, height2);
        blurv(blury, values2, temp, width2, height2);
      }
      return data2;
    };
  }
  function blurh(blur3, T2, S2, w, h2) {
    for (let y5 = 0, n = w * h2; y5 < n; ) {
      blur3(T2, S2, y5, y5 += w, 1);
    }
  }
  function blurv(blur3, T2, S2, w, h2) {
    for (let x5 = 0, n = w * h2; x5 < w; ++x5) {
      blur3(T2, S2, x5, x5 + n, w);
    }
  }
  function blurfImage(radius) {
    const blur3 = blurf(radius);
    return (T2, S2, start2, stop, step) => {
      start2 <<= 2, stop <<= 2, step <<= 2;
      blur3(T2, S2, start2 + 0, stop + 0, step);
      blur3(T2, S2, start2 + 1, stop + 1, step);
      blur3(T2, S2, start2 + 2, stop + 2, step);
      blur3(T2, S2, start2 + 3, stop + 3, step);
    };
  }
  function blurf(radius) {
    const radius0 = Math.floor(radius);
    if (radius0 === radius) return bluri(radius);
    const t = radius - radius0;
    const w = 2 * radius + 1;
    return (T2, S2, start2, stop, step) => {
      if (!((stop -= step) >= start2)) return;
      let sum4 = radius0 * S2[start2];
      const s0 = step * radius0;
      const s1 = s0 + step;
      for (let i = start2, j2 = start2 + s0; i < j2; i += step) {
        sum4 += S2[Math.min(stop, i)];
      }
      for (let i = start2, j2 = stop; i <= j2; i += step) {
        sum4 += S2[Math.min(stop, i + s0)];
        T2[i] = (sum4 + t * (S2[Math.max(start2, i - s1)] + S2[Math.min(stop, i + s1)])) / w;
        sum4 -= S2[Math.max(start2, i - s0)];
      }
    };
  }
  function bluri(radius) {
    const w = 2 * radius + 1;
    return (T2, S2, start2, stop, step) => {
      if (!((stop -= step) >= start2)) return;
      let sum4 = radius * S2[start2];
      const s2 = step * radius;
      for (let i = start2, j2 = start2 + s2; i < j2; i += step) {
        sum4 += S2[Math.min(stop, i)];
      }
      for (let i = start2, j2 = stop; i <= j2; i += step) {
        sum4 += S2[Math.min(stop, i + s2)];
        T2[i] = sum4 / w;
        sum4 -= S2[Math.max(start2, i - s2)];
      }
    };
  }

  // node_modules/d3-array/src/count.js
  function count(values2, valueof) {
    let count3 = 0;
    if (valueof === void 0) {
      for (let value of values2) {
        if (value != null && (value = +value) >= value) {
          ++count3;
        }
      }
    } else {
      let index4 = -1;
      for (let value of values2) {
        if ((value = valueof(value, ++index4, values2)) != null && (value = +value) >= value) {
          ++count3;
        }
      }
    }
    return count3;
  }

  // node_modules/d3-array/src/cross.js
  function length(array4) {
    return array4.length | 0;
  }
  function empty(length3) {
    return !(length3 > 0);
  }
  function arrayify(values2) {
    return typeof values2 !== "object" || "length" in values2 ? values2 : Array.from(values2);
  }
  function reducer(reduce2) {
    return (values2) => reduce2(...values2);
  }
  function cross(...values2) {
    const reduce2 = typeof values2[values2.length - 1] === "function" && reducer(values2.pop());
    values2 = values2.map(arrayify);
    const lengths = values2.map(length);
    const j2 = values2.length - 1;
    const index4 = new Array(j2 + 1).fill(0);
    const product = [];
    if (j2 < 0 || lengths.some(empty)) return product;
    while (true) {
      product.push(index4.map((j3, i2) => values2[i2][j3]));
      let i = j2;
      while (++index4[i] === lengths[i]) {
        if (i === 0) return reduce2 ? product.map(reduce2) : product;
        index4[i--] = 0;
      }
    }
  }

  // node_modules/d3-array/src/cumsum.js
  function cumsum(values2, valueof) {
    var sum4 = 0, index4 = 0;
    return Float64Array.from(values2, valueof === void 0 ? (v3) => sum4 += +v3 || 0 : (v3) => sum4 += +valueof(v3, index4++, values2) || 0);
  }

  // node_modules/d3-array/src/variance.js
  function variance(values2, valueof) {
    let count3 = 0;
    let delta;
    let mean2 = 0;
    let sum4 = 0;
    if (valueof === void 0) {
      for (let value of values2) {
        if (value != null && (value = +value) >= value) {
          delta = value - mean2;
          mean2 += delta / ++count3;
          sum4 += delta * (value - mean2);
        }
      }
    } else {
      let index4 = -1;
      for (let value of values2) {
        if ((value = valueof(value, ++index4, values2)) != null && (value = +value) >= value) {
          delta = value - mean2;
          mean2 += delta / ++count3;
          sum4 += delta * (value - mean2);
        }
      }
    }
    if (count3 > 1) return sum4 / (count3 - 1);
  }

  // node_modules/d3-array/src/deviation.js
  function deviation(values2, valueof) {
    const v3 = variance(values2, valueof);
    return v3 ? Math.sqrt(v3) : v3;
  }

  // node_modules/d3-array/src/extent.js
  function extent(values2, valueof) {
    let min4;
    let max5;
    if (valueof === void 0) {
      for (const value of values2) {
        if (value != null) {
          if (min4 === void 0) {
            if (value >= value) min4 = max5 = value;
          } else {
            if (min4 > value) min4 = value;
            if (max5 < value) max5 = value;
          }
        }
      }
    } else {
      let index4 = -1;
      for (let value of values2) {
        if ((value = valueof(value, ++index4, values2)) != null) {
          if (min4 === void 0) {
            if (value >= value) min4 = max5 = value;
          } else {
            if (min4 > value) min4 = value;
            if (max5 < value) max5 = value;
          }
        }
      }
    }
    return [min4, max5];
  }

  // node_modules/d3-array/src/fsum.js
  var Adder = class {
    constructor() {
      this._partials = new Float64Array(32);
      this._n = 0;
    }
    add(x5) {
      const p = this._partials;
      let i = 0;
      for (let j2 = 0; j2 < this._n && j2 < 32; j2++) {
        const y5 = p[j2], hi = x5 + y5, lo = Math.abs(x5) < Math.abs(y5) ? x5 - (hi - y5) : y5 - (hi - x5);
        if (lo) p[i++] = lo;
        x5 = hi;
      }
      p[i] = x5;
      this._n = i + 1;
      return this;
    }
    valueOf() {
      const p = this._partials;
      let n = this._n, x5, y5, lo, hi = 0;
      if (n > 0) {
        hi = p[--n];
        while (n > 0) {
          x5 = hi;
          y5 = p[--n];
          hi = x5 + y5;
          lo = y5 - (hi - x5);
          if (lo) break;
        }
        if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
          y5 = lo * 2;
          x5 = hi + y5;
          if (y5 == x5 - hi) hi = x5;
        }
      }
      return hi;
    }
  };
  function fsum(values2, valueof) {
    const adder = new Adder();
    if (valueof === void 0) {
      for (let value of values2) {
        if (value = +value) {
          adder.add(value);
        }
      }
    } else {
      let index4 = -1;
      for (let value of values2) {
        if (value = +valueof(value, ++index4, values2)) {
          adder.add(value);
        }
      }
    }
    return +adder;
  }
  function fcumsum(values2, valueof) {
    const adder = new Adder();
    let index4 = -1;
    return Float64Array.from(
      values2,
      valueof === void 0 ? (v3) => adder.add(+v3 || 0) : (v3) => adder.add(+valueof(v3, ++index4, values2) || 0)
    );
  }

  // node_modules/internmap/src/index.js
  var InternMap = class extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value) {
      return super.set(intern_set(this, key), value);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  };
  var InternSet = class extends Set {
    constructor(values2, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (values2 != null) for (const value of values2) this.add(value);
    }
    has(value) {
      return super.has(intern_get(this, value));
    }
    add(value) {
      return super.add(intern_set(this, value));
    }
    delete(value) {
      return super.delete(intern_delete(this, value));
    }
  };
  function intern_get({ _intern, _key }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
  }
  function intern_set({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value);
    return value;
  }
  function intern_delete({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
      value = _intern.get(key);
      _intern.delete(key);
    }
    return value;
  }
  function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }

  // node_modules/d3-array/src/identity.js
  function identity(x5) {
    return x5;
  }

  // node_modules/d3-array/src/group.js
  function group(values2, ...keys) {
    return nest(values2, identity, identity, keys);
  }
  function groups(values2, ...keys) {
    return nest(values2, Array.from, identity, keys);
  }
  function flatten(groups2, keys) {
    for (let i = 1, n = keys.length; i < n; ++i) {
      groups2 = groups2.flatMap((g) => g.pop().map(([key, value]) => [...g, key, value]));
    }
    return groups2;
  }
  function flatGroup(values2, ...keys) {
    return flatten(groups(values2, ...keys), keys);
  }
  function flatRollup(values2, reduce2, ...keys) {
    return flatten(rollups(values2, reduce2, ...keys), keys);
  }
  function rollup(values2, reduce2, ...keys) {
    return nest(values2, identity, reduce2, keys);
  }
  function rollups(values2, reduce2, ...keys) {
    return nest(values2, Array.from, reduce2, keys);
  }
  function index2(values2, ...keys) {
    return nest(values2, identity, unique, keys);
  }
  function indexes(values2, ...keys) {
    return nest(values2, Array.from, unique, keys);
  }
  function unique(values2) {
    if (values2.length !== 1) throw new Error("duplicate key");
    return values2[0];
  }
  function nest(values2, map4, reduce2, keys) {
    return function regroup(values3, i) {
      if (i >= keys.length) return reduce2(values3);
      const groups2 = new InternMap();
      const keyof2 = keys[i++];
      let index4 = -1;
      for (const value of values3) {
        const key = keyof2(value, ++index4, values3);
        const group2 = groups2.get(key);
        if (group2) group2.push(value);
        else groups2.set(key, [value]);
      }
      for (const [key, values4] of groups2) {
        groups2.set(key, regroup(values4, i));
      }
      return map4(groups2);
    }(values2, 0);
  }

  // node_modules/d3-array/src/permute.js
  function permute(source2, keys) {
    return Array.from(keys, (key) => source2[key]);
  }

  // node_modules/d3-array/src/sort.js
  function sort(values2, ...F2) {
    if (typeof values2[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    values2 = Array.from(values2);
    let [f] = F2;
    if (f && f.length !== 2 || F2.length > 1) {
      const index4 = Uint32Array.from(values2, (d, i) => i);
      if (F2.length > 1) {
        F2 = F2.map((f2) => values2.map(f2));
        index4.sort((i, j2) => {
          for (const f2 of F2) {
            const c6 = ascendingDefined(f2[i], f2[j2]);
            if (c6) return c6;
          }
        });
      } else {
        f = values2.map(f);
        index4.sort((i, j2) => ascendingDefined(f[i], f[j2]));
      }
      return permute(values2, index4);
    }
    return values2.sort(compareDefined(f));
  }
  function compareDefined(compare = ascending) {
    if (compare === ascending) return ascendingDefined;
    if (typeof compare !== "function") throw new TypeError("compare is not a function");
    return (a4, b10) => {
      const x5 = compare(a4, b10);
      if (x5 || x5 === 0) return x5;
      return (compare(b10, b10) === 0) - (compare(a4, a4) === 0);
    };
  }
  function ascendingDefined(a4, b10) {
    return (a4 == null || !(a4 >= a4)) - (b10 == null || !(b10 >= b10)) || (a4 < b10 ? -1 : a4 > b10 ? 1 : 0);
  }

  // node_modules/d3-array/src/groupSort.js
  function groupSort(values2, reduce2, key) {
    return (reduce2.length !== 2 ? sort(rollup(values2, reduce2, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values2, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
  }

  // node_modules/d3-array/src/array.js
  var array = Array.prototype;
  var slice = array.slice;
  var map = array.map;

  // node_modules/d3-array/src/constant.js
  function constant(x5) {
    return () => x5;
  }

  // node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function tickSpec(start2, stop, count3) {
    const step = (stop - start2) / Math.max(0, count3), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
    let i1, i2, inc2;
    if (power < 0) {
      inc2 = Math.pow(10, -power) / factor;
      i1 = Math.round(start2 * inc2);
      i2 = Math.round(stop * inc2);
      if (i1 / inc2 < start2) ++i1;
      if (i2 / inc2 > stop) --i2;
      inc2 = -inc2;
    } else {
      inc2 = Math.pow(10, power) * factor;
      i1 = Math.round(start2 / inc2);
      i2 = Math.round(stop / inc2);
      if (i1 * inc2 < start2) ++i1;
      if (i2 * inc2 > stop) --i2;
    }
    if (i2 < i1 && 0.5 <= count3 && count3 < 2) return tickSpec(start2, stop, count3 * 2);
    return [i1, i2, inc2];
  }
  function ticks(start2, stop, count3) {
    stop = +stop, start2 = +start2, count3 = +count3;
    if (!(count3 > 0)) return [];
    if (start2 === stop) return [start2];
    const reverse2 = stop < start2, [i1, i2, inc2] = reverse2 ? tickSpec(stop, start2, count3) : tickSpec(start2, stop, count3);
    if (!(i2 >= i1)) return [];
    const n = i2 - i1 + 1, ticks2 = new Array(n);
    if (reverse2) {
      if (inc2 < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc2;
      else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc2;
    } else {
      if (inc2 < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc2;
      else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc2;
    }
    return ticks2;
  }
  function tickIncrement(start2, stop, count3) {
    stop = +stop, start2 = +start2, count3 = +count3;
    return tickSpec(start2, stop, count3)[2];
  }
  function tickStep(start2, stop, count3) {
    stop = +stop, start2 = +start2, count3 = +count3;
    const reverse2 = stop < start2, inc2 = reverse2 ? tickIncrement(stop, start2, count3) : tickIncrement(start2, stop, count3);
    return (reverse2 ? -1 : 1) * (inc2 < 0 ? 1 / -inc2 : inc2);
  }

  // node_modules/d3-array/src/nice.js
  function nice(start2, stop, count3) {
    let prestep;
    while (true) {
      const step = tickIncrement(start2, stop, count3);
      if (step === prestep || step === 0 || !isFinite(step)) {
        return [start2, stop];
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      }
      prestep = step;
    }
  }

  // node_modules/d3-array/src/threshold/sturges.js
  function thresholdSturges(values2) {
    return Math.max(1, Math.ceil(Math.log(count(values2)) / Math.LN2) + 1);
  }

  // node_modules/d3-array/src/bin.js
  function bin() {
    var value = identity, domain = extent, threshold2 = thresholdSturges;
    function histogram(data2) {
      if (!Array.isArray(data2)) data2 = Array.from(data2);
      var i, n = data2.length, x5, step, values2 = new Array(n);
      for (i = 0; i < n; ++i) {
        values2[i] = value(data2[i], i, data2);
      }
      var xz = domain(values2), x06 = xz[0], x12 = xz[1], tz = threshold2(values2, x06, x12);
      if (!Array.isArray(tz)) {
        const max5 = x12, tn = +tz;
        if (domain === extent) [x06, x12] = nice(x06, x12, tn);
        tz = ticks(x06, x12, tn);
        if (tz[0] <= x06) step = tickIncrement(x06, x12, tn);
        if (tz[tz.length - 1] >= x12) {
          if (max5 >= x12 && domain === extent) {
            const step2 = tickIncrement(x06, x12, tn);
            if (isFinite(step2)) {
              if (step2 > 0) {
                x12 = (Math.floor(x12 / step2) + 1) * step2;
              } else if (step2 < 0) {
                x12 = (Math.ceil(x12 * -step2) + 1) / -step2;
              }
            }
          } else {
            tz.pop();
          }
        }
      }
      var m4 = tz.length, a4 = 0, b10 = m4;
      while (tz[a4] <= x06) ++a4;
      while (tz[b10 - 1] > x12) --b10;
      if (a4 || b10 < m4) tz = tz.slice(a4, b10), m4 = b10 - a4;
      var bins = new Array(m4 + 1), bin2;
      for (i = 0; i <= m4; ++i) {
        bin2 = bins[i] = [];
        bin2.x0 = i > 0 ? tz[i - 1] : x06;
        bin2.x1 = i < m4 ? tz[i] : x12;
      }
      if (isFinite(step)) {
        if (step > 0) {
          for (i = 0; i < n; ++i) {
            if ((x5 = values2[i]) != null && x06 <= x5 && x5 <= x12) {
              bins[Math.min(m4, Math.floor((x5 - x06) / step))].push(data2[i]);
            }
          }
        } else if (step < 0) {
          for (i = 0; i < n; ++i) {
            if ((x5 = values2[i]) != null && x06 <= x5 && x5 <= x12) {
              const j2 = Math.floor((x06 - x5) * step);
              bins[Math.min(m4, j2 + (tz[j2] <= x5))].push(data2[i]);
            }
          }
        }
      } else {
        for (i = 0; i < n; ++i) {
          if ((x5 = values2[i]) != null && x06 <= x5 && x5 <= x12) {
            bins[bisect_default(tz, x5, 0, m4)].push(data2[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(_25) {
      return arguments.length ? (value = typeof _25 === "function" ? _25 : constant(_25), histogram) : value;
    };
    histogram.domain = function(_25) {
      return arguments.length ? (domain = typeof _25 === "function" ? _25 : constant([_25[0], _25[1]]), histogram) : domain;
    };
    histogram.thresholds = function(_25) {
      return arguments.length ? (threshold2 = typeof _25 === "function" ? _25 : constant(Array.isArray(_25) ? slice.call(_25) : _25), histogram) : threshold2;
    };
    return histogram;
  }

  // node_modules/d3-array/src/max.js
  function max(values2, valueof) {
    let max5;
    if (valueof === void 0) {
      for (const value of values2) {
        if (value != null && (max5 < value || max5 === void 0 && value >= value)) {
          max5 = value;
        }
      }
    } else {
      let index4 = -1;
      for (let value of values2) {
        if ((value = valueof(value, ++index4, values2)) != null && (max5 < value || max5 === void 0 && value >= value)) {
          max5 = value;
        }
      }
    }
    return max5;
  }

  // node_modules/d3-array/src/maxIndex.js
  function maxIndex(values2, valueof) {
    let max5;
    let maxIndex2 = -1;
    let index4 = -1;
    if (valueof === void 0) {
      for (const value of values2) {
        ++index4;
        if (value != null && (max5 < value || max5 === void 0 && value >= value)) {
          max5 = value, maxIndex2 = index4;
        }
      }
    } else {
      for (let value of values2) {
        if ((value = valueof(value, ++index4, values2)) != null && (max5 < value || max5 === void 0 && value >= value)) {
          max5 = value, maxIndex2 = index4;
        }
      }
    }
    return maxIndex2;
  }

  // node_modules/d3-array/src/min.js
  function min(values2, valueof) {
    let min4;
    if (valueof === void 0) {
      for (const value of values2) {
        if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
          min4 = value;
        }
      }
    } else {
      let index4 = -1;
      for (let value of values2) {
        if ((value = valueof(value, ++index4, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
          min4 = value;
        }
      }
    }
    return min4;
  }

  // node_modules/d3-array/src/minIndex.js
  function minIndex(values2, valueof) {
    let min4;
    let minIndex2 = -1;
    let index4 = -1;
    if (valueof === void 0) {
      for (const value of values2) {
        ++index4;
        if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
          min4 = value, minIndex2 = index4;
        }
      }
    } else {
      for (let value of values2) {
        if ((value = valueof(value, ++index4, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
          min4 = value, minIndex2 = index4;
        }
      }
    }
    return minIndex2;
  }

  // node_modules/d3-array/src/quickselect.js
  function quickselect(array4, k3, left2 = 0, right2 = Infinity, compare) {
    k3 = Math.floor(k3);
    left2 = Math.floor(Math.max(0, left2));
    right2 = Math.floor(Math.min(array4.length - 1, right2));
    if (!(left2 <= k3 && k3 <= right2)) return array4;
    compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
    while (right2 > left2) {
      if (right2 - left2 > 600) {
        const n = right2 - left2 + 1;
        const m4 = k3 - left2 + 1;
        const z2 = Math.log(n);
        const s2 = 0.5 * Math.exp(2 * z2 / 3);
        const sd = 0.5 * Math.sqrt(z2 * s2 * (n - s2) / n) * (m4 - n / 2 < 0 ? -1 : 1);
        const newLeft = Math.max(left2, Math.floor(k3 - m4 * s2 / n + sd));
        const newRight = Math.min(right2, Math.floor(k3 + (n - m4) * s2 / n + sd));
        quickselect(array4, k3, newLeft, newRight, compare);
      }
      const t = array4[k3];
      let i = left2;
      let j2 = right2;
      swap(array4, left2, k3);
      if (compare(array4[right2], t) > 0) swap(array4, left2, right2);
      while (i < j2) {
        swap(array4, i, j2), ++i, --j2;
        while (compare(array4[i], t) < 0) ++i;
        while (compare(array4[j2], t) > 0) --j2;
      }
      if (compare(array4[left2], t) === 0) swap(array4, left2, j2);
      else ++j2, swap(array4, j2, right2);
      if (j2 <= k3) left2 = j2 + 1;
      if (k3 <= j2) right2 = j2 - 1;
    }
    return array4;
  }
  function swap(array4, i, j2) {
    const t = array4[i];
    array4[i] = array4[j2];
    array4[j2] = t;
  }

  // node_modules/d3-array/src/greatest.js
  function greatest(values2, compare = ascending) {
    let max5;
    let defined = false;
    if (compare.length === 1) {
      let maxValue;
      for (const element2 of values2) {
        const value = compare(element2);
        if (defined ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {
          max5 = element2;
          maxValue = value;
          defined = true;
        }
      }
    } else {
      for (const value of values2) {
        if (defined ? compare(value, max5) > 0 : compare(value, value) === 0) {
          max5 = value;
          defined = true;
        }
      }
    }
    return max5;
  }

  // node_modules/d3-array/src/quantile.js
  function quantile(values2, p, valueof) {
    values2 = Float64Array.from(numbers(values2, valueof));
    if (!(n = values2.length) || isNaN(p = +p)) return;
    if (p <= 0 || n < 2) return min(values2);
    if (p >= 1) return max(values2);
    var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min(values2.subarray(i0 + 1));
    return value0 + (value1 - value0) * (i - i0);
  }
  function quantileSorted(values2, p, valueof = number) {
    if (!(n = values2.length) || isNaN(p = +p)) return;
    if (p <= 0 || n < 2) return +valueof(values2[0], 0, values2);
    if (p >= 1) return +valueof(values2[n - 1], n - 1, values2);
    var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values2[i0], i0, values2), value1 = +valueof(values2[i0 + 1], i0 + 1, values2);
    return value0 + (value1 - value0) * (i - i0);
  }
  function quantileIndex(values2, p, valueof = number) {
    if (isNaN(p = +p)) return;
    numbers2 = Float64Array.from(values2, (_25, i2) => number(valueof(values2[i2], i2, values2)));
    if (p <= 0) return minIndex(numbers2);
    if (p >= 1) return maxIndex(numbers2);
    var numbers2, index4 = Uint32Array.from(values2, (_25, i2) => i2), j2 = numbers2.length - 1, i = Math.floor(j2 * p);
    quickselect(index4, i, 0, j2, (i2, j3) => ascendingDefined(numbers2[i2], numbers2[j3]));
    i = greatest(index4.subarray(0, i + 1), (i2) => numbers2[i2]);
    return i >= 0 ? i : -1;
  }

  // node_modules/d3-array/src/threshold/freedmanDiaconis.js
  function thresholdFreedmanDiaconis(values2, min4, max5) {
    const c6 = count(values2), d = quantile(values2, 0.75) - quantile(values2, 0.25);
    return c6 && d ? Math.ceil((max5 - min4) / (2 * d * Math.pow(c6, -1 / 3))) : 1;
  }

  // node_modules/d3-array/src/threshold/scott.js
  function thresholdScott(values2, min4, max5) {
    const c6 = count(values2), d = deviation(values2);
    return c6 && d ? Math.ceil((max5 - min4) * Math.cbrt(c6) / (3.49 * d)) : 1;
  }

  // node_modules/d3-array/src/mean.js
  function mean(values2, valueof) {
    let count3 = 0;
    let sum4 = 0;
    if (valueof === void 0) {
      for (let value of values2) {
        if (value != null && (value = +value) >= value) {
          ++count3, sum4 += value;
        }
      }
    } else {
      let index4 = -1;
      for (let value of values2) {
        if ((value = valueof(value, ++index4, values2)) != null && (value = +value) >= value) {
          ++count3, sum4 += value;
        }
      }
    }
    if (count3) return sum4 / count3;
  }

  // node_modules/d3-array/src/median.js
  function median(values2, valueof) {
    return quantile(values2, 0.5, valueof);
  }
  function medianIndex(values2, valueof) {
    return quantileIndex(values2, 0.5, valueof);
  }

  // node_modules/d3-array/src/merge.js
  function* flatten2(arrays) {
    for (const array4 of arrays) {
      yield* array4;
    }
  }
  function merge(arrays) {
    return Array.from(flatten2(arrays));
  }

  // node_modules/d3-array/src/mode.js
  function mode(values2, valueof) {
    const counts = new InternMap();
    if (valueof === void 0) {
      for (let value of values2) {
        if (value != null && value >= value) {
          counts.set(value, (counts.get(value) || 0) + 1);
        }
      }
    } else {
      let index4 = -1;
      for (let value of values2) {
        if ((value = valueof(value, ++index4, values2)) != null && value >= value) {
          counts.set(value, (counts.get(value) || 0) + 1);
        }
      }
    }
    let modeValue;
    let modeCount = 0;
    for (const [value, count3] of counts) {
      if (count3 > modeCount) {
        modeCount = count3;
        modeValue = value;
      }
    }
    return modeValue;
  }

  // node_modules/d3-array/src/pairs.js
  function pairs(values2, pairof = pair) {
    const pairs2 = [];
    let previous;
    let first = false;
    for (const value of values2) {
      if (first) pairs2.push(pairof(previous, value));
      previous = value;
      first = true;
    }
    return pairs2;
  }
  function pair(a4, b10) {
    return [a4, b10];
  }

  // node_modules/d3-array/src/range.js
  function range(start2, stop, step) {
    start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
    var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range6 = new Array(n);
    while (++i < n) {
      range6[i] = start2 + i * step;
    }
    return range6;
  }

  // node_modules/d3-array/src/rank.js
  function rank(values2, valueof = ascending) {
    if (typeof values2[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    let V2 = Array.from(values2);
    const R2 = new Float64Array(V2.length);
    if (valueof.length !== 2) V2 = V2.map(valueof), valueof = ascending;
    const compareIndex = (i, j2) => valueof(V2[i], V2[j2]);
    let k3, r;
    values2 = Uint32Array.from(V2, (_25, i) => i);
    values2.sort(valueof === ascending ? (i, j2) => ascendingDefined(V2[i], V2[j2]) : compareDefined(compareIndex));
    values2.forEach((j2, i) => {
      const c6 = compareIndex(j2, k3 === void 0 ? j2 : k3);
      if (c6 >= 0) {
        if (k3 === void 0 || c6 > 0) k3 = j2, r = i;
        R2[j2] = r;
      } else {
        R2[j2] = NaN;
      }
    });
    return R2;
  }

  // node_modules/d3-array/src/least.js
  function least(values2, compare = ascending) {
    let min4;
    let defined = false;
    if (compare.length === 1) {
      let minValue;
      for (const element2 of values2) {
        const value = compare(element2);
        if (defined ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {
          min4 = element2;
          minValue = value;
          defined = true;
        }
      }
    } else {
      for (const value of values2) {
        if (defined ? compare(value, min4) < 0 : compare(value, value) === 0) {
          min4 = value;
          defined = true;
        }
      }
    }
    return min4;
  }

  // node_modules/d3-array/src/leastIndex.js
  function leastIndex(values2, compare = ascending) {
    if (compare.length === 1) return minIndex(values2, compare);
    let minValue;
    let min4 = -1;
    let index4 = -1;
    for (const value of values2) {
      ++index4;
      if (min4 < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {
        minValue = value;
        min4 = index4;
      }
    }
    return min4;
  }

  // node_modules/d3-array/src/greatestIndex.js
  function greatestIndex(values2, compare = ascending) {
    if (compare.length === 1) return maxIndex(values2, compare);
    let maxValue;
    let max5 = -1;
    let index4 = -1;
    for (const value of values2) {
      ++index4;
      if (max5 < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {
        maxValue = value;
        max5 = index4;
      }
    }
    return max5;
  }

  // node_modules/d3-array/src/scan.js
  function scan(values2, compare) {
    const index4 = leastIndex(values2, compare);
    return index4 < 0 ? void 0 : index4;
  }

  // node_modules/d3-array/src/shuffle.js
  var shuffle_default = shuffler(Math.random);
  function shuffler(random) {
    return function shuffle2(array4, i0 = 0, i1 = array4.length) {
      let m4 = i1 - (i0 = +i0);
      while (m4) {
        const i = random() * m4-- | 0, t = array4[m4 + i0];
        array4[m4 + i0] = array4[i + i0];
        array4[i + i0] = t;
      }
      return array4;
    };
  }

  // node_modules/d3-array/src/sum.js
  function sum(values2, valueof) {
    let sum4 = 0;
    if (valueof === void 0) {
      for (let value of values2) {
        if (value = +value) {
          sum4 += value;
        }
      }
    } else {
      let index4 = -1;
      for (let value of values2) {
        if (value = +valueof(value, ++index4, values2)) {
          sum4 += value;
        }
      }
    }
    return sum4;
  }

  // node_modules/d3-array/src/transpose.js
  function transpose(matrix2) {
    if (!(n = matrix2.length)) return [];
    for (var i = -1, m4 = min(matrix2, length2), transpose2 = new Array(m4); ++i < m4; ) {
      for (var j2 = -1, n, row = transpose2[i] = new Array(n); ++j2 < n; ) {
        row[j2] = matrix2[j2][i];
      }
    }
    return transpose2;
  }
  function length2(d) {
    return d.length;
  }

  // node_modules/d3-array/src/zip.js
  function zip() {
    return transpose(arguments);
  }

  // node_modules/d3-array/src/every.js
  function every(values2, test) {
    if (typeof test !== "function") throw new TypeError("test is not a function");
    let index4 = -1;
    for (const value of values2) {
      if (!test(value, ++index4, values2)) {
        return false;
      }
    }
    return true;
  }

  // node_modules/d3-array/src/some.js
  function some(values2, test) {
    if (typeof test !== "function") throw new TypeError("test is not a function");
    let index4 = -1;
    for (const value of values2) {
      if (test(value, ++index4, values2)) {
        return true;
      }
    }
    return false;
  }

  // node_modules/d3-array/src/filter.js
  function filter(values2, test) {
    if (typeof test !== "function") throw new TypeError("test is not a function");
    const array4 = [];
    let index4 = -1;
    for (const value of values2) {
      if (test(value, ++index4, values2)) {
        array4.push(value);
      }
    }
    return array4;
  }

  // node_modules/d3-array/src/map.js
  function map2(values2, mapper) {
    if (typeof values2[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
    return Array.from(values2, (value, index4) => mapper(value, index4, values2));
  }

  // node_modules/d3-array/src/reduce.js
  function reduce(values2, reducer2, value) {
    if (typeof reducer2 !== "function") throw new TypeError("reducer is not a function");
    const iterator = values2[Symbol.iterator]();
    let done, next2, index4 = -1;
    if (arguments.length < 3) {
      ({ done, value } = iterator.next());
      if (done) return;
      ++index4;
    }
    while ({ done, value: next2 } = iterator.next(), !done) {
      value = reducer2(value, next2, ++index4, values2);
    }
    return value;
  }

  // node_modules/d3-array/src/reverse.js
  function reverse(values2) {
    if (typeof values2[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    return Array.from(values2).reverse();
  }

  // node_modules/d3-array/src/difference.js
  function difference(values2, ...others) {
    values2 = new InternSet(values2);
    for (const other2 of others) {
      for (const value of other2) {
        values2.delete(value);
      }
    }
    return values2;
  }

  // node_modules/d3-array/src/disjoint.js
  function disjoint(values2, other2) {
    const iterator = other2[Symbol.iterator](), set5 = new InternSet();
    for (const v3 of values2) {
      if (set5.has(v3)) return false;
      let value, done;
      while ({ value, done } = iterator.next()) {
        if (done) break;
        if (Object.is(v3, value)) return false;
        set5.add(value);
      }
    }
    return true;
  }

  // node_modules/d3-array/src/intersection.js
  function intersection(values2, ...others) {
    values2 = new InternSet(values2);
    others = others.map(set2);
    out: for (const value of values2) {
      for (const other2 of others) {
        if (!other2.has(value)) {
          values2.delete(value);
          continue out;
        }
      }
    }
    return values2;
  }
  function set2(values2) {
    return values2 instanceof InternSet ? values2 : new InternSet(values2);
  }

  // node_modules/d3-array/src/superset.js
  function superset(values2, other2) {
    const iterator = values2[Symbol.iterator](), set5 = /* @__PURE__ */ new Set();
    for (const o of other2) {
      const io = intern(o);
      if (set5.has(io)) continue;
      let value, done;
      while ({ value, done } = iterator.next()) {
        if (done) return false;
        const ivalue = intern(value);
        set5.add(ivalue);
        if (Object.is(io, ivalue)) break;
      }
    }
    return true;
  }
  function intern(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }

  // node_modules/d3-array/src/subset.js
  function subset(values2, other2) {
    return superset(other2, values2);
  }

  // node_modules/d3-array/src/union.js
  function union(...others) {
    const set5 = new InternSet();
    for (const other2 of others) {
      for (const o of other2) {
        set5.add(o);
      }
    }
    return set5;
  }

  // node_modules/d3-axis/src/identity.js
  function identity_default(x5) {
    return x5;
  }

  // node_modules/d3-axis/src/axis.js
  var top = 1;
  var right = 2;
  var bottom = 3;
  var left = 4;
  var epsilon = 1e-6;
  function translateX(x5) {
    return "translate(" + x5 + ",0)";
  }
  function translateY(y5) {
    return "translate(0," + y5 + ")";
  }
  function number2(scale2) {
    return (d) => +scale2(d);
  }
  function center(scale2, offset) {
    offset = Math.max(0, scale2.bandwidth() - offset * 2) / 2;
    if (scale2.round()) offset = Math.round(offset);
    return (d) => +scale2(d) + offset;
  }
  function entering() {
    return !this.__axis;
  }
  function axis(orient, scale2) {
    var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k3 = orient === top || orient === left ? -1 : 1, x5 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
    function axis2(context) {
      var values2 = tickValues == null ? scale2.ticks ? scale2.ticks.apply(scale2, tickArguments) : scale2.domain() : tickValues, format2 = tickFormat2 == null ? scale2.tickFormat ? scale2.tickFormat.apply(scale2, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range6 = scale2.range(), range0 = +range6[0] + offset, range1 = +range6[range6.length - 1] + offset, position = (scale2.bandwidth ? center : number2)(scale2.copy(), offset), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick2 = selection2.selectAll(".tick").data(values2, scale2).order(), tickExit = tick2.exit(), tickEnter = tick2.enter().append("g").attr("class", "tick"), line = tick2.select("line"), text2 = tick2.select("text");
      path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
      tick2 = tick2.merge(tickEnter);
      line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x5 + "2", k3 * tickSizeInner));
      text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x5, k3 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
      if (context !== selection2) {
        path2 = path2.transition(context);
        tick2 = tick2.transition(context);
        line = line.transition(context);
        text2 = text2.transition(context);
        tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
          return isFinite(d = position(d)) ? transform2(d + offset) : this.getAttribute("transform");
        });
        tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
          var p = this.parentNode.__axis;
          return transform2((p && isFinite(p = p(d)) ? p : position(d)) + offset);
        });
      }
      tickExit.remove();
      path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k3 * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k3 * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k3 * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k3 * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
      tick2.attr("opacity", 1).attr("transform", function(d) {
        return transform2(position(d) + offset);
      });
      line.attr(x5 + "2", k3 * tickSizeInner);
      text2.attr(x5, k3 * spacing).text(format2);
      selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
      selection2.each(function() {
        this.__axis = position;
      });
    }
    axis2.scale = function(_25) {
      return arguments.length ? (scale2 = _25, axis2) : scale2;
    };
    axis2.ticks = function() {
      return tickArguments = Array.from(arguments), axis2;
    };
    axis2.tickArguments = function(_25) {
      return arguments.length ? (tickArguments = _25 == null ? [] : Array.from(_25), axis2) : tickArguments.slice();
    };
    axis2.tickValues = function(_25) {
      return arguments.length ? (tickValues = _25 == null ? null : Array.from(_25), axis2) : tickValues && tickValues.slice();
    };
    axis2.tickFormat = function(_25) {
      return arguments.length ? (tickFormat2 = _25, axis2) : tickFormat2;
    };
    axis2.tickSize = function(_25) {
      return arguments.length ? (tickSizeInner = tickSizeOuter = +_25, axis2) : tickSizeInner;
    };
    axis2.tickSizeInner = function(_25) {
      return arguments.length ? (tickSizeInner = +_25, axis2) : tickSizeInner;
    };
    axis2.tickSizeOuter = function(_25) {
      return arguments.length ? (tickSizeOuter = +_25, axis2) : tickSizeOuter;
    };
    axis2.tickPadding = function(_25) {
      return arguments.length ? (tickPadding = +_25, axis2) : tickPadding;
    };
    axis2.offset = function(_25) {
      return arguments.length ? (offset = +_25, axis2) : offset;
    };
    return axis2;
  }
  function axisTop(scale2) {
    return axis(top, scale2);
  }
  function axisRight(scale2) {
    return axis(right, scale2);
  }
  function axisBottom(scale2) {
    return axis(bottom, scale2);
  }
  function axisLeft(scale2) {
    return axis(left, scale2);
  }

  // node_modules/d3-dispatch/src/dispatch.js
  var noop2 = { value: () => {
  } };
  function dispatch() {
    for (var i = 0, n = arguments.length, _25 = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || t in _25 || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
      _25[t] = [];
    }
    return new Dispatch(_25);
  }
  function Dispatch(_25) {
    this._ = _25;
  }
  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      return { type: t, name };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _25 = this._, T2 = parseTypenames(typename + "", _25), t, i = -1, n = T2.length;
      if (arguments.length < 2) {
        while (++i < n) if ((t = (typename = T2[i]).type) && (t = get3(_25[t], typename.name))) return t;
        return;
      }
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T2[i]).type) _25[t] = set3(_25[t], typename.name, callback);
        else if (callback == null) for (t in _25) _25[t] = set3(_25[t], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy3 = {}, _25 = this._;
      for (var t in _25) copy3[t] = _25[t].slice();
      return new Dispatch(copy3);
    },
    call: function(type2, that) {
      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
      for (t = this._[type2], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    },
    apply: function(type2, that, args) {
      if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
      for (var t = this._[type2], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    }
  };
  function get3(type2, name) {
    for (var i = 0, n = type2.length, c6; i < n; ++i) {
      if ((c6 = type2[i]).name === name) {
        return c6.value;
      }
    }
  }
  function set3(type2, name, callback) {
    for (var i = 0, n = type2.length; i < n; ++i) {
      if (type2[i].name === name) {
        type2[i] = noop2, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
        break;
      }
    }
    if (callback != null) type2.push({ name, value: callback });
    return type2;
  }
  var dispatch_default = dispatch;

  // node_modules/d3-selection/src/namespaces.js
  var xhtml = "http://www.w3.org/1999/xhtml";
  var namespaces_default = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  // node_modules/d3-selection/src/namespace.js
  function namespace_default(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
  }

  // node_modules/d3-selection/src/creator.js
  function creatorInherit(name) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator_default(name) {
    var fullname = namespace_default(name);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }

  // node_modules/d3-selection/src/selector.js
  function none() {
  }
  function selector_default(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  // node_modules/d3-selection/src/selection/select.js
  function select_default(select) {
    if (typeof select !== "function") select = selector_default(select);
    for (var groups2 = this._groups, m4 = groups2.length, subgroups = new Array(m4), j2 = 0; j2 < m4; ++j2) {
      for (var group2 = groups2[j2], n = group2.length, subgroup = subgroups[j2] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group2[i]) && (subnode = select.call(node, node.__data__, i, group2))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/array.js
  function array2(x5) {
    return x5 == null ? [] : Array.isArray(x5) ? x5 : Array.from(x5);
  }

  // node_modules/d3-selection/src/selectorAll.js
  function empty2() {
    return [];
  }
  function selectorAll_default(selector) {
    return selector == null ? empty2 : function() {
      return this.querySelectorAll(selector);
    };
  }

  // node_modules/d3-selection/src/selection/selectAll.js
  function arrayAll(select) {
    return function() {
      return array2(select.apply(this, arguments));
    };
  }
  function selectAll_default(select) {
    if (typeof select === "function") select = arrayAll(select);
    else select = selectorAll_default(select);
    for (var groups2 = this._groups, m4 = groups2.length, subgroups = [], parents = [], j2 = 0; j2 < m4; ++j2) {
      for (var group2 = groups2[j2], n = group2.length, node, i = 0; i < n; ++i) {
        if (node = group2[i]) {
          subgroups.push(select.call(node, node.__data__, i, group2));
          parents.push(node);
        }
      }
    }
    return new Selection(subgroups, parents);
  }

  // node_modules/d3-selection/src/matcher.js
  function matcher_default(selector) {
    return function() {
      return this.matches(selector);
    };
  }
  function childMatcher(selector) {
    return function(node) {
      return node.matches(selector);
    };
  }

  // node_modules/d3-selection/src/selection/selectChild.js
  var find = Array.prototype.find;
  function childFind(match2) {
    return function() {
      return find.call(this.children, match2);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selectChild_default(match2) {
    return this.select(match2 == null ? childFirst : childFind(typeof match2 === "function" ? match2 : childMatcher(match2)));
  }

  // node_modules/d3-selection/src/selection/selectChildren.js
  var filter2 = Array.prototype.filter;
  function children() {
    return Array.from(this.children);
  }
  function childrenFilter(match2) {
    return function() {
      return filter2.call(this.children, match2);
    };
  }
  function selectChildren_default(match2) {
    return this.selectAll(match2 == null ? children : childrenFilter(typeof match2 === "function" ? match2 : childMatcher(match2)));
  }

  // node_modules/d3-selection/src/selection/filter.js
  function filter_default(match2) {
    if (typeof match2 !== "function") match2 = matcher_default(match2);
    for (var groups2 = this._groups, m4 = groups2.length, subgroups = new Array(m4), j2 = 0; j2 < m4; ++j2) {
      for (var group2 = groups2[j2], n = group2.length, subgroup = subgroups[j2] = [], node, i = 0; i < n; ++i) {
        if ((node = group2[i]) && match2.call(node, node.__data__, i, group2)) {
          subgroup.push(node);
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/selection/sparse.js
  function sparse_default(update2) {
    return new Array(update2.length);
  }

  // node_modules/d3-selection/src/selection/enter.js
  function enter_default() {
    return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
  }
  function EnterNode(parent, datum2) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum2;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child2) {
      return this._parent.insertBefore(child2, this._next);
    },
    insertBefore: function(child2, next2) {
      return this._parent.insertBefore(child2, next2);
    },
    querySelector: function(selector) {
      return this._parent.querySelector(selector);
    },
    querySelectorAll: function(selector) {
      return this._parent.querySelectorAll(selector);
    }
  };

  // node_modules/d3-selection/src/constant.js
  function constant_default(x5) {
    return function() {
      return x5;
    };
  }

  // node_modules/d3-selection/src/selection/data.js
  function bindIndex(parent, group2, enter, update2, exit, data2) {
    var i = 0, node, groupLength = group2.length, dataLength = data2.length;
    for (; i < dataLength; ++i) {
      if (node = group2[i]) {
        node.__data__ = data2[i];
        update2[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data2[i]);
      }
    }
    for (; i < groupLength; ++i) {
      if (node = group2[i]) {
        exit[i] = node;
      }
    }
  }
  function bindKey(parent, group2, enter, update2, exit, data2, key) {
    var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group2.length, dataLength = data2.length, keyValues = new Array(groupLength), keyValue;
    for (i = 0; i < groupLength; ++i) {
      if (node = group2[i]) {
        keyValues[i] = keyValue = key.call(node, node.__data__, i, group2) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }
    for (i = 0; i < dataLength; ++i) {
      keyValue = key.call(parent, data2[i], i, data2) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update2[i] = node;
        node.__data__ = data2[i];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i] = new EnterNode(parent, data2[i]);
      }
    }
    for (i = 0; i < groupLength; ++i) {
      if ((node = group2[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
        exit[i] = node;
      }
    }
  }
  function datum(node) {
    return node.__data__;
  }
  function data_default(value, key) {
    if (!arguments.length) return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;
    if (typeof value !== "function") value = constant_default(value);
    for (var m4 = groups2.length, update2 = new Array(m4), enter = new Array(m4), exit = new Array(m4), j2 = 0; j2 < m4; ++j2) {
      var parent = parents[j2], group2 = groups2[j2], groupLength = group2.length, data2 = arraylike(value.call(parent, parent && parent.__data__, j2, parents)), dataLength = data2.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update2[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
      bind(parent, group2, enterGroup, updateGroup, exitGroup, data2, key);
      for (var i0 = 0, i1 = 0, previous, next2; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next2 = updateGroup[i1]) && ++i1 < dataLength) ;
          previous._next = next2 || null;
        }
      }
    }
    update2 = new Selection(update2, parents);
    update2._enter = enter;
    update2._exit = exit;
    return update2;
  }
  function arraylike(data2) {
    return typeof data2 === "object" && "length" in data2 ? data2 : Array.from(data2);
  }

  // node_modules/d3-selection/src/selection/exit.js
  function exit_default() {
    return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
  }

  // node_modules/d3-selection/src/selection/join.js
  function join_default(onenter, onupdate, onexit) {
    var enter = this.enter(), update2 = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter) enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update2 = onupdate(update2);
      if (update2) update2 = update2.selection();
    }
    if (onexit == null) exit.remove();
    else onexit(exit);
    return enter && update2 ? enter.merge(update2).order() : update2;
  }

  // node_modules/d3-selection/src/selection/merge.js
  function merge_default(context) {
    var selection2 = context.selection ? context.selection() : context;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m4 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m4; ++j2) {
      for (var group0 = groups0[j2], group1 = groups1[j2], n = group0.length, merge2 = merges[j2] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge2[i] = node;
        }
      }
    }
    for (; j2 < m0; ++j2) {
      merges[j2] = groups0[j2];
    }
    return new Selection(merges, this._parents);
  }

  // node_modules/d3-selection/src/selection/order.js
  function order_default() {
    for (var groups2 = this._groups, j2 = -1, m4 = groups2.length; ++j2 < m4; ) {
      for (var group2 = groups2[j2], i = group2.length - 1, next2 = group2[i], node; --i >= 0; ) {
        if (node = group2[i]) {
          if (next2 && node.compareDocumentPosition(next2) ^ 4) next2.parentNode.insertBefore(node, next2);
          next2 = node;
        }
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/sort.js
  function sort_default(compare) {
    if (!compare) compare = ascending2;
    function compareNode(a4, b10) {
      return a4 && b10 ? compare(a4.__data__, b10.__data__) : !a4 - !b10;
    }
    for (var groups2 = this._groups, m4 = groups2.length, sortgroups = new Array(m4), j2 = 0; j2 < m4; ++j2) {
      for (var group2 = groups2[j2], n = group2.length, sortgroup = sortgroups[j2] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group2[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection(sortgroups, this._parents).order();
  }
  function ascending2(a4, b10) {
    return a4 < b10 ? -1 : a4 > b10 ? 1 : a4 >= b10 ? 0 : NaN;
  }

  // node_modules/d3-selection/src/selection/call.js
  function call_default() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  // node_modules/d3-selection/src/selection/nodes.js
  function nodes_default() {
    return Array.from(this);
  }

  // node_modules/d3-selection/src/selection/node.js
  function node_default() {
    for (var groups2 = this._groups, j2 = 0, m4 = groups2.length; j2 < m4; ++j2) {
      for (var group2 = groups2[j2], i = 0, n = group2.length; i < n; ++i) {
        var node = group2[i];
        if (node) return node;
      }
    }
    return null;
  }

  // node_modules/d3-selection/src/selection/size.js
  function size_default() {
    let size2 = 0;
    for (const node of this) ++size2;
    return size2;
  }

  // node_modules/d3-selection/src/selection/empty.js
  function empty_default() {
    return !this.node();
  }

  // node_modules/d3-selection/src/selection/each.js
  function each_default(callback) {
    for (var groups2 = this._groups, j2 = 0, m4 = groups2.length; j2 < m4; ++j2) {
      for (var group2 = groups2[j2], i = 0, n = group2.length, node; i < n; ++i) {
        if (node = group2[i]) callback.call(node, node.__data__, i, group2);
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/attr.js
  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }
  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction(name, value) {
    return function() {
      var v3 = value.apply(this, arguments);
      if (v3 == null) this.removeAttribute(name);
      else this.setAttribute(name, v3);
    };
  }
  function attrFunctionNS(fullname, value) {
    return function() {
      var v3 = value.apply(this, arguments);
      if (v3 == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v3);
    };
  }
  function attr_default(name, value) {
    var fullname = namespace_default(name);
    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
  }

  // node_modules/d3-selection/src/window.js
  function window_default(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
  }

  // node_modules/d3-selection/src/selection/style.js
  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }
  function styleFunction(name, value, priority) {
    return function() {
      var v3 = value.apply(this, arguments);
      if (v3 == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v3, priority);
    };
  }
  function style_default(name, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
  }
  function styleValue(node, name) {
    return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  // node_modules/d3-selection/src/selection/property.js
  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }
  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }
  function propertyFunction(name, value) {
    return function() {
      var v3 = value.apply(this, arguments);
      if (v3 == null) delete this[name];
      else this[name] = v3;
    };
  }
  function property_default(name, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
  }

  // node_modules/d3-selection/src/selection/classed.js
  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }
  function classList(node) {
    return node.classList || new ClassList(node);
  }
  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };
  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.add(names[i]);
  }
  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.remove(names[i]);
  }
  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }
  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }
  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }
  function classed_default(name, value) {
    var names = classArray(name + "");
    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
  }

  // node_modules/d3-selection/src/selection/text.js
  function textRemove() {
    this.textContent = "";
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var v3 = value.apply(this, arguments);
      this.textContent = v3 == null ? "" : v3;
    };
  }
  function text_default(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
  }

  // node_modules/d3-selection/src/selection/html.js
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v3 = value.apply(this, arguments);
      this.innerHTML = v3 == null ? "" : v3;
    };
  }
  function html_default(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }

  // node_modules/d3-selection/src/selection/raise.js
  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }
  function raise_default() {
    return this.each(raise);
  }

  // node_modules/d3-selection/src/selection/lower.js
  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function lower_default() {
    return this.each(lower);
  }

  // node_modules/d3-selection/src/selection/append.js
  function append_default(name) {
    var create2 = typeof name === "function" ? name : creator_default(name);
    return this.select(function() {
      return this.appendChild(create2.apply(this, arguments));
    });
  }

  // node_modules/d3-selection/src/selection/insert.js
  function constantNull() {
    return null;
  }
  function insert_default(name, before) {
    var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
    return this.select(function() {
      return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  // node_modules/d3-selection/src/selection/remove.js
  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  function remove_default() {
    return this.each(remove);
  }

  // node_modules/d3-selection/src/selection/clone.js
  function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function clone_default(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  // node_modules/d3-selection/src/selection/datum.js
  function datum_default(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }

  // node_modules/d3-selection/src/selection/on.js
  function contextListener(listener) {
    return function(event2) {
      listener.call(this, event2, this.__data__);
    };
  }
  function parseTypenames2(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return { type: t, name };
    });
  }
  function onRemove(typename) {
    return function() {
      var on2 = this.__on;
      if (!on2) return;
      for (var j2 = 0, i = -1, m4 = on2.length, o; j2 < m4; ++j2) {
        if (o = on2[j2], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
        } else {
          on2[++i] = o;
        }
      }
      if (++i) on2.length = i;
      else delete this.__on;
    };
  }
  function onAdd(typename, value, options) {
    return function() {
      var on2 = this.__on, o, listener = contextListener(value);
      if (on2) for (var j2 = 0, m4 = on2.length; j2 < m4; ++j2) {
        if ((o = on2[j2]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, options);
      o = { type: typename.type, name: typename.name, value, listener, options };
      if (!on2) this.__on = [o];
      else on2.push(o);
    };
  }
  function on_default(typename, value, options) {
    var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
    if (arguments.length < 2) {
      var on2 = this.node().__on;
      if (on2) for (var j2 = 0, m4 = on2.length, o; j2 < m4; ++j2) {
        for (i = 0, o = on2[j2]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }
    on2 = value ? onAdd : onRemove;
    for (i = 0; i < n; ++i) this.each(on2(typenames[i], value, options));
    return this;
  }

  // node_modules/d3-selection/src/selection/dispatch.js
  function dispatchEvent(node, type2, params) {
    var window2 = window_default(node), event2 = window2.CustomEvent;
    if (typeof event2 === "function") {
      event2 = new event2(type2, params);
    } else {
      event2 = window2.document.createEvent("Event");
      if (params) event2.initEvent(type2, params.bubbles, params.cancelable), event2.detail = params.detail;
      else event2.initEvent(type2, false, false);
    }
    node.dispatchEvent(event2);
  }
  function dispatchConstant(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params);
    };
  }
  function dispatchFunction(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params.apply(this, arguments));
    };
  }
  function dispatch_default2(type2, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
  }

  // node_modules/d3-selection/src/selection/iterator.js
  function* iterator_default() {
    for (var groups2 = this._groups, j2 = 0, m4 = groups2.length; j2 < m4; ++j2) {
      for (var group2 = groups2[j2], i = 0, n = group2.length, node; i < n; ++i) {
        if (node = group2[i]) yield node;
      }
    }
  }

  // node_modules/d3-selection/src/selection/index.js
  var root = [null];
  function Selection(groups2, parents) {
    this._groups = groups2;
    this._parents = parents;
  }
  function selection() {
    return new Selection([[document.documentElement]], root);
  }
  function selection_selection() {
    return this;
  }
  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: select_default,
    selectAll: selectAll_default,
    selectChild: selectChild_default,
    selectChildren: selectChildren_default,
    filter: filter_default,
    data: data_default,
    enter: enter_default,
    exit: exit_default,
    join: join_default,
    merge: merge_default,
    selection: selection_selection,
    order: order_default,
    sort: sort_default,
    call: call_default,
    nodes: nodes_default,
    node: node_default,
    size: size_default,
    empty: empty_default,
    each: each_default,
    attr: attr_default,
    style: style_default,
    property: property_default,
    classed: classed_default,
    text: text_default,
    html: html_default,
    raise: raise_default,
    lower: lower_default,
    append: append_default,
    insert: insert_default,
    remove: remove_default,
    clone: clone_default,
    datum: datum_default,
    on: on_default,
    dispatch: dispatch_default2,
    [Symbol.iterator]: iterator_default
  };
  var selection_default = selection;

  // node_modules/d3-selection/src/select.js
  function select_default2(selector) {
    return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
  }

  // node_modules/d3-selection/src/create.js
  function create_default(name) {
    return select_default2(creator_default(name).call(document.documentElement));
  }

  // node_modules/d3-selection/src/local.js
  var nextId = 0;
  function local() {
    return new Local();
  }
  function Local() {
    this._ = "@" + (++nextId).toString(36);
  }
  Local.prototype = local.prototype = {
    constructor: Local,
    get: function(node) {
      var id2 = this._;
      while (!(id2 in node)) if (!(node = node.parentNode)) return;
      return node[id2];
    },
    set: function(node, value) {
      return node[this._] = value;
    },
    remove: function(node) {
      return this._ in node && delete node[this._];
    },
    toString: function() {
      return this._;
    }
  };

  // node_modules/d3-selection/src/sourceEvent.js
  function sourceEvent_default(event2) {
    let sourceEvent;
    while (sourceEvent = event2.sourceEvent) event2 = sourceEvent;
    return event2;
  }

  // node_modules/d3-selection/src/pointer.js
  function pointer_default(event2, node) {
    event2 = sourceEvent_default(event2);
    if (node === void 0) node = event2.currentTarget;
    if (node) {
      var svg2 = node.ownerSVGElement || node;
      if (svg2.createSVGPoint) {
        var point6 = svg2.createSVGPoint();
        point6.x = event2.clientX, point6.y = event2.clientY;
        point6 = point6.matrixTransform(node.getScreenCTM().inverse());
        return [point6.x, point6.y];
      }
      if (node.getBoundingClientRect) {
        var rect = node.getBoundingClientRect();
        return [event2.clientX - rect.left - node.clientLeft, event2.clientY - rect.top - node.clientTop];
      }
    }
    return [event2.pageX, event2.pageY];
  }

  // node_modules/d3-selection/src/pointers.js
  function pointers_default(events, node) {
    if (events.target) {
      events = sourceEvent_default(events);
      if (node === void 0) node = events.currentTarget;
      events = events.touches || [events];
    }
    return Array.from(events, (event2) => pointer_default(event2, node));
  }

  // node_modules/d3-selection/src/selectAll.js
  function selectAll_default2(selector) {
    return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array2(selector)], root);
  }

  // node_modules/d3-drag/src/noevent.js
  var nonpassive2 = { passive: false };
  var nonpassivecapture = { capture: true, passive: false };
  function nopropagation(event2) {
    event2.stopImmediatePropagation();
  }
  function noevent_default(event2) {
    event2.preventDefault();
    event2.stopImmediatePropagation();
  }

  // node_modules/d3-drag/src/nodrag.js
  function nodrag_default(view) {
    var root21 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
    if ("onselectstart" in root21) {
      selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
    } else {
      root21.__noselect = root21.style.MozUserSelect;
      root21.style.MozUserSelect = "none";
    }
  }
  function yesdrag(view, noclick) {
    var root21 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
    if (noclick) {
      selection2.on("click.drag", noevent_default, nonpassivecapture);
      setTimeout(function() {
        selection2.on("click.drag", null);
      }, 0);
    }
    if ("onselectstart" in root21) {
      selection2.on("selectstart.drag", null);
    } else {
      root21.style.MozUserSelect = root21.__noselect;
      delete root21.__noselect;
    }
  }

  // node_modules/d3-drag/src/constant.js
  var constant_default2 = (x5) => () => x5;

  // node_modules/d3-drag/src/event.js
  function DragEvent(type2, {
    sourceEvent,
    subject,
    target,
    identifier,
    active,
    x: x5,
    y: y5,
    dx,
    dy,
    dispatch: dispatch2
  }) {
    Object.defineProperties(this, {
      type: { value: type2, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
      subject: { value: subject, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      identifier: { value: identifier, enumerable: true, configurable: true },
      active: { value: active, enumerable: true, configurable: true },
      x: { value: x5, enumerable: true, configurable: true },
      y: { value: y5, enumerable: true, configurable: true },
      dx: { value: dx, enumerable: true, configurable: true },
      dy: { value: dy, enumerable: true, configurable: true },
      _: { value: dispatch2 }
    });
  }
  DragEvent.prototype.on = function() {
    var value = this._.on.apply(this._, arguments);
    return value === this._ ? this : value;
  };

  // node_modules/d3-drag/src/drag.js
  function defaultFilter(event2) {
    return !event2.ctrlKey && !event2.button;
  }
  function defaultContainer() {
    return this.parentNode;
  }
  function defaultSubject(event2, d) {
    return d == null ? { x: event2.x, y: event2.y } : d;
  }
  function defaultTouchable() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function drag_default() {
    var filter3 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
    function drag(selection2) {
      selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive2).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function mousedowned(event2, d) {
      if (touchending || !filter3.call(this, event2, d)) return;
      var gesture = beforestart(this, container.call(this, event2, d), event2, d, "mouse");
      if (!gesture) return;
      select_default2(event2.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
      nodrag_default(event2.view);
      nopropagation(event2);
      mousemoving = false;
      mousedownx = event2.clientX;
      mousedowny = event2.clientY;
      gesture("start", event2);
    }
    function mousemoved(event2) {
      noevent_default(event2);
      if (!mousemoving) {
        var dx = event2.clientX - mousedownx, dy = event2.clientY - mousedowny;
        mousemoving = dx * dx + dy * dy > clickDistance2;
      }
      gestures.mouse("drag", event2);
    }
    function mouseupped(event2) {
      select_default2(event2.view).on("mousemove.drag mouseup.drag", null);
      yesdrag(event2.view, mousemoving);
      noevent_default(event2);
      gestures.mouse("end", event2);
    }
    function touchstarted(event2, d) {
      if (!filter3.call(this, event2, d)) return;
      var touches = event2.changedTouches, c6 = container.call(this, event2, d), n = touches.length, i, gesture;
      for (i = 0; i < n; ++i) {
        if (gesture = beforestart(this, c6, event2, d, touches[i].identifier, touches[i])) {
          nopropagation(event2);
          gesture("start", event2, touches[i]);
        }
      }
    }
    function touchmoved(event2) {
      var touches = event2.changedTouches, n = touches.length, i, gesture;
      for (i = 0; i < n; ++i) {
        if (gesture = gestures[touches[i].identifier]) {
          noevent_default(event2);
          gesture("drag", event2, touches[i]);
        }
      }
    }
    function touchended(event2) {
      var touches = event2.changedTouches, n = touches.length, i, gesture;
      if (touchending) clearTimeout(touchending);
      touchending = setTimeout(function() {
        touchending = null;
      }, 500);
      for (i = 0; i < n; ++i) {
        if (gesture = gestures[touches[i].identifier]) {
          nopropagation(event2);
          gesture("end", event2, touches[i]);
        }
      }
    }
    function beforestart(that, container2, event2, d, identifier, touch) {
      var dispatch2 = listeners.copy(), p = pointer_default(touch || event2, container2), dx, dy, s2;
      if ((s2 = subject.call(that, new DragEvent("beforestart", {
        sourceEvent: event2,
        target: drag,
        identifier,
        active,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch: dispatch2
      }), d)) == null) return;
      dx = s2.x - p[0] || 0;
      dy = s2.y - p[1] || 0;
      return function gesture(type2, event3, touch2) {
        var p02 = p, n;
        switch (type2) {
          case "start":
            gestures[identifier] = gesture, n = active++;
            break;
          case "end":
            delete gestures[identifier], --active;
          // falls through
          case "drag":
            p = pointer_default(touch2 || event3, container2), n = active;
            break;
        }
        dispatch2.call(
          type2,
          that,
          new DragEvent(type2, {
            sourceEvent: event3,
            subject: s2,
            target: drag,
            identifier,
            active: n,
            x: p[0] + dx,
            y: p[1] + dy,
            dx: p[0] - p02[0],
            dy: p[1] - p02[1],
            dispatch: dispatch2
          }),
          d
        );
      };
    }
    drag.filter = function(_25) {
      return arguments.length ? (filter3 = typeof _25 === "function" ? _25 : constant_default2(!!_25), drag) : filter3;
    };
    drag.container = function(_25) {
      return arguments.length ? (container = typeof _25 === "function" ? _25 : constant_default2(_25), drag) : container;
    };
    drag.subject = function(_25) {
      return arguments.length ? (subject = typeof _25 === "function" ? _25 : constant_default2(_25), drag) : subject;
    };
    drag.touchable = function(_25) {
      return arguments.length ? (touchable = typeof _25 === "function" ? _25 : constant_default2(!!_25), drag) : touchable;
    };
    drag.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? drag : value;
    };
    drag.clickDistance = function(_25) {
      return arguments.length ? (clickDistance2 = (_25 = +_25) * _25, drag) : Math.sqrt(clickDistance2);
    };
    return drag;
  }

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m4, l2;
    format2 = (format2 + "").trim().toLowerCase();
    return (m4 = reHex.exec(format2)) ? (l2 = m4[1].length, m4 = parseInt(m4[1], 16), l2 === 6 ? rgbn(m4) : l2 === 3 ? new Rgb(m4 >> 8 & 15 | m4 >> 4 & 240, m4 >> 4 & 15 | m4 & 240, (m4 & 15) << 4 | m4 & 15, 1) : l2 === 8 ? rgba(m4 >> 24 & 255, m4 >> 16 & 255, m4 >> 8 & 255, (m4 & 255) / 255) : l2 === 4 ? rgba(m4 >> 12 & 15 | m4 >> 8 & 240, m4 >> 8 & 15 | m4 >> 4 & 240, m4 >> 4 & 15 | m4 & 240, ((m4 & 15) << 4 | m4 & 15) / 255) : null) : (m4 = reRgbInteger.exec(format2)) ? new Rgb(m4[1], m4[2], m4[3], 1) : (m4 = reRgbPercent.exec(format2)) ? new Rgb(m4[1] * 255 / 100, m4[2] * 255 / 100, m4[3] * 255 / 100, 1) : (m4 = reRgbaInteger.exec(format2)) ? rgba(m4[1], m4[2], m4[3], m4[4]) : (m4 = reRgbaPercent.exec(format2)) ? rgba(m4[1] * 255 / 100, m4[2] * 255 / 100, m4[3] * 255 / 100, m4[4]) : (m4 = reHslPercent.exec(format2)) ? hsla(m4[1], m4[2] / 100, m4[3] / 100, 1) : (m4 = reHslaPercent.exec(format2)) ? hsla(m4[1], m4[2] / 100, m4[3] / 100, m4[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba(r, g, b10, a4) {
    if (a4 <= 0) r = g = b10 = NaN;
    return new Rgb(r, g, b10, a4);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b10, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b10, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b10, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b10;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend(Color, {
    brighter(k3) {
      k3 = k3 == null ? brighter : Math.pow(brighter, k3);
      return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
    },
    darker(k3) {
      k3 = k3 == null ? darker : Math.pow(darker, k3);
      return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a4 = clampa(this.opacity);
    return `${a4 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a4 === 1 ? ")" : `, ${a4})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h2, s2, l2, a4) {
    if (a4 <= 0) h2 = s2 = l2 = NaN;
    else if (l2 <= 0 || l2 >= 1) h2 = s2 = NaN;
    else if (s2 <= 0) h2 = NaN;
    return new Hsl(h2, s2, l2, a4);
  }
  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl();
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b10 = o.b / 255, min4 = Math.min(r, g, b10), max5 = Math.max(r, g, b10), h2 = NaN, s2 = max5 - min4, l2 = (max5 + min4) / 2;
    if (s2) {
      if (r === max5) h2 = (g - b10) / s2 + (g < b10) * 6;
      else if (g === max5) h2 = (b10 - r) / s2 + 2;
      else h2 = (r - g) / s2 + 4;
      s2 /= l2 < 0.5 ? max5 + min4 : 2 - max5 - min4;
      h2 *= 60;
    } else {
      s2 = l2 > 0 && l2 < 1 ? 0 : h2;
    }
    return new Hsl(h2, s2, l2, o.opacity);
  }
  function hsl(h2, s2, l2, opacity) {
    return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
  }
  function Hsl(h2, s2, l2, opacity) {
    this.h = +h2;
    this.s = +s2;
    this.l = +l2;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend(Color, {
    brighter(k3) {
      k3 = k3 == null ? brighter : Math.pow(brighter, k3);
      return new Hsl(this.h, this.s, this.l * k3, this.opacity);
    },
    darker(k3) {
      k3 = k3 == null ? darker : Math.pow(darker, k3);
      return new Hsl(this.h, this.s, this.l * k3, this.opacity);
    },
    rgb() {
      var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m22 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m22;
      return new Rgb(
        hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m22),
        hsl2rgb(h2, m1, m22),
        hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m22),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a4 = clampa(this.opacity);
      return `${a4 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a4 === 1 ? ")" : `, ${a4})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h2, m1, m22) {
    return (h2 < 60 ? m1 + (m22 - m1) * h2 / 60 : h2 < 180 ? m22 : h2 < 240 ? m1 + (m22 - m1) * (240 - h2) / 60 : m1) * 255;
  }

  // node_modules/d3-color/src/math.js
  var radians = Math.PI / 180;
  var degrees = 180 / Math.PI;

  // node_modules/d3-color/src/lab.js
  var K = 18;
  var Xn = 0.96422;
  var Yn = 1;
  var Zn = 0.82521;
  var t0 = 4 / 29;
  var t1 = 6 / 29;
  var t2 = 3 * t1 * t1;
  var t3 = t1 * t1 * t1;
  function labConvert(o) {
    if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
    if (o instanceof Hcl) return hcl2lab(o);
    if (!(o instanceof Rgb)) o = rgbConvert(o);
    var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b10 = rgb2lrgb(o.b), y5 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b10) / Yn), x5, z2;
    if (r === g && g === b10) x5 = z2 = y5;
    else {
      x5 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b10) / Xn);
      z2 = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b10) / Zn);
    }
    return new Lab(116 * y5 - 16, 500 * (x5 - y5), 200 * (y5 - z2), o.opacity);
  }
  function gray(l2, opacity) {
    return new Lab(l2, 0, 0, opacity == null ? 1 : opacity);
  }
  function lab(l2, a4, b10, opacity) {
    return arguments.length === 1 ? labConvert(l2) : new Lab(l2, a4, b10, opacity == null ? 1 : opacity);
  }
  function Lab(l2, a4, b10, opacity) {
    this.l = +l2;
    this.a = +a4;
    this.b = +b10;
    this.opacity = +opacity;
  }
  define_default(Lab, lab, extend(Color, {
    brighter(k3) {
      return new Lab(this.l + K * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
    },
    darker(k3) {
      return new Lab(this.l - K * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
    },
    rgb() {
      var y5 = (this.l + 16) / 116, x5 = isNaN(this.a) ? y5 : y5 + this.a / 500, z2 = isNaN(this.b) ? y5 : y5 - this.b / 200;
      x5 = Xn * lab2xyz(x5);
      y5 = Yn * lab2xyz(y5);
      z2 = Zn * lab2xyz(z2);
      return new Rgb(
        lrgb2rgb(3.1338561 * x5 - 1.6168667 * y5 - 0.4906146 * z2),
        lrgb2rgb(-0.9787684 * x5 + 1.9161415 * y5 + 0.033454 * z2),
        lrgb2rgb(0.0719453 * x5 - 0.2289914 * y5 + 1.4052427 * z2),
        this.opacity
      );
    }
  }));
  function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
  }
  function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
  }
  function lrgb2rgb(x5) {
    return 255 * (x5 <= 31308e-7 ? 12.92 * x5 : 1.055 * Math.pow(x5, 1 / 2.4) - 0.055);
  }
  function rgb2lrgb(x5) {
    return (x5 /= 255) <= 0.04045 ? x5 / 12.92 : Math.pow((x5 + 0.055) / 1.055, 2.4);
  }
  function hclConvert(o) {
    if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
    if (!(o instanceof Lab)) o = labConvert(o);
    if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
    var h2 = Math.atan2(o.b, o.a) * degrees;
    return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
  }
  function lch(l2, c6, h2, opacity) {
    return arguments.length === 1 ? hclConvert(l2) : new Hcl(h2, c6, l2, opacity == null ? 1 : opacity);
  }
  function hcl(h2, c6, l2, opacity) {
    return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c6, l2, opacity == null ? 1 : opacity);
  }
  function Hcl(h2, c6, l2, opacity) {
    this.h = +h2;
    this.c = +c6;
    this.l = +l2;
    this.opacity = +opacity;
  }
  function hcl2lab(o) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h2 = o.h * radians;
    return new Lab(o.l, Math.cos(h2) * o.c, Math.sin(h2) * o.c, o.opacity);
  }
  define_default(Hcl, hcl, extend(Color, {
    brighter(k3) {
      return new Hcl(this.h, this.c, this.l + K * (k3 == null ? 1 : k3), this.opacity);
    },
    darker(k3) {
      return new Hcl(this.h, this.c, this.l - K * (k3 == null ? 1 : k3), this.opacity);
    },
    rgb() {
      return hcl2lab(this).rgb();
    }
  }));

  // node_modules/d3-color/src/cubehelix.js
  var A = -0.14861;
  var B = 1.78277;
  var C = -0.29227;
  var D = -0.90649;
  var E = 1.97294;
  var ED = E * D;
  var EB = E * B;
  var BC_DA = B * C - D * A;
  function cubehelixConvert(o) {
    if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Rgb)) o = rgbConvert(o);
    var r = o.r / 255, g = o.g / 255, b10 = o.b / 255, l2 = (BC_DA * b10 + ED * r - EB * g) / (BC_DA + ED - EB), bl = b10 - l2, k3 = (E * (g - l2) - C * bl) / D, s2 = Math.sqrt(k3 * k3 + bl * bl) / (E * l2 * (1 - l2)), h2 = s2 ? Math.atan2(k3, bl) * degrees - 120 : NaN;
    return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s2, l2, o.opacity);
  }
  function cubehelix(h2, s2, l2, opacity) {
    return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s2, l2, opacity == null ? 1 : opacity);
  }
  function Cubehelix(h2, s2, l2, opacity) {
    this.h = +h2;
    this.s = +s2;
    this.l = +l2;
    this.opacity = +opacity;
  }
  define_default(Cubehelix, cubehelix, extend(Color, {
    brighter(k3) {
      k3 = k3 == null ? brighter : Math.pow(brighter, k3);
      return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
    },
    darker(k3) {
      k3 = k3 == null ? darker : Math.pow(darker, k3);
      return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
    },
    rgb() {
      var h2 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l2 = +this.l, a4 = isNaN(this.s) ? 0 : this.s * l2 * (1 - l2), cosh2 = Math.cos(h2), sinh2 = Math.sin(h2);
      return new Rgb(
        255 * (l2 + a4 * (A * cosh2 + B * sinh2)),
        255 * (l2 + a4 * (C * cosh2 + D * sinh2)),
        255 * (l2 + a4 * (E * cosh2)),
        this.opacity
      );
    }
  }));

  // node_modules/d3-interpolate/src/basis.js
  function basis(t13, v0, v1, v22, v3) {
    var t22 = t13 * t13, t32 = t22 * t13;
    return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v22 + t32 * v3) / 6;
  }
  function basis_default(values2) {
    var n = values2.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v22 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v22, v3 = i < n - 1 ? values2[i + 2] : 2 * v22 - v1;
      return basis((t - i / n) * n, v0, v1, v22, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values2) {
    var n = values2.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v22 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v22, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  var constant_default3 = (x5) => () => x5;

  // node_modules/d3-interpolate/src/color.js
  function linear(a4, d) {
    return function(t) {
      return a4 + t * d;
    };
  }
  function exponential(a4, b10, y5) {
    return a4 = Math.pow(a4, y5), b10 = Math.pow(b10, y5) - a4, y5 = 1 / y5, function(t) {
      return Math.pow(a4 + t * b10, y5);
    };
  }
  function hue(a4, b10) {
    var d = b10 - a4;
    return d ? linear(a4, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a4) ? b10 : a4);
  }
  function gamma(y5) {
    return (y5 = +y5) === 1 ? nogamma : function(a4, b10) {
      return b10 - a4 ? exponential(a4, b10, y5) : constant_default3(isNaN(a4) ? b10 : a4);
    };
  }
  function nogamma(a4, b10) {
    var d = b10 - a4;
    return d ? linear(a4, d) : constant_default3(isNaN(a4) ? b10 : a4);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y5) {
    var color2 = gamma(y5);
    function rgb2(start2, end) {
      var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b10 = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.r = r(t);
        start2.g = g(t);
        start2.b = b10(t);
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length, r = new Array(n), g = new Array(n), b10 = new Array(n), i, color2;
      for (i = 0; i < n; ++i) {
        color2 = rgb(colors[i]);
        r[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b10[i] = color2.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b10 = spline(b10);
      color2.opacity = 1;
      return function(t) {
        color2.r = r(t);
        color2.g = g(t);
        color2.b = b10(t);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/numberArray.js
  function numberArray_default(a4, b10) {
    if (!b10) b10 = [];
    var n = a4 ? Math.min(b10.length, a4.length) : 0, c6 = b10.slice(), i;
    return function(t) {
      for (i = 0; i < n; ++i) c6[i] = a4[i] * (1 - t) + b10[i] * t;
      return c6;
    };
  }
  function isNumberArray(x5) {
    return ArrayBuffer.isView(x5) && !(x5 instanceof DataView);
  }

  // node_modules/d3-interpolate/src/array.js
  function array_default(a4, b10) {
    return (isNumberArray(b10) ? numberArray_default : genericArray)(a4, b10);
  }
  function genericArray(a4, b10) {
    var nb = b10 ? b10.length : 0, na = a4 ? Math.min(nb, a4.length) : 0, x5 = new Array(na), c6 = new Array(nb), i;
    for (i = 0; i < na; ++i) x5[i] = value_default(a4[i], b10[i]);
    for (; i < nb; ++i) c6[i] = b10[i];
    return function(t) {
      for (i = 0; i < na; ++i) c6[i] = x5[i](t);
      return c6;
    };
  }

  // node_modules/d3-interpolate/src/date.js
  function date_default(a4, b10) {
    var d = /* @__PURE__ */ new Date();
    return a4 = +a4, b10 = +b10, function(t) {
      return d.setTime(a4 * (1 - t) + b10 * t), d;
    };
  }

  // node_modules/d3-interpolate/src/number.js
  function number_default(a4, b10) {
    return a4 = +a4, b10 = +b10, function(t) {
      return a4 * (1 - t) + b10 * t;
    };
  }

  // node_modules/d3-interpolate/src/object.js
  function object_default(a4, b10) {
    var i = {}, c6 = {}, k3;
    if (a4 === null || typeof a4 !== "object") a4 = {};
    if (b10 === null || typeof b10 !== "object") b10 = {};
    for (k3 in b10) {
      if (k3 in a4) {
        i[k3] = value_default(a4[k3], b10[k3]);
      } else {
        c6[k3] = b10[k3];
      }
    }
    return function(t) {
      for (k3 in i) c6[k3] = i[k3](t);
      return c6;
    };
  }

  // node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero2(b10) {
    return function() {
      return b10;
    };
  }
  function one(b10) {
    return function(t) {
      return b10(t) + "";
    };
  }
  function string_default(a4, b10) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q2 = [];
    a4 = a4 + "", b10 = b10 + "";
    while ((am = reA.exec(a4)) && (bm = reB.exec(b10))) {
      if ((bs = bm.index) > bi) {
        bs = b10.slice(bi, bs);
        if (s2[i]) s2[i] += bs;
        else s2[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s2[i]) s2[i] += bm;
        else s2[++i] = bm;
      } else {
        s2[++i] = null;
        q2.push({ i, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b10.length) {
      bs = b10.slice(bi);
      if (s2[i]) s2[i] += bs;
      else s2[++i] = bs;
    }
    return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero2(b10) : (b10 = q2.length, function(t) {
      for (var i2 = 0, o; i2 < b10; ++i2) s2[(o = q2[i2]).i] = o.x(t);
      return s2.join("");
    });
  }

  // node_modules/d3-interpolate/src/value.js
  function value_default(a4, b10) {
    var t = typeof b10, c6;
    return b10 == null || t === "boolean" ? constant_default3(b10) : (t === "number" ? number_default : t === "string" ? (c6 = color(b10)) ? (b10 = c6, rgb_default) : string_default : b10 instanceof color ? rgb_default : b10 instanceof Date ? date_default : isNumberArray(b10) ? numberArray_default : Array.isArray(b10) ? genericArray : typeof b10.valueOf !== "function" && typeof b10.toString !== "function" || isNaN(b10) ? object_default : number_default)(a4, b10);
  }

  // node_modules/d3-interpolate/src/discrete.js
  function discrete_default(range6) {
    var n = range6.length;
    return function(t) {
      return range6[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }

  // node_modules/d3-interpolate/src/hue.js
  function hue_default(a4, b10) {
    var i = hue(+a4, +b10);
    return function(t) {
      var x5 = i(t);
      return x5 - 360 * Math.floor(x5 / 360);
    };
  }

  // node_modules/d3-interpolate/src/round.js
  function round_default(a4, b10) {
    return a4 = +a4, b10 = +b10, function(t) {
      return Math.round(a4 * (1 - t) + b10 * t);
    };
  }

  // node_modules/d3-interpolate/src/transform/decompose.js
  var degrees2 = 180 / Math.PI;
  var identity2 = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose_default(a4, b10, c6, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a4 * a4 + b10 * b10)) a4 /= scaleX, b10 /= scaleX;
    if (skewX = a4 * c6 + b10 * d) c6 -= a4 * skewX, d -= b10 * skewX;
    if (scaleY = Math.sqrt(c6 * c6 + d * d)) c6 /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a4 * d < b10 * c6) a4 = -a4, b10 = -b10, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b10, a4) * degrees2,
      skewX: Math.atan(skewX) * degrees2,
      scaleX,
      scaleY
    };
  }

  // node_modules/d3-interpolate/src/transform/parse.js
  var svgNode;
  function parseCss(value) {
    const m4 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m4.isIdentity ? identity2 : decompose_default(m4.a, m4.b, m4.c, m4.d, m4.e, m4.f);
  }
  function parseSvg(value) {
    if (value == null) return identity2;
    if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate())) return identity2;
    value = value.matrix;
    return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  // node_modules/d3-interpolate/src/transform/index.js
  function interpolateTransform(parse, pxComma, pxParen, degParen) {
    function pop2(s2) {
      return s2.length ? s2.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s2, q2) {
      if (xa !== xb || ya !== yb) {
        var i = s2.push("translate(", null, pxComma, null, pxParen);
        q2.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
      } else if (xb || yb) {
        s2.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a4, b10, s2, q2) {
      if (a4 !== b10) {
        if (a4 - b10 > 180) b10 += 360;
        else if (b10 - a4 > 180) a4 += 360;
        q2.push({ i: s2.push(pop2(s2) + "rotate(", null, degParen) - 2, x: number_default(a4, b10) });
      } else if (b10) {
        s2.push(pop2(s2) + "rotate(" + b10 + degParen);
      }
    }
    function skewX(a4, b10, s2, q2) {
      if (a4 !== b10) {
        q2.push({ i: s2.push(pop2(s2) + "skewX(", null, degParen) - 2, x: number_default(a4, b10) });
      } else if (b10) {
        s2.push(pop2(s2) + "skewX(" + b10 + degParen);
      }
    }
    function scale2(xa, ya, xb, yb, s2, q2) {
      if (xa !== xb || ya !== yb) {
        var i = s2.push(pop2(s2) + "scale(", null, ",", null, ")");
        q2.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s2.push(pop2(s2) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a4, b10) {
      var s2 = [], q2 = [];
      a4 = parse(a4), b10 = parse(b10);
      translate(a4.translateX, a4.translateY, b10.translateX, b10.translateY, s2, q2);
      rotate(a4.rotate, b10.rotate, s2, q2);
      skewX(a4.skewX, b10.skewX, s2, q2);
      scale2(a4.scaleX, a4.scaleY, b10.scaleX, b10.scaleY, s2, q2);
      a4 = b10 = null;
      return function(t) {
        var i = -1, n = q2.length, o;
        while (++i < n) s2[(o = q2[i]).i] = o.x(t);
        return s2.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  // node_modules/d3-interpolate/src/zoom.js
  var epsilon2 = 1e-12;
  function cosh(x5) {
    return ((x5 = Math.exp(x5)) + 1 / x5) / 2;
  }
  function sinh(x5) {
    return ((x5 = Math.exp(x5)) - 1 / x5) / 2;
  }
  function tanh(x5) {
    return ((x5 = Math.exp(2 * x5)) - 1) / (x5 + 1);
  }
  var zoom_default = function zoomRho(rho, rho2, rho4) {
    function zoom(p02, p1) {
      var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S2;
      if (d2 < epsilon2) {
        S2 = Math.log(w1 / w0) / rho;
        i = function(t) {
          return [
            ux0 + t * dx,
            uy0 + t * dy,
            w0 * Math.exp(rho * t * S2)
          ];
        };
      } else {
        var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
        S2 = (r1 - r0) / rho;
        i = function(t) {
          var s2 = t * S2, coshr0 = cosh(r0), u5 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
          return [
            ux0 + u5 * dx,
            uy0 + u5 * dy,
            w0 * coshr0 / cosh(rho * s2 + r0)
          ];
        };
      }
      i.duration = S2 * 1e3 * rho / Math.SQRT2;
      return i;
    }
    zoom.rho = function(_25) {
      var _1 = Math.max(1e-3, +_25), _26 = _1 * _1, _42 = _26 * _26;
      return zoomRho(_1, _26, _42);
    };
    return zoom;
  }(Math.SQRT2, 2, 4);

  // node_modules/d3-interpolate/src/hsl.js
  function hsl2(hue2) {
    return function(start2, end) {
      var h2 = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s2 = nogamma(start2.s, end.s), l2 = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.h = h2(t);
        start2.s = s2(t);
        start2.l = l2(t);
        start2.opacity = opacity(t);
        return start2 + "";
      };
    };
  }
  var hsl_default = hsl2(hue);
  var hslLong = hsl2(nogamma);

  // node_modules/d3-interpolate/src/lab.js
  function lab2(start2, end) {
    var l2 = nogamma((start2 = lab(start2)).l, (end = lab(end)).l), a4 = nogamma(start2.a, end.a), b10 = nogamma(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.l = l2(t);
      start2.a = a4(t);
      start2.b = b10(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }

  // node_modules/d3-interpolate/src/hcl.js
  function hcl2(hue2) {
    return function(start2, end) {
      var h2 = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c6 = nogamma(start2.c, end.c), l2 = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.h = h2(t);
        start2.c = c6(t);
        start2.l = l2(t);
        start2.opacity = opacity(t);
        return start2 + "";
      };
    };
  }
  var hcl_default = hcl2(hue);
  var hclLong = hcl2(nogamma);

  // node_modules/d3-interpolate/src/cubehelix.js
  function cubehelix2(hue2) {
    return function cubehelixGamma(y5) {
      y5 = +y5;
      function cubehelix3(start2, end) {
        var h2 = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s2 = nogamma(start2.s, end.s), l2 = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
        return function(t) {
          start2.h = h2(t);
          start2.s = s2(t);
          start2.l = l2(Math.pow(t, y5));
          start2.opacity = opacity(t);
          return start2 + "";
        };
      }
      cubehelix3.gamma = cubehelixGamma;
      return cubehelix3;
    }(1);
  }
  var cubehelix_default = cubehelix2(hue);
  var cubehelixLong = cubehelix2(nogamma);

  // node_modules/d3-interpolate/src/piecewise.js
  function piecewise(interpolate, values2) {
    if (values2 === void 0) values2 = interpolate, interpolate = value_default;
    var i = 0, n = values2.length - 1, v3 = values2[0], I2 = new Array(n < 0 ? 0 : n);
    while (i < n) I2[i] = interpolate(v3, v3 = values2[++i]);
    return function(t) {
      var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
      return I2[i2](t - i2);
    };
  }

  // node_modules/d3-interpolate/src/quantize.js
  function quantize_default(interpolator, n) {
    var samples = new Array(n);
    for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
    return samples;
  }

  // node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time2) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail) taskTail._next = this;
        else taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time2;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time2) {
    var t = new Timer();
    t.restart(callback, delay, time2);
    return t;
  }
  function timerFlush() {
    now();
    ++frame;
    var t = taskHead, e;
    while (t) {
      if ((e = clockNow - t._time) >= 0) t._call.call(void 0, e);
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now2 = clock.now(), delay = now2 - clockLast;
    if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
  }
  function nap() {
    var t03, t13 = taskHead, t22, time2 = Infinity;
    while (t13) {
      if (t13._call) {
        if (time2 > t13._time) time2 = t13._time;
        t03 = t13, t13 = t13._next;
      } else {
        t22 = t13._next, t13._next = null;
        t13 = t03 ? t03._next = t22 : taskHead = t22;
      }
    }
    taskTail = t03;
    sleep(time2);
  }
  function sleep(time2) {
    if (frame) return;
    if (timeout) timeout = clearTimeout(timeout);
    var delay = time2 - clockNow;
    if (delay > 24) {
      if (time2 < Infinity) timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
      if (interval) interval = clearInterval(interval);
    } else {
      if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/d3-timer/src/timeout.js
  function timeout_default(callback, delay, time2) {
    var t = new Timer();
    delay = delay == null ? 0 : +delay;
    t.restart((elapsed) => {
      t.stop();
      callback(elapsed + delay);
    }, delay, time2);
    return t;
  }

  // node_modules/d3-timer/src/interval.js
  function interval_default(callback, delay, time2) {
    var t = new Timer(), total = delay;
    if (delay == null) return t.restart(callback, delay, time2), t;
    t._restart = t.restart;
    t.restart = function(callback2, delay2, time3) {
      delay2 = +delay2, time3 = time3 == null ? now() : +time3;
      t._restart(function tick2(elapsed) {
        elapsed += total;
        t._restart(tick2, total += delay2, time3);
        callback2(elapsed);
      }, delay2, time3);
    };
    t.restart(callback, delay, time2);
    return t;
  }

  // node_modules/d3-transition/src/transition/schedule.js
  var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
  var emptyTween = [];
  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;
  function schedule_default(node, name, id2, index4, group2, timing) {
    var schedules = node.__transition;
    if (!schedules) node.__transition = {};
    else if (id2 in schedules) return;
    create(node, id2, {
      name,
      index: index4,
      // For context during callback.
      group: group2,
      // For context during callback.
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }
  function init2(node, id2) {
    var schedule = get4(node, id2);
    if (schedule.state > CREATED) throw new Error("too late; already scheduled");
    return schedule;
  }
  function set4(node, id2) {
    var schedule = get4(node, id2);
    if (schedule.state > STARTED) throw new Error("too late; already running");
    return schedule;
  }
  function get4(node, id2) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
    return schedule;
  }
  function create(node, id2, self3) {
    var schedules = node.__transition, tween;
    schedules[id2] = self3;
    self3.timer = timer(schedule, 0, self3.time);
    function schedule(elapsed) {
      self3.state = SCHEDULED;
      self3.timer.restart(start2, self3.delay, self3.time);
      if (self3.delay <= elapsed) start2(elapsed - self3.delay);
    }
    function start2(elapsed) {
      var i, j2, n, o;
      if (self3.state !== SCHEDULED) return stop();
      for (i in schedules) {
        o = schedules[i];
        if (o.name !== self3.name) continue;
        if (o.state === STARTED) return timeout_default(start2);
        if (o.state === RUNNING) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("interrupt", node, node.__data__, o.index, o.group);
          delete schedules[i];
        } else if (+i < id2) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("cancel", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }
      }
      timeout_default(function() {
        if (self3.state === STARTED) {
          self3.state = RUNNING;
          self3.timer.restart(tick2, self3.delay, self3.time);
          tick2(elapsed);
        }
      });
      self3.state = STARTING;
      self3.on.call("start", node, node.__data__, self3.index, self3.group);
      if (self3.state !== STARTING) return;
      self3.state = STARTED;
      tween = new Array(n = self3.tween.length);
      for (i = 0, j2 = -1; i < n; ++i) {
        if (o = self3.tween[i].value.call(node, node.__data__, self3.index, self3.group)) {
          tween[++j2] = o;
        }
      }
      tween.length = j2 + 1;
    }
    function tick2(elapsed) {
      var t = elapsed < self3.duration ? self3.ease.call(null, elapsed / self3.duration) : (self3.timer.restart(stop), self3.state = ENDING, 1), i = -1, n = tween.length;
      while (++i < n) {
        tween[i].call(node, t);
      }
      if (self3.state === ENDING) {
        self3.on.call("end", node, node.__data__, self3.index, self3.group);
        stop();
      }
    }
    function stop() {
      self3.state = ENDED;
      self3.timer.stop();
      delete schedules[id2];
      for (var i in schedules) return;
      delete node.__transition;
    }
  }

  // node_modules/d3-transition/src/interrupt.js
  function interrupt_default(node, name) {
    var schedules = node.__transition, schedule, active, empty4 = true, i;
    if (!schedules) return;
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).name !== name) {
        empty4 = false;
        continue;
      }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
      delete schedules[i];
    }
    if (empty4) delete node.__transition;
  }

  // node_modules/d3-transition/src/selection/interrupt.js
  function interrupt_default2(name) {
    return this.each(function() {
      interrupt_default(this, name);
    });
  }

  // node_modules/d3-transition/src/transition/tween.js
  function tweenRemove(id2, name) {
    var tween0, tween1;
    return function() {
      var schedule = set4(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1 = tween1.slice();
            tween1.splice(i, 1);
            break;
          }
        }
      }
      schedule.tween = tween1;
    };
  }
  function tweenFunction(id2, name, value) {
    var tween0, tween1;
    if (typeof value !== "function") throw new Error();
    return function() {
      var schedule = set4(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1[i] = t;
            break;
          }
        }
        if (i === n) tween1.push(t);
      }
      schedule.tween = tween1;
    };
  }
  function tween_default(name, value) {
    var id2 = this._id;
    name += "";
    if (arguments.length < 2) {
      var tween = get4(this.node(), id2).tween;
      for (var i = 0, n = tween.length, t; i < n; ++i) {
        if ((t = tween[i]).name === name) {
          return t.value;
        }
      }
      return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
  }
  function tweenValue(transition3, name, value) {
    var id2 = transition3._id;
    transition3.each(function() {
      var schedule = set4(this, id2);
      (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
    });
    return function(node) {
      return get4(node, id2).value[name];
    };
  }

  // node_modules/d3-transition/src/transition/interpolate.js
  function interpolate_default(a4, b10) {
    var c6;
    return (typeof b10 === "number" ? number_default : b10 instanceof color ? rgb_default : (c6 = color(b10)) ? (b10 = c6, rgb_default) : string_default)(a4, b10);
  }

  // node_modules/d3-transition/src/transition/attr.js
  function attrRemove2(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS2(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant2(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttribute(name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrConstantNS2(fullname, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrFunction2(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttribute(name);
      string0 = this.getAttribute(name);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attrFunctionNS2(fullname, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attr_default2(name, value) {
    var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
    return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
  }

  // node_modules/d3-transition/src/transition/attrTween.js
  function attrInterpolate(name, i) {
    return function(t) {
      this.setAttribute(name, i.call(this, t));
    };
  }
  function attrInterpolateNS(fullname, i) {
    return function(t) {
      this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
    };
  }
  function attrTweenNS(fullname, value) {
    var t03, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t03 = (i0 = i) && attrInterpolateNS(fullname, i);
      return t03;
    }
    tween._value = value;
    return tween;
  }
  function attrTween(name, value) {
    var t03, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t03 = (i0 = i) && attrInterpolate(name, i);
      return t03;
    }
    tween._value = value;
    return tween;
  }
  function attrTween_default(name, value) {
    var key = "attr." + name;
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    var fullname = namespace_default(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }

  // node_modules/d3-transition/src/transition/delay.js
  function delayFunction(id2, value) {
    return function() {
      init2(this, id2).delay = +value.apply(this, arguments);
    };
  }
  function delayConstant(id2, value) {
    return value = +value, function() {
      init2(this, id2).delay = value;
    };
  }
  function delay_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get4(this.node(), id2).delay;
  }

  // node_modules/d3-transition/src/transition/duration.js
  function durationFunction(id2, value) {
    return function() {
      set4(this, id2).duration = +value.apply(this, arguments);
    };
  }
  function durationConstant(id2, value) {
    return value = +value, function() {
      set4(this, id2).duration = value;
    };
  }
  function duration_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get4(this.node(), id2).duration;
  }

  // node_modules/d3-transition/src/transition/ease.js
  function easeConstant(id2, value) {
    if (typeof value !== "function") throw new Error();
    return function() {
      set4(this, id2).ease = value;
    };
  }
  function ease_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each(easeConstant(id2, value)) : get4(this.node(), id2).ease;
  }

  // node_modules/d3-transition/src/transition/easeVarying.js
  function easeVarying(id2, value) {
    return function() {
      var v3 = value.apply(this, arguments);
      if (typeof v3 !== "function") throw new Error();
      set4(this, id2).ease = v3;
    };
  }
  function easeVarying_default(value) {
    if (typeof value !== "function") throw new Error();
    return this.each(easeVarying(this._id, value));
  }

  // node_modules/d3-transition/src/transition/filter.js
  function filter_default2(match2) {
    if (typeof match2 !== "function") match2 = matcher_default(match2);
    for (var groups2 = this._groups, m4 = groups2.length, subgroups = new Array(m4), j2 = 0; j2 < m4; ++j2) {
      for (var group2 = groups2[j2], n = group2.length, subgroup = subgroups[j2] = [], node, i = 0; i < n; ++i) {
        if ((node = group2[i]) && match2.call(node, node.__data__, i, group2)) {
          subgroup.push(node);
        }
      }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/merge.js
  function merge_default2(transition3) {
    if (transition3._id !== this._id) throw new Error();
    for (var groups0 = this._groups, groups1 = transition3._groups, m0 = groups0.length, m1 = groups1.length, m4 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m4; ++j2) {
      for (var group0 = groups0[j2], group1 = groups1[j2], n = group0.length, merge2 = merges[j2] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge2[i] = node;
        }
      }
    }
    for (; j2 < m0; ++j2) {
      merges[j2] = groups0[j2];
    }
    return new Transition(merges, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/on.js
  function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function(t) {
      var i = t.indexOf(".");
      if (i >= 0) t = t.slice(0, i);
      return !t || t === "start";
    });
  }
  function onFunction(id2, name, listener) {
    var on0, on1, sit = start(name) ? init2 : set4;
    return function() {
      var schedule = sit(this, id2), on2 = schedule.on;
      if (on2 !== on0) (on1 = (on0 = on2).copy()).on(name, listener);
      schedule.on = on1;
    };
  }
  function on_default2(name, listener) {
    var id2 = this._id;
    return arguments.length < 2 ? get4(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
  }

  // node_modules/d3-transition/src/transition/remove.js
  function removeFunction(id2) {
    return function() {
      var parent = this.parentNode;
      for (var i in this.__transition) if (+i !== id2) return;
      if (parent) parent.removeChild(this);
    };
  }
  function remove_default2() {
    return this.on("end.remove", removeFunction(this._id));
  }

  // node_modules/d3-transition/src/transition/select.js
  function select_default3(select) {
    var name = this._name, id2 = this._id;
    if (typeof select !== "function") select = selector_default(select);
    for (var groups2 = this._groups, m4 = groups2.length, subgroups = new Array(m4), j2 = 0; j2 < m4; ++j2) {
      for (var group2 = groups2[j2], n = group2.length, subgroup = subgroups[j2] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group2[i]) && (subnode = select.call(node, node.__data__, i, group2))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
          schedule_default(subgroup[i], name, id2, i, subgroup, get4(node, id2));
        }
      }
    }
    return new Transition(subgroups, this._parents, name, id2);
  }

  // node_modules/d3-transition/src/transition/selectAll.js
  function selectAll_default3(select) {
    var name = this._name, id2 = this._id;
    if (typeof select !== "function") select = selectorAll_default(select);
    for (var groups2 = this._groups, m4 = groups2.length, subgroups = [], parents = [], j2 = 0; j2 < m4; ++j2) {
      for (var group2 = groups2[j2], n = group2.length, node, i = 0; i < n; ++i) {
        if (node = group2[i]) {
          for (var children2 = select.call(node, node.__data__, i, group2), child2, inherit2 = get4(node, id2), k3 = 0, l2 = children2.length; k3 < l2; ++k3) {
            if (child2 = children2[k3]) {
              schedule_default(child2, name, id2, k3, children2, inherit2);
            }
          }
          subgroups.push(children2);
          parents.push(node);
        }
      }
    }
    return new Transition(subgroups, parents, name, id2);
  }

  // node_modules/d3-transition/src/transition/selection.js
  var Selection2 = selection_default.prototype.constructor;
  function selection_default2() {
    return new Selection2(this._groups, this._parents);
  }

  // node_modules/d3-transition/src/transition/style.js
  function styleNull(name, interpolate) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
  }
  function styleRemove2(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant2(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = styleValue(this, name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function styleFunction2(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
      if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function styleMaybeRemove(id2, name) {
    var on0, on1, listener0, key = "style." + name, event2 = "end." + key, remove2;
    return function() {
      var schedule = set4(this, id2), on2 = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
      if (on2 !== on0 || listener0 !== listener) (on1 = (on0 = on2).copy()).on(event2, listener0 = listener);
      schedule.on = on1;
    };
  }
  function style_default2(name, value, priority) {
    var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
    return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
  }

  // node_modules/d3-transition/src/transition/styleTween.js
  function styleInterpolate(name, i, priority) {
    return function(t) {
      this.style.setProperty(name, i.call(this, t), priority);
    };
  }
  function styleTween(name, value, priority) {
    var t, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
      return t;
    }
    tween._value = value;
    return tween;
  }
  function styleTween_default(name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
  }

  // node_modules/d3-transition/src/transition/text.js
  function textConstant2(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction2(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }
  function text_default2(value) {
    return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
  }

  // node_modules/d3-transition/src/transition/textTween.js
  function textInterpolate(i) {
    return function(t) {
      this.textContent = i.call(this, t);
    };
  }
  function textTween(value) {
    var t03, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t03 = (i0 = i) && textInterpolate(i);
      return t03;
    }
    tween._value = value;
    return tween;
  }
  function textTween_default(value) {
    var key = "text";
    if (arguments.length < 1) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    return this.tween(key, textTween(value));
  }

  // node_modules/d3-transition/src/transition/transition.js
  function transition_default() {
    var name = this._name, id0 = this._id, id1 = newId();
    for (var groups2 = this._groups, m4 = groups2.length, j2 = 0; j2 < m4; ++j2) {
      for (var group2 = groups2[j2], n = group2.length, node, i = 0; i < n; ++i) {
        if (node = group2[i]) {
          var inherit2 = get4(node, id0);
          schedule_default(node, name, id1, i, group2, {
            time: inherit2.time + inherit2.delay + inherit2.duration,
            delay: 0,
            duration: inherit2.duration,
            ease: inherit2.ease
          });
        }
      }
    }
    return new Transition(groups2, this._parents, name, id1);
  }

  // node_modules/d3-transition/src/transition/end.js
  function end_default() {
    var on0, on1, that = this, id2 = that._id, size2 = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = { value: reject }, end = { value: function() {
        if (--size2 === 0) resolve();
      } };
      that.each(function() {
        var schedule = set4(this, id2), on2 = schedule.on;
        if (on2 !== on0) {
          on1 = (on0 = on2).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }
        schedule.on = on1;
      });
      if (size2 === 0) resolve();
    });
  }

  // node_modules/d3-transition/src/transition/index.js
  var id = 0;
  function Transition(groups2, parents, name, id2) {
    this._groups = groups2;
    this._parents = parents;
    this._name = name;
    this._id = id2;
  }
  function transition2(name) {
    return selection_default().transition(name);
  }
  function newId() {
    return ++id;
  }
  var selection_prototype = selection_default.prototype;
  Transition.prototype = transition2.prototype = {
    constructor: Transition,
    select: select_default3,
    selectAll: selectAll_default3,
    selectChild: selection_prototype.selectChild,
    selectChildren: selection_prototype.selectChildren,
    filter: filter_default2,
    merge: merge_default2,
    selection: selection_default2,
    transition: transition_default,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: on_default2,
    attr: attr_default2,
    attrTween: attrTween_default,
    style: style_default2,
    styleTween: styleTween_default,
    text: text_default2,
    textTween: textTween_default,
    remove: remove_default2,
    tween: tween_default,
    delay: delay_default,
    duration: duration_default,
    ease: ease_default,
    easeVarying: easeVarying_default,
    end: end_default,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };

  // node_modules/d3-ease/src/linear.js
  var linear2 = (t) => +t;

  // node_modules/d3-ease/src/quad.js
  function quadIn(t) {
    return t * t;
  }
  function quadOut(t) {
    return t * (2 - t);
  }
  function quadInOut(t) {
    return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
  }

  // node_modules/d3-ease/src/cubic.js
  function cubicIn(t) {
    return t * t * t;
  }
  function cubicOut(t) {
    return --t * t * t + 1;
  }
  function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }

  // node_modules/d3-ease/src/poly.js
  var exponent = 3;
  var polyIn = function custom(e) {
    e = +e;
    function polyIn2(t) {
      return Math.pow(t, e);
    }
    polyIn2.exponent = custom;
    return polyIn2;
  }(exponent);
  var polyOut = function custom2(e) {
    e = +e;
    function polyOut2(t) {
      return 1 - Math.pow(1 - t, e);
    }
    polyOut2.exponent = custom2;
    return polyOut2;
  }(exponent);
  var polyInOut = function custom3(e) {
    e = +e;
    function polyInOut2(t) {
      return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
    }
    polyInOut2.exponent = custom3;
    return polyInOut2;
  }(exponent);

  // node_modules/d3-ease/src/sin.js
  var pi = Math.PI;
  var halfPi = pi / 2;
  function sinIn(t) {
    return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
  }
  function sinOut(t) {
    return Math.sin(t * halfPi);
  }
  function sinInOut(t) {
    return (1 - Math.cos(pi * t)) / 2;
  }

  // node_modules/d3-ease/src/math.js
  function tpmt(x5) {
    return (Math.pow(2, -10 * x5) - 9765625e-10) * 1.0009775171065494;
  }

  // node_modules/d3-ease/src/exp.js
  function expIn(t) {
    return tpmt(1 - +t);
  }
  function expOut(t) {
    return 1 - tpmt(t);
  }
  function expInOut(t) {
    return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
  }

  // node_modules/d3-ease/src/circle.js
  function circleIn(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function circleOut(t) {
    return Math.sqrt(1 - --t * t);
  }
  function circleInOut(t) {
    return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
  }

  // node_modules/d3-ease/src/bounce.js
  var b1 = 4 / 11;
  var b2 = 6 / 11;
  var b3 = 8 / 11;
  var b4 = 3 / 4;
  var b5 = 9 / 11;
  var b6 = 10 / 11;
  var b7 = 15 / 16;
  var b8 = 21 / 22;
  var b9 = 63 / 64;
  var b0 = 1 / b1 / b1;
  function bounceIn(t) {
    return 1 - bounceOut(1 - t);
  }
  function bounceOut(t) {
    return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
  }
  function bounceInOut(t) {
    return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
  }

  // node_modules/d3-ease/src/back.js
  var overshoot = 1.70158;
  var backIn = function custom4(s2) {
    s2 = +s2;
    function backIn2(t) {
      return (t = +t) * t * (s2 * (t - 1) + t);
    }
    backIn2.overshoot = custom4;
    return backIn2;
  }(overshoot);
  var backOut = function custom5(s2) {
    s2 = +s2;
    function backOut2(t) {
      return --t * t * ((t + 1) * s2 + t) + 1;
    }
    backOut2.overshoot = custom5;
    return backOut2;
  }(overshoot);
  var backInOut = function custom6(s2) {
    s2 = +s2;
    function backInOut2(t) {
      return ((t *= 2) < 1 ? t * t * ((s2 + 1) * t - s2) : (t -= 2) * t * ((s2 + 1) * t + s2) + 2) / 2;
    }
    backInOut2.overshoot = custom6;
    return backInOut2;
  }(overshoot);

  // node_modules/d3-ease/src/elastic.js
  var tau = 2 * Math.PI;
  var amplitude = 1;
  var period = 0.3;
  var elasticIn = function custom7(a4, p) {
    var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);
    function elasticIn2(t) {
      return a4 * tpmt(- --t) * Math.sin((s2 - t) / p);
    }
    elasticIn2.amplitude = function(a5) {
      return custom7(a5, p * tau);
    };
    elasticIn2.period = function(p2) {
      return custom7(a4, p2);
    };
    return elasticIn2;
  }(amplitude, period);
  var elasticOut = function custom8(a4, p) {
    var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);
    function elasticOut2(t) {
      return 1 - a4 * tpmt(t = +t) * Math.sin((t + s2) / p);
    }
    elasticOut2.amplitude = function(a5) {
      return custom8(a5, p * tau);
    };
    elasticOut2.period = function(p2) {
      return custom8(a4, p2);
    };
    return elasticOut2;
  }(amplitude, period);
  var elasticInOut = function custom9(a4, p) {
    var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);
    function elasticInOut2(t) {
      return ((t = t * 2 - 1) < 0 ? a4 * tpmt(-t) * Math.sin((s2 - t) / p) : 2 - a4 * tpmt(t) * Math.sin((s2 + t) / p)) / 2;
    }
    elasticInOut2.amplitude = function(a5) {
      return custom9(a5, p * tau);
    };
    elasticInOut2.period = function(p2) {
      return custom9(a4, p2);
    };
    return elasticInOut2;
  }(amplitude, period);

  // node_modules/d3-transition/src/selection/transition.js
  var defaultTiming = {
    time: null,
    // Set on use.
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };
  function inherit(node, id2) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id2])) {
      if (!(node = node.parentNode)) {
        throw new Error(`transition ${id2} not found`);
      }
    }
    return timing;
  }
  function transition_default2(name) {
    var id2, timing;
    if (name instanceof Transition) {
      id2 = name._id, name = name._name;
    } else {
      id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
    }
    for (var groups2 = this._groups, m4 = groups2.length, j2 = 0; j2 < m4; ++j2) {
      for (var group2 = groups2[j2], n = group2.length, node, i = 0; i < n; ++i) {
        if (node = group2[i]) {
          schedule_default(node, name, id2, i, group2, timing || inherit(node, id2));
        }
      }
    }
    return new Transition(groups2, this._parents, name, id2);
  }

  // node_modules/d3-transition/src/selection/index.js
  selection_default.prototype.interrupt = interrupt_default2;
  selection_default.prototype.transition = transition_default2;

  // node_modules/d3-transition/src/active.js
  var root2 = [null];
  function active_default(node, name) {
    var schedules = node.__transition, schedule, i;
    if (schedules) {
      name = name == null ? null : name + "";
      for (i in schedules) {
        if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
          return new Transition([[node]], root2, name, +i);
        }
      }
    }
    return null;
  }

  // node_modules/d3-brush/src/constant.js
  var constant_default4 = (x5) => () => x5;

  // node_modules/d3-brush/src/event.js
  function BrushEvent(type2, {
    sourceEvent,
    target,
    selection: selection2,
    mode: mode2,
    dispatch: dispatch2
  }) {
    Object.defineProperties(this, {
      type: { value: type2, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      selection: { value: selection2, enumerable: true, configurable: true },
      mode: { value: mode2, enumerable: true, configurable: true },
      _: { value: dispatch2 }
    });
  }

  // node_modules/d3-brush/src/noevent.js
  function nopropagation2(event2) {
    event2.stopImmediatePropagation();
  }
  function noevent_default2(event2) {
    event2.preventDefault();
    event2.stopImmediatePropagation();
  }

  // node_modules/d3-brush/src/brush.js
  var MODE_DRAG = { name: "drag" };
  var MODE_SPACE = { name: "space" };
  var MODE_HANDLE = { name: "handle" };
  var MODE_CENTER = { name: "center" };
  var { abs, max: max2, min: min2 } = Math;
  function number1(e) {
    return [+e[0], +e[1]];
  }
  function number22(e) {
    return [number1(e[0]), number1(e[1])];
  }
  var X = {
    name: "x",
    handles: ["w", "e"].map(type),
    input: function(x5, e) {
      return x5 == null ? null : [[+x5[0], e[0][1]], [+x5[1], e[1][1]]];
    },
    output: function(xy) {
      return xy && [xy[0][0], xy[1][0]];
    }
  };
  var Y = {
    name: "y",
    handles: ["n", "s"].map(type),
    input: function(y5, e) {
      return y5 == null ? null : [[e[0][0], +y5[0]], [e[1][0], +y5[1]]];
    },
    output: function(xy) {
      return xy && [xy[0][1], xy[1][1]];
    }
  };
  var XY = {
    name: "xy",
    handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
    input: function(xy) {
      return xy == null ? null : number22(xy);
    },
    output: function(xy) {
      return xy;
    }
  };
  var cursors = {
    overlay: "crosshair",
    selection: "move",
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var flipX = {
    e: "w",
    w: "e",
    nw: "ne",
    ne: "nw",
    se: "sw",
    sw: "se"
  };
  var flipY = {
    n: "s",
    s: "n",
    nw: "sw",
    ne: "se",
    se: "ne",
    sw: "nw"
  };
  var signsX = {
    overlay: 1,
    selection: 1,
    n: null,
    e: 1,
    s: null,
    w: -1,
    nw: -1,
    ne: 1,
    se: 1,
    sw: -1
  };
  var signsY = {
    overlay: 1,
    selection: 1,
    n: -1,
    e: null,
    s: 1,
    w: null,
    nw: -1,
    ne: -1,
    se: 1,
    sw: 1
  };
  function type(t) {
    return { type: t };
  }
  function defaultFilter2(event2) {
    return !event2.ctrlKey && !event2.button;
  }
  function defaultExtent() {
    var svg2 = this.ownerSVGElement || this;
    if (svg2.hasAttribute("viewBox")) {
      svg2 = svg2.viewBox.baseVal;
      return [[svg2.x, svg2.y], [svg2.x + svg2.width, svg2.y + svg2.height]];
    }
    return [[0, 0], [svg2.width.baseVal.value, svg2.height.baseVal.value]];
  }
  function defaultTouchable2() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function local2(node) {
    while (!node.__brush) if (!(node = node.parentNode)) return;
    return node.__brush;
  }
  function empty3(extent2) {
    return extent2[0][0] === extent2[1][0] || extent2[0][1] === extent2[1][1];
  }
  function brushSelection(node) {
    var state2 = node.__brush;
    return state2 ? state2.dim.output(state2.selection) : null;
  }
  function brushX() {
    return brush(X);
  }
  function brushY() {
    return brush(Y);
  }
  function brush_default() {
    return brush(XY);
  }
  function brush(dim) {
    var extent2 = defaultExtent, filter3 = defaultFilter2, touchable = defaultTouchable2, keys = true, listeners = dispatch_default("start", "brush", "end"), handleSize = 6, touchending;
    function brush2(group2) {
      var overlay = group2.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
      overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
        var extent3 = local2(this).extent;
        select_default2(this).attr("x", extent3[0][0]).attr("y", extent3[0][1]).attr("width", extent3[1][0] - extent3[0][0]).attr("height", extent3[1][1] - extent3[0][1]);
      });
      group2.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
      var handle = group2.selectAll(".handle").data(dim.handles, function(d) {
        return d.type;
      });
      handle.exit().remove();
      handle.enter().append("rect").attr("class", function(d) {
        return "handle handle--" + d.type;
      }).attr("cursor", function(d) {
        return cursors[d.type];
      });
      group2.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    brush2.move = function(group2, selection2, event2) {
      if (group2.tween) {
        group2.on("start.brush", function(event3) {
          emitter(this, arguments).beforestart().start(event3);
        }).on("interrupt.brush end.brush", function(event3) {
          emitter(this, arguments).end(event3);
        }).tween("brush", function() {
          var that = this, state2 = that.__brush, emit = emitter(that, arguments), selection0 = state2.selection, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state2.extent), i = value_default(selection0, selection1);
          function tween(t) {
            state2.selection = t === 1 && selection1 === null ? null : i(t);
            redraw.call(that);
            emit.brush();
          }
          return selection0 !== null && selection1 !== null ? tween : tween(1);
        });
      } else {
        group2.each(function() {
          var that = this, args = arguments, state2 = that.__brush, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state2.extent), emit = emitter(that, args).beforestart();
          interrupt_default(that);
          state2.selection = selection1 === null ? null : selection1;
          redraw.call(that);
          emit.start(event2).brush(event2).end(event2);
        });
      }
    };
    brush2.clear = function(group2, event2) {
      brush2.move(group2, null, event2);
    };
    function redraw() {
      var group2 = select_default2(this), selection2 = local2(this).selection;
      if (selection2) {
        group2.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
        group2.selectAll(".handle").style("display", null).attr("x", function(d) {
          return d.type[d.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
        }).attr("y", function(d) {
          return d.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
        }).attr("width", function(d) {
          return d.type === "n" || d.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
        }).attr("height", function(d) {
          return d.type === "e" || d.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
        });
      } else {
        group2.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
      }
    }
    function emitter(that, args, clean) {
      var emit = that.__brush.emitter;
      return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
    }
    function Emitter(that, args, clean) {
      this.that = that;
      this.args = args;
      this.state = that.__brush;
      this.active = 0;
      this.clean = clean;
    }
    Emitter.prototype = {
      beforestart: function() {
        if (++this.active === 1) this.state.emitter = this, this.starting = true;
        return this;
      },
      start: function(event2, mode2) {
        if (this.starting) this.starting = false, this.emit("start", event2, mode2);
        else this.emit("brush", event2);
        return this;
      },
      brush: function(event2, mode2) {
        this.emit("brush", event2, mode2);
        return this;
      },
      end: function(event2, mode2) {
        if (--this.active === 0) delete this.state.emitter, this.emit("end", event2, mode2);
        return this;
      },
      emit: function(type2, event2, mode2) {
        var d = select_default2(this.that).datum();
        listeners.call(
          type2,
          this.that,
          new BrushEvent(type2, {
            sourceEvent: event2,
            target: brush2,
            selection: dim.output(this.state.selection),
            mode: mode2,
            dispatch: listeners
          }),
          d
        );
      }
    };
    function started(event2) {
      if (touchending && !event2.touches) return;
      if (!filter3.apply(this, arguments)) return;
      var that = this, type2 = event2.target.__data__.type, mode2 = (keys && event2.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys && event2.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state2 = local2(that), extent3 = state2.extent, selection2 = state2.selection, W2 = extent3[0][0], w0, w1, N2 = extent3[0][1], n0, n1, E3 = extent3[1][0], e0, e1, S2 = extent3[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && event2.shiftKey, lockX, lockY, points = Array.from(event2.touches || [event2], (t) => {
        const i = t.identifier;
        t = pointer_default(t, that);
        t.point0 = t.slice();
        t.identifier = i;
        return t;
      });
      interrupt_default(that);
      var emit = emitter(that, arguments, true).beforestart();
      if (type2 === "overlay") {
        if (selection2) moving = true;
        const pts = [points[0], points[1] || points[0]];
        state2.selection = selection2 = [[
          w0 = dim === Y ? W2 : min2(pts[0][0], pts[1][0]),
          n0 = dim === X ? N2 : min2(pts[0][1], pts[1][1])
        ], [
          e0 = dim === Y ? E3 : max2(pts[0][0], pts[1][0]),
          s0 = dim === X ? S2 : max2(pts[0][1], pts[1][1])
        ]];
        if (points.length > 1) move2(event2);
      } else {
        w0 = selection2[0][0];
        n0 = selection2[0][1];
        e0 = selection2[1][0];
        s0 = selection2[1][1];
      }
      w1 = w0;
      n1 = n0;
      e1 = e0;
      s1 = s0;
      var group2 = select_default2(that).attr("pointer-events", "none");
      var overlay = group2.selectAll(".overlay").attr("cursor", cursors[type2]);
      if (event2.touches) {
        emit.moved = moved;
        emit.ended = ended;
      } else {
        var view = select_default2(event2.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
        if (keys) view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
        nodrag_default(event2.view);
      }
      redraw.call(that);
      emit.start(event2, mode2.name);
      function moved(event3) {
        for (const p of event3.changedTouches || [event3]) {
          for (const d of points)
            if (d.identifier === p.identifier) d.cur = pointer_default(p, that);
        }
        if (shifting && !lockX && !lockY && points.length === 1) {
          const point6 = points[0];
          if (abs(point6.cur[0] - point6[0]) > abs(point6.cur[1] - point6[1]))
            lockY = true;
          else
            lockX = true;
        }
        for (const point6 of points)
          if (point6.cur) point6[0] = point6.cur[0], point6[1] = point6.cur[1];
        moving = true;
        noevent_default2(event3);
        move2(event3);
      }
      function move2(event3) {
        const point6 = points[0], point0 = point6.point0;
        var t;
        dx = point6[0] - point0[0];
        dy = point6[1] - point0[1];
        switch (mode2) {
          case MODE_SPACE:
          case MODE_DRAG: {
            if (signX) dx = max2(W2 - w0, min2(E3 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
            if (signY) dy = max2(N2 - n0, min2(S2 - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
            break;
          }
          case MODE_HANDLE: {
            if (points[1]) {
              if (signX) w1 = max2(W2, min2(E3, points[0][0])), e1 = max2(W2, min2(E3, points[1][0])), signX = 1;
              if (signY) n1 = max2(N2, min2(S2, points[0][1])), s1 = max2(N2, min2(S2, points[1][1])), signY = 1;
            } else {
              if (signX < 0) dx = max2(W2 - w0, min2(E3 - w0, dx)), w1 = w0 + dx, e1 = e0;
              else if (signX > 0) dx = max2(W2 - e0, min2(E3 - e0, dx)), w1 = w0, e1 = e0 + dx;
              if (signY < 0) dy = max2(N2 - n0, min2(S2 - n0, dy)), n1 = n0 + dy, s1 = s0;
              else if (signY > 0) dy = max2(N2 - s0, min2(S2 - s0, dy)), n1 = n0, s1 = s0 + dy;
            }
            break;
          }
          case MODE_CENTER: {
            if (signX) w1 = max2(W2, min2(E3, w0 - dx * signX)), e1 = max2(W2, min2(E3, e0 + dx * signX));
            if (signY) n1 = max2(N2, min2(S2, n0 - dy * signY)), s1 = max2(N2, min2(S2, s0 + dy * signY));
            break;
          }
        }
        if (e1 < w1) {
          signX *= -1;
          t = w0, w0 = e0, e0 = t;
          t = w1, w1 = e1, e1 = t;
          if (type2 in flipX) overlay.attr("cursor", cursors[type2 = flipX[type2]]);
        }
        if (s1 < n1) {
          signY *= -1;
          t = n0, n0 = s0, s0 = t;
          t = n1, n1 = s1, s1 = t;
          if (type2 in flipY) overlay.attr("cursor", cursors[type2 = flipY[type2]]);
        }
        if (state2.selection) selection2 = state2.selection;
        if (lockX) w1 = selection2[0][0], e1 = selection2[1][0];
        if (lockY) n1 = selection2[0][1], s1 = selection2[1][1];
        if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
          state2.selection = [[w1, n1], [e1, s1]];
          redraw.call(that);
          emit.brush(event3, mode2.name);
        }
      }
      function ended(event3) {
        nopropagation2(event3);
        if (event3.touches) {
          if (event3.touches.length) return;
          if (touchending) clearTimeout(touchending);
          touchending = setTimeout(function() {
            touchending = null;
          }, 500);
        } else {
          yesdrag(event3.view, moving);
          view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
        }
        group2.attr("pointer-events", "all");
        overlay.attr("cursor", cursors.overlay);
        if (state2.selection) selection2 = state2.selection;
        if (empty3(selection2)) state2.selection = null, redraw.call(that);
        emit.end(event3, mode2.name);
      }
      function keydowned(event3) {
        switch (event3.keyCode) {
          case 16: {
            shifting = signX && signY;
            break;
          }
          case 18: {
            if (mode2 === MODE_HANDLE) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode2 = MODE_CENTER;
              move2(event3);
            }
            break;
          }
          case 32: {
            if (mode2 === MODE_HANDLE || mode2 === MODE_CENTER) {
              if (signX < 0) e0 = e1 - dx;
              else if (signX > 0) w0 = w1 - dx;
              if (signY < 0) s0 = s1 - dy;
              else if (signY > 0) n0 = n1 - dy;
              mode2 = MODE_SPACE;
              overlay.attr("cursor", cursors.selection);
              move2(event3);
            }
            break;
          }
          default:
            return;
        }
        noevent_default2(event3);
      }
      function keyupped(event3) {
        switch (event3.keyCode) {
          case 16: {
            if (shifting) {
              lockX = lockY = shifting = false;
              move2(event3);
            }
            break;
          }
          case 18: {
            if (mode2 === MODE_CENTER) {
              if (signX < 0) e0 = e1;
              else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1;
              else if (signY > 0) n0 = n1;
              mode2 = MODE_HANDLE;
              move2(event3);
            }
            break;
          }
          case 32: {
            if (mode2 === MODE_SPACE) {
              if (event3.altKey) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode2 = MODE_CENTER;
              } else {
                if (signX < 0) e0 = e1;
                else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1;
                else if (signY > 0) n0 = n1;
                mode2 = MODE_HANDLE;
              }
              overlay.attr("cursor", cursors[type2]);
              move2(event3);
            }
            break;
          }
          default:
            return;
        }
        noevent_default2(event3);
      }
    }
    function touchmoved(event2) {
      emitter(this, arguments).moved(event2);
    }
    function touchended(event2) {
      emitter(this, arguments).ended(event2);
    }
    function initialize() {
      var state2 = this.__brush || { selection: null };
      state2.extent = number22(extent2.apply(this, arguments));
      state2.dim = dim;
      return state2;
    }
    brush2.extent = function(_25) {
      return arguments.length ? (extent2 = typeof _25 === "function" ? _25 : constant_default4(number22(_25)), brush2) : extent2;
    };
    brush2.filter = function(_25) {
      return arguments.length ? (filter3 = typeof _25 === "function" ? _25 : constant_default4(!!_25), brush2) : filter3;
    };
    brush2.touchable = function(_25) {
      return arguments.length ? (touchable = typeof _25 === "function" ? _25 : constant_default4(!!_25), brush2) : touchable;
    };
    brush2.handleSize = function(_25) {
      return arguments.length ? (handleSize = +_25, brush2) : handleSize;
    };
    brush2.keyModifiers = function(_25) {
      return arguments.length ? (keys = !!_25, brush2) : keys;
    };
    brush2.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? brush2 : value;
    };
    return brush2;
  }

  // node_modules/d3-chord/src/math.js
  var abs2 = Math.abs;
  var cos = Math.cos;
  var sin = Math.sin;
  var pi2 = Math.PI;
  var halfPi2 = pi2 / 2;
  var tau2 = pi2 * 2;
  var max3 = Math.max;
  var epsilon3 = 1e-12;

  // node_modules/d3-chord/src/chord.js
  function range2(i, j2) {
    return Array.from({ length: j2 - i }, (_25, k3) => i + k3);
  }
  function compareValue(compare) {
    return function(a4, b10) {
      return compare(
        a4.source.value + a4.target.value,
        b10.source.value + b10.target.value
      );
    };
  }
  function chord_default() {
    return chord(false, false);
  }
  function chordTranspose() {
    return chord(false, true);
  }
  function chordDirected() {
    return chord(true, false);
  }
  function chord(directed, transpose2) {
    var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null;
    function chord2(matrix2) {
      var n = matrix2.length, groupSums = new Array(n), groupIndex = range2(0, n), chords = new Array(n * n), groups2 = new Array(n), k3 = 0, dx;
      matrix2 = Float64Array.from({ length: n * n }, transpose2 ? (_25, i) => matrix2[i % n][i / n | 0] : (_25, i) => matrix2[i / n | 0][i % n]);
      for (let i = 0; i < n; ++i) {
        let x5 = 0;
        for (let j2 = 0; j2 < n; ++j2) x5 += matrix2[i * n + j2] + directed * matrix2[j2 * n + i];
        k3 += groupSums[i] = x5;
      }
      k3 = max3(0, tau2 - padAngle * n) / k3;
      dx = k3 ? padAngle : tau2 / n;
      {
        let x5 = 0;
        if (sortGroups) groupIndex.sort((a4, b10) => sortGroups(groupSums[a4], groupSums[b10]));
        for (const i of groupIndex) {
          const x06 = x5;
          if (directed) {
            const subgroupIndex = range2(~n + 1, n).filter((j2) => j2 < 0 ? matrix2[~j2 * n + i] : matrix2[i * n + j2]);
            if (sortSubgroups) subgroupIndex.sort((a4, b10) => sortSubgroups(a4 < 0 ? -matrix2[~a4 * n + i] : matrix2[i * n + a4], b10 < 0 ? -matrix2[~b10 * n + i] : matrix2[i * n + b10]));
            for (const j2 of subgroupIndex) {
              if (j2 < 0) {
                const chord3 = chords[~j2 * n + i] || (chords[~j2 * n + i] = { source: null, target: null });
                chord3.target = { index: i, startAngle: x5, endAngle: x5 += matrix2[~j2 * n + i] * k3, value: matrix2[~j2 * n + i] };
              } else {
                const chord3 = chords[i * n + j2] || (chords[i * n + j2] = { source: null, target: null });
                chord3.source = { index: i, startAngle: x5, endAngle: x5 += matrix2[i * n + j2] * k3, value: matrix2[i * n + j2] };
              }
            }
            groups2[i] = { index: i, startAngle: x06, endAngle: x5, value: groupSums[i] };
          } else {
            const subgroupIndex = range2(0, n).filter((j2) => matrix2[i * n + j2] || matrix2[j2 * n + i]);
            if (sortSubgroups) subgroupIndex.sort((a4, b10) => sortSubgroups(matrix2[i * n + a4], matrix2[i * n + b10]));
            for (const j2 of subgroupIndex) {
              let chord3;
              if (i < j2) {
                chord3 = chords[i * n + j2] || (chords[i * n + j2] = { source: null, target: null });
                chord3.source = { index: i, startAngle: x5, endAngle: x5 += matrix2[i * n + j2] * k3, value: matrix2[i * n + j2] };
              } else {
                chord3 = chords[j2 * n + i] || (chords[j2 * n + i] = { source: null, target: null });
                chord3.target = { index: i, startAngle: x5, endAngle: x5 += matrix2[i * n + j2] * k3, value: matrix2[i * n + j2] };
                if (i === j2) chord3.source = chord3.target;
              }
              if (chord3.source && chord3.target && chord3.source.value < chord3.target.value) {
                const source2 = chord3.source;
                chord3.source = chord3.target;
                chord3.target = source2;
              }
            }
            groups2[i] = { index: i, startAngle: x06, endAngle: x5, value: groupSums[i] };
          }
          x5 += dx;
        }
      }
      chords = Object.values(chords);
      chords.groups = groups2;
      return sortChords ? chords.sort(sortChords) : chords;
    }
    chord2.padAngle = function(_25) {
      return arguments.length ? (padAngle = max3(0, _25), chord2) : padAngle;
    };
    chord2.sortGroups = function(_25) {
      return arguments.length ? (sortGroups = _25, chord2) : sortGroups;
    };
    chord2.sortSubgroups = function(_25) {
      return arguments.length ? (sortSubgroups = _25, chord2) : sortSubgroups;
    };
    chord2.sortChords = function(_25) {
      return arguments.length ? (_25 == null ? sortChords = null : (sortChords = compareValue(_25))._ = _25, chord2) : sortChords && sortChords._;
    };
    return chord2;
  }

  // node_modules/d3-path/src/path.js
  var pi3 = Math.PI;
  var tau3 = 2 * pi3;
  var epsilon4 = 1e-6;
  var tauEpsilon = tau3 - epsilon4;
  function append2(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += arguments[i] + strings[i];
    }
  }
  function appendRound(digits) {
    let d = Math.floor(digits);
    if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
    if (d > 15) return append2;
    const k3 = 10 ** d;
    return function(strings) {
      this._ += strings[0];
      for (let i = 1, n = strings.length; i < n; ++i) {
        this._ += Math.round(arguments[i] * k3) / k3 + strings[i];
      }
    };
  }
  var Path = class {
    constructor(digits) {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null;
      this._ = "";
      this._append = digits == null ? append2 : appendRound(digits);
    }
    moveTo(x5, y5) {
      this._append`M${this._x0 = this._x1 = +x5},${this._y0 = this._y1 = +y5}`;
    }
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._append`Z`;
      }
    }
    lineTo(x5, y5) {
      this._append`L${this._x1 = +x5},${this._y1 = +y5}`;
    }
    quadraticCurveTo(x12, y12, x5, y5) {
      this._append`Q${+x12},${+y12},${this._x1 = +x5},${this._y1 = +y5}`;
    }
    bezierCurveTo(x12, y12, x22, y22, x5, y5) {
      this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x5},${this._y1 = +y5}`;
    }
    arcTo(x12, y12, x22, y22, r) {
      x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;
      if (r < 0) throw new Error(`negative radius: ${r}`);
      let x06 = this._x1, y06 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;
      if (this._x1 === null) {
        this._append`M${this._x1 = x12},${this._y1 = y12}`;
      } else if (!(l01_2 > epsilon4)) ;
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon4) || !r) {
        this._append`L${this._x1 = x12},${this._y1 = y12}`;
      } else {
        let x20 = x22 - x06, y20 = y22 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r * Math.tan((pi3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
        if (Math.abs(t01 - 1) > epsilon4) {
          this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
        }
        this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
      }
    }
    arc(x5, y5, r, a0, a1, ccw) {
      x5 = +x5, y5 = +y5, r = +r, ccw = !!ccw;
      if (r < 0) throw new Error(`negative radius: ${r}`);
      let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x06 = x5 + dx, y06 = y5 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
      if (this._x1 === null) {
        this._append`M${x06},${y06}`;
      } else if (Math.abs(this._x1 - x06) > epsilon4 || Math.abs(this._y1 - y06) > epsilon4) {
        this._append`L${x06},${y06}`;
      }
      if (!r) return;
      if (da2 < 0) da2 = da2 % tau3 + tau3;
      if (da2 > tauEpsilon) {
        this._append`A${r},${r},0,1,${cw},${x5 - dx},${y5 - dy}A${r},${r},0,1,${cw},${this._x1 = x06},${this._y1 = y06}`;
      } else if (da2 > epsilon4) {
        this._append`A${r},${r},0,${+(da2 >= pi3)},${cw},${this._x1 = x5 + r * Math.cos(a1)},${this._y1 = y5 + r * Math.sin(a1)}`;
      }
    }
    rect(x5, y5, w, h2) {
      this._append`M${this._x0 = this._x1 = +x5},${this._y0 = this._y1 = +y5}h${w = +w}v${+h2}h${-w}Z`;
    }
    toString() {
      return this._;
    }
  };
  function path() {
    return new Path();
  }
  path.prototype = Path.prototype;
  function pathRound(digits = 3) {
    return new Path(+digits);
  }

  // node_modules/d3-chord/src/array.js
  var slice2 = Array.prototype.slice;

  // node_modules/d3-chord/src/constant.js
  function constant_default5(x5) {
    return function() {
      return x5;
    };
  }

  // node_modules/d3-chord/src/ribbon.js
  function defaultSource(d) {
    return d.source;
  }
  function defaultTarget(d) {
    return d.target;
  }
  function defaultRadius(d) {
    return d.radius;
  }
  function defaultStartAngle(d) {
    return d.startAngle;
  }
  function defaultEndAngle(d) {
    return d.endAngle;
  }
  function defaultPadAngle() {
    return 0;
  }
  function defaultArrowheadRadius() {
    return 10;
  }
  function ribbon(headRadius) {
    var source2 = defaultSource, target = defaultTarget, sourceRadius = defaultRadius, targetRadius = defaultRadius, startAngle = defaultStartAngle, endAngle = defaultEndAngle, padAngle = defaultPadAngle, context = null;
    function ribbon2() {
      var buffer, s2 = source2.apply(this, arguments), t = target.apply(this, arguments), ap = padAngle.apply(this, arguments) / 2, argv = slice2.call(arguments), sr = +sourceRadius.apply(this, (argv[0] = s2, argv)), sa0 = startAngle.apply(this, argv) - halfPi2, sa1 = endAngle.apply(this, argv) - halfPi2, tr = +targetRadius.apply(this, (argv[0] = t, argv)), ta0 = startAngle.apply(this, argv) - halfPi2, ta1 = endAngle.apply(this, argv) - halfPi2;
      if (!context) context = buffer = path();
      if (ap > epsilon3) {
        if (abs2(sa1 - sa0) > ap * 2 + epsilon3) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
        else sa0 = sa1 = (sa0 + sa1) / 2;
        if (abs2(ta1 - ta0) > ap * 2 + epsilon3) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
        else ta0 = ta1 = (ta0 + ta1) / 2;
      }
      context.moveTo(sr * cos(sa0), sr * sin(sa0));
      context.arc(0, 0, sr, sa0, sa1);
      if (sa0 !== ta0 || sa1 !== ta1) {
        if (headRadius) {
          var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
          context.quadraticCurveTo(0, 0, tr2 * cos(ta0), tr2 * sin(ta0));
          context.lineTo(tr * cos(ta2), tr * sin(ta2));
          context.lineTo(tr2 * cos(ta1), tr2 * sin(ta1));
        } else {
          context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
          context.arc(0, 0, tr, ta0, ta1);
        }
      }
      context.quadraticCurveTo(0, 0, sr * cos(sa0), sr * sin(sa0));
      context.closePath();
      if (buffer) return context = null, buffer + "" || null;
    }
    if (headRadius) ribbon2.headRadius = function(_25) {
      return arguments.length ? (headRadius = typeof _25 === "function" ? _25 : constant_default5(+_25), ribbon2) : headRadius;
    };
    ribbon2.radius = function(_25) {
      return arguments.length ? (sourceRadius = targetRadius = typeof _25 === "function" ? _25 : constant_default5(+_25), ribbon2) : sourceRadius;
    };
    ribbon2.sourceRadius = function(_25) {
      return arguments.length ? (sourceRadius = typeof _25 === "function" ? _25 : constant_default5(+_25), ribbon2) : sourceRadius;
    };
    ribbon2.targetRadius = function(_25) {
      return arguments.length ? (targetRadius = typeof _25 === "function" ? _25 : constant_default5(+_25), ribbon2) : targetRadius;
    };
    ribbon2.startAngle = function(_25) {
      return arguments.length ? (startAngle = typeof _25 === "function" ? _25 : constant_default5(+_25), ribbon2) : startAngle;
    };
    ribbon2.endAngle = function(_25) {
      return arguments.length ? (endAngle = typeof _25 === "function" ? _25 : constant_default5(+_25), ribbon2) : endAngle;
    };
    ribbon2.padAngle = function(_25) {
      return arguments.length ? (padAngle = typeof _25 === "function" ? _25 : constant_default5(+_25), ribbon2) : padAngle;
    };
    ribbon2.source = function(_25) {
      return arguments.length ? (source2 = _25, ribbon2) : source2;
    };
    ribbon2.target = function(_25) {
      return arguments.length ? (target = _25, ribbon2) : target;
    };
    ribbon2.context = function(_25) {
      return arguments.length ? (context = _25 == null ? null : _25, ribbon2) : context;
    };
    return ribbon2;
  }
  function ribbon_default() {
    return ribbon();
  }
  function ribbonArrow() {
    return ribbon(defaultArrowheadRadius);
  }

  // node_modules/d3-contour/src/array.js
  var array3 = Array.prototype;
  var slice3 = array3.slice;

  // node_modules/d3-contour/src/ascending.js
  function ascending_default(a4, b10) {
    return a4 - b10;
  }

  // node_modules/d3-contour/src/area.js
  function area_default(ring) {
    var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
    while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
    return area;
  }

  // node_modules/d3-contour/src/constant.js
  var constant_default6 = (x5) => () => x5;

  // node_modules/d3-contour/src/contains.js
  function contains_default(ring, hole) {
    var i = -1, n = hole.length, c6;
    while (++i < n) if (c6 = ringContains(ring, hole[i])) return c6;
    return 0;
  }
  function ringContains(ring, point6) {
    var x5 = point6[0], y5 = point6[1], contains = -1;
    for (var i = 0, n = ring.length, j2 = n - 1; i < n; j2 = i++) {
      var pi6 = ring[i], xi = pi6[0], yi = pi6[1], pj = ring[j2], xj = pj[0], yj = pj[1];
      if (segmentContains(pi6, pj, point6)) return 0;
      if (yi > y5 !== yj > y5 && x5 < (xj - xi) * (y5 - yi) / (yj - yi) + xi) contains = -contains;
    }
    return contains;
  }
  function segmentContains(a4, b10, c6) {
    var i;
    return collinear(a4, b10, c6) && within(a4[i = +(a4[0] === b10[0])], c6[i], b10[i]);
  }
  function collinear(a4, b10, c6) {
    return (b10[0] - a4[0]) * (c6[1] - a4[1]) === (c6[0] - a4[0]) * (b10[1] - a4[1]);
  }
  function within(p, q2, r) {
    return p <= q2 && q2 <= r || r <= q2 && q2 <= p;
  }

  // node_modules/d3-contour/src/noop.js
  function noop_default() {
  }

  // node_modules/d3-contour/src/contours.js
  var cases = [
    [],
    [[[1, 1.5], [0.5, 1]]],
    [[[1.5, 1], [1, 1.5]]],
    [[[1.5, 1], [0.5, 1]]],
    [[[1, 0.5], [1.5, 1]]],
    [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
    [[[1, 0.5], [1, 1.5]]],
    [[[1, 0.5], [0.5, 1]]],
    [[[0.5, 1], [1, 0.5]]],
    [[[1, 1.5], [1, 0.5]]],
    [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
    [[[1.5, 1], [1, 0.5]]],
    [[[0.5, 1], [1.5, 1]]],
    [[[1, 1.5], [1.5, 1]]],
    [[[0.5, 1], [1, 1.5]]],
    []
  ];
  function contours_default() {
    var dx = 1, dy = 1, threshold2 = thresholdSturges, smooth = smoothLinear;
    function contours(values2) {
      var tz = threshold2(values2);
      if (!Array.isArray(tz)) {
        const e = extent(values2, finite);
        tz = ticks(...nice(e[0], e[1], tz), tz);
        while (tz[tz.length - 1] >= e[1]) tz.pop();
        while (tz[1] < e[0]) tz.shift();
      } else {
        tz = tz.slice().sort(ascending_default);
      }
      return tz.map((value) => contour(values2, value));
    }
    function contour(values2, value) {
      const v3 = value == null ? NaN : +value;
      if (isNaN(v3)) throw new Error(`invalid value: ${value}`);
      var polygons = [], holes = [];
      isorings(values2, v3, function(ring) {
        smooth(ring, values2, v3);
        if (area_default(ring) > 0) polygons.push([ring]);
        else holes.push(ring);
      });
      holes.forEach(function(hole) {
        for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
          if (contains_default((polygon = polygons[i])[0], hole) !== -1) {
            polygon.push(hole);
            return;
          }
        }
      });
      return {
        type: "MultiPolygon",
        value,
        coordinates: polygons
      };
    }
    function isorings(values2, value, callback) {
      var fragmentByStart = new Array(), fragmentByEnd = new Array(), x5, y5, t03, t13, t22, t32;
      x5 = y5 = -1;
      t13 = above(values2[0], value);
      cases[t13 << 1].forEach(stitch);
      while (++x5 < dx - 1) {
        t03 = t13, t13 = above(values2[x5 + 1], value);
        cases[t03 | t13 << 1].forEach(stitch);
      }
      cases[t13 << 0].forEach(stitch);
      while (++y5 < dy - 1) {
        x5 = -1;
        t13 = above(values2[y5 * dx + dx], value);
        t22 = above(values2[y5 * dx], value);
        cases[t13 << 1 | t22 << 2].forEach(stitch);
        while (++x5 < dx - 1) {
          t03 = t13, t13 = above(values2[y5 * dx + dx + x5 + 1], value);
          t32 = t22, t22 = above(values2[y5 * dx + x5 + 1], value);
          cases[t03 | t13 << 1 | t22 << 2 | t32 << 3].forEach(stitch);
        }
        cases[t13 | t22 << 3].forEach(stitch);
      }
      x5 = -1;
      t22 = values2[y5 * dx] >= value;
      cases[t22 << 2].forEach(stitch);
      while (++x5 < dx - 1) {
        t32 = t22, t22 = above(values2[y5 * dx + x5 + 1], value);
        cases[t22 << 2 | t32 << 3].forEach(stitch);
      }
      cases[t22 << 3].forEach(stitch);
      function stitch(line) {
        var start2 = [line[0][0] + x5, line[0][1] + y5], end = [line[1][0] + x5, line[1][1] + y5], startIndex = index4(start2), endIndex = index4(end), f, g;
        if (f = fragmentByEnd[startIndex]) {
          if (g = fragmentByStart[endIndex]) {
            delete fragmentByEnd[f.end];
            delete fragmentByStart[g.start];
            if (f === g) {
              f.ring.push(end);
              callback(f.ring);
            } else {
              fragmentByStart[f.start] = fragmentByEnd[g.end] = { start: f.start, end: g.end, ring: f.ring.concat(g.ring) };
            }
          } else {
            delete fragmentByEnd[f.end];
            f.ring.push(end);
            fragmentByEnd[f.end = endIndex] = f;
          }
        } else if (f = fragmentByStart[endIndex]) {
          if (g = fragmentByEnd[startIndex]) {
            delete fragmentByStart[f.start];
            delete fragmentByEnd[g.end];
            if (f === g) {
              f.ring.push(end);
              callback(f.ring);
            } else {
              fragmentByStart[g.start] = fragmentByEnd[f.end] = { start: g.start, end: f.end, ring: g.ring.concat(f.ring) };
            }
          } else {
            delete fragmentByStart[f.start];
            f.ring.unshift(start2);
            fragmentByStart[f.start = startIndex] = f;
          }
        } else {
          fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start2, end] };
        }
      }
    }
    function index4(point6) {
      return point6[0] * 2 + point6[1] * (dx + 1) * 4;
    }
    function smoothLinear(ring, values2, value) {
      ring.forEach(function(point6) {
        var x5 = point6[0], y5 = point6[1], xt = x5 | 0, yt2 = y5 | 0, v1 = valid(values2[yt2 * dx + xt]);
        if (x5 > 0 && x5 < dx && xt === x5) {
          point6[0] = smooth1(x5, valid(values2[yt2 * dx + xt - 1]), v1, value);
        }
        if (y5 > 0 && y5 < dy && yt2 === y5) {
          point6[1] = smooth1(y5, valid(values2[(yt2 - 1) * dx + xt]), v1, value);
        }
      });
    }
    contours.contour = contour;
    contours.size = function(_25) {
      if (!arguments.length) return [dx, dy];
      var _0 = Math.floor(_25[0]), _1 = Math.floor(_25[1]);
      if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
      return dx = _0, dy = _1, contours;
    };
    contours.thresholds = function(_25) {
      return arguments.length ? (threshold2 = typeof _25 === "function" ? _25 : Array.isArray(_25) ? constant_default6(slice3.call(_25)) : constant_default6(_25), contours) : threshold2;
    };
    contours.smooth = function(_25) {
      return arguments.length ? (smooth = _25 ? smoothLinear : noop_default, contours) : smooth === smoothLinear;
    };
    return contours;
  }
  function finite(x5) {
    return isFinite(x5) ? x5 : NaN;
  }
  function above(x5, value) {
    return x5 == null ? false : +x5 >= value;
  }
  function valid(v3) {
    return v3 == null || isNaN(v3 = +v3) ? -Infinity : v3;
  }
  function smooth1(x5, v0, v1, value) {
    const a4 = value - v0;
    const b10 = v1 - v0;
    const d = isFinite(a4) || isFinite(b10) ? a4 / b10 : Math.sign(a4) / Math.sign(b10);
    return isNaN(d) ? x5 : x5 + d - 0.5;
  }

  // node_modules/d3-contour/src/density.js
  function defaultX(d) {
    return d[0];
  }
  function defaultY(d) {
    return d[1];
  }
  function defaultWeight() {
    return 1;
  }
  function density_default() {
    var x5 = defaultX, y5 = defaultY, weight = defaultWeight, dx = 960, dy = 500, r = 20, k3 = 2, o = r * 3, n = dx + o * 2 >> k3, m4 = dy + o * 2 >> k3, threshold2 = constant_default6(20);
    function grid(data2) {
      var values2 = new Float32Array(n * m4), pow2k = Math.pow(2, -k3), i = -1;
      for (const d of data2) {
        var xi = (x5(d, ++i, data2) + o) * pow2k, yi = (y5(d, i, data2) + o) * pow2k, wi = +weight(d, i, data2);
        if (wi && xi >= 0 && xi < n && yi >= 0 && yi < m4) {
          var x06 = Math.floor(xi), y06 = Math.floor(yi), xt = xi - x06 - 0.5, yt2 = yi - y06 - 0.5;
          values2[x06 + y06 * n] += (1 - xt) * (1 - yt2) * wi;
          values2[x06 + 1 + y06 * n] += xt * (1 - yt2) * wi;
          values2[x06 + 1 + (y06 + 1) * n] += xt * yt2 * wi;
          values2[x06 + (y06 + 1) * n] += (1 - xt) * yt2 * wi;
        }
      }
      blur2({ data: values2, width: n, height: m4 }, r * pow2k);
      return values2;
    }
    function density(data2) {
      var values2 = grid(data2), tz = threshold2(values2), pow4k = Math.pow(2, 2 * k3);
      if (!Array.isArray(tz)) {
        tz = ticks(Number.MIN_VALUE, max(values2) / pow4k, tz);
      }
      return contours_default().size([n, m4]).thresholds(tz.map((d) => d * pow4k))(values2).map((c6, i) => (c6.value = +tz[i], transform2(c6)));
    }
    density.contours = function(data2) {
      var values2 = grid(data2), contours = contours_default().size([n, m4]), pow4k = Math.pow(2, 2 * k3), contour = (value) => {
        value = +value;
        var c6 = transform2(contours.contour(values2, value * pow4k));
        c6.value = value;
        return c6;
      };
      Object.defineProperty(contour, "max", { get: () => max(values2) / pow4k });
      return contour;
    };
    function transform2(geometry) {
      geometry.coordinates.forEach(transformPolygon);
      return geometry;
    }
    function transformPolygon(coordinates2) {
      coordinates2.forEach(transformRing);
    }
    function transformRing(coordinates2) {
      coordinates2.forEach(transformPoint);
    }
    function transformPoint(coordinates2) {
      coordinates2[0] = coordinates2[0] * Math.pow(2, k3) - o;
      coordinates2[1] = coordinates2[1] * Math.pow(2, k3) - o;
    }
    function resize() {
      o = r * 3;
      n = dx + o * 2 >> k3;
      m4 = dy + o * 2 >> k3;
      return density;
    }
    density.x = function(_25) {
      return arguments.length ? (x5 = typeof _25 === "function" ? _25 : constant_default6(+_25), density) : x5;
    };
    density.y = function(_25) {
      return arguments.length ? (y5 = typeof _25 === "function" ? _25 : constant_default6(+_25), density) : y5;
    };
    density.weight = function(_25) {
      return arguments.length ? (weight = typeof _25 === "function" ? _25 : constant_default6(+_25), density) : weight;
    };
    density.size = function(_25) {
      if (!arguments.length) return [dx, dy];
      var _0 = +_25[0], _1 = +_25[1];
      if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
      return dx = _0, dy = _1, resize();
    };
    density.cellSize = function(_25) {
      if (!arguments.length) return 1 << k3;
      if (!((_25 = +_25) >= 1)) throw new Error("invalid cell size");
      return k3 = Math.floor(Math.log(_25) / Math.LN2), resize();
    };
    density.thresholds = function(_25) {
      return arguments.length ? (threshold2 = typeof _25 === "function" ? _25 : Array.isArray(_25) ? constant_default6(slice3.call(_25)) : constant_default6(_25), density) : threshold2;
    };
    density.bandwidth = function(_25) {
      if (!arguments.length) return Math.sqrt(r * (r + 1));
      if (!((_25 = +_25) >= 0)) throw new Error("invalid bandwidth");
      return r = (Math.sqrt(4 * _25 * _25 + 1) - 1) / 2, resize();
    };
    return density;
  }

  // node_modules/robust-predicates/esm/util.js
  var epsilon5 = 11102230246251565e-32;
  var splitter = 134217729;
  var resulterrbound = (3 + 8 * epsilon5) * epsilon5;
  function sum2(elen, e, flen, f, h2) {
    let Q2, Qnew, hh, bvirt;
    let enow = e[0];
    let fnow = f[0];
    let eindex = 0;
    let findex = 0;
    if (fnow > enow === fnow > -enow) {
      Q2 = enow;
      enow = e[++eindex];
    } else {
      Q2 = fnow;
      fnow = f[++findex];
    }
    let hindex = 0;
    if (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = enow + Q2;
        hh = Q2 - (Qnew - enow);
        enow = e[++eindex];
      } else {
        Qnew = fnow + Q2;
        hh = Q2 - (Qnew - fnow);
        fnow = f[++findex];
      }
      Q2 = Qnew;
      if (hh !== 0) {
        h2[hindex++] = hh;
      }
      while (eindex < elen && findex < flen) {
        if (fnow > enow === fnow > -enow) {
          Qnew = Q2 + enow;
          bvirt = Qnew - Q2;
          hh = Q2 - (Qnew - bvirt) + (enow - bvirt);
          enow = e[++eindex];
        } else {
          Qnew = Q2 + fnow;
          bvirt = Qnew - Q2;
          hh = Q2 - (Qnew - bvirt) + (fnow - bvirt);
          fnow = f[++findex];
        }
        Q2 = Qnew;
        if (hh !== 0) {
          h2[hindex++] = hh;
        }
      }
    }
    while (eindex < elen) {
      Qnew = Q2 + enow;
      bvirt = Qnew - Q2;
      hh = Q2 - (Qnew - bvirt) + (enow - bvirt);
      enow = e[++eindex];
      Q2 = Qnew;
      if (hh !== 0) {
        h2[hindex++] = hh;
      }
    }
    while (findex < flen) {
      Qnew = Q2 + fnow;
      bvirt = Qnew - Q2;
      hh = Q2 - (Qnew - bvirt) + (fnow - bvirt);
      fnow = f[++findex];
      Q2 = Qnew;
      if (hh !== 0) {
        h2[hindex++] = hh;
      }
    }
    if (Q2 !== 0 || hindex === 0) {
      h2[hindex++] = Q2;
    }
    return hindex;
  }
  function estimate(elen, e) {
    let Q2 = e[0];
    for (let i = 1; i < elen; i++) Q2 += e[i];
    return Q2;
  }
  function vec(n) {
    return new Float64Array(n);
  }

  // node_modules/robust-predicates/esm/orient2d.js
  var ccwerrboundA = (3 + 16 * epsilon5) * epsilon5;
  var ccwerrboundB = (2 + 12 * epsilon5) * epsilon5;
  var ccwerrboundC = (9 + 64 * epsilon5) * epsilon5 * epsilon5;
  var B2 = vec(4);
  var C1 = vec(8);
  var C2 = vec(12);
  var D2 = vec(16);
  var u = vec(4);
  function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
    let acxtail, acytail, bcxtail, bcytail;
    let bvirt, c6, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t13, t03, u32;
    const acx = ax - cx;
    const bcx = bx - cx;
    const acy = ay - cy;
    const bcy = by - cy;
    s1 = acx * bcy;
    c6 = splitter * acx;
    ahi = c6 - (c6 - acx);
    alo = acx - ahi;
    c6 = splitter * bcy;
    bhi = c6 - (c6 - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t13 = acy * bcx;
    c6 = splitter * acy;
    ahi = c6 - (c6 - acy);
    alo = acy - ahi;
    c6 = splitter * bcx;
    bhi = c6 - (c6 - bcx);
    blo = bcx - bhi;
    t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t03;
    bvirt = s0 - _i;
    B2[0] = s0 - (_i + bvirt) + (bvirt - t03);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t13;
    bvirt = _0 - _i;
    B2[1] = _0 - (_i + bvirt) + (bvirt - t13);
    u32 = _j + _i;
    bvirt = u32 - _j;
    B2[2] = _j - (u32 - bvirt) + (_i - bvirt);
    B2[3] = u32;
    let det = estimate(4, B2);
    let errbound = ccwerrboundB * detsum;
    if (det >= errbound || -det >= errbound) {
      return det;
    }
    bvirt = ax - acx;
    acxtail = ax - (acx + bvirt) + (bvirt - cx);
    bvirt = bx - bcx;
    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
    bvirt = ay - acy;
    acytail = ay - (acy + bvirt) + (bvirt - cy);
    bvirt = by - bcy;
    bcytail = by - (bcy + bvirt) + (bvirt - cy);
    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
      return det;
    }
    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
    det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
    if (det >= errbound || -det >= errbound) return det;
    s1 = acxtail * bcy;
    c6 = splitter * acxtail;
    ahi = c6 - (c6 - acxtail);
    alo = acxtail - ahi;
    c6 = splitter * bcy;
    bhi = c6 - (c6 - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t13 = acytail * bcx;
    c6 = splitter * acytail;
    ahi = c6 - (c6 - acytail);
    alo = acytail - ahi;
    c6 = splitter * bcx;
    bhi = c6 - (c6 - bcx);
    blo = bcx - bhi;
    t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t03;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t03);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t13;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t13);
    u32 = _j + _i;
    bvirt = u32 - _j;
    u[2] = _j - (u32 - bvirt) + (_i - bvirt);
    u[3] = u32;
    const C1len = sum2(4, B2, 4, u, C1);
    s1 = acx * bcytail;
    c6 = splitter * acx;
    ahi = c6 - (c6 - acx);
    alo = acx - ahi;
    c6 = splitter * bcytail;
    bhi = c6 - (c6 - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t13 = acy * bcxtail;
    c6 = splitter * acy;
    ahi = c6 - (c6 - acy);
    alo = acy - ahi;
    c6 = splitter * bcxtail;
    bhi = c6 - (c6 - bcxtail);
    blo = bcxtail - bhi;
    t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t03;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t03);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t13;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t13);
    u32 = _j + _i;
    bvirt = u32 - _j;
    u[2] = _j - (u32 - bvirt) + (_i - bvirt);
    u[3] = u32;
    const C2len = sum2(C1len, C1, 4, u, C2);
    s1 = acxtail * bcytail;
    c6 = splitter * acxtail;
    ahi = c6 - (c6 - acxtail);
    alo = acxtail - ahi;
    c6 = splitter * bcytail;
    bhi = c6 - (c6 - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t13 = acytail * bcxtail;
    c6 = splitter * acytail;
    ahi = c6 - (c6 - acytail);
    alo = acytail - ahi;
    c6 = splitter * bcxtail;
    bhi = c6 - (c6 - bcxtail);
    blo = bcxtail - bhi;
    t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t03;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t03);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t13;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t13);
    u32 = _j + _i;
    bvirt = u32 - _j;
    u[2] = _j - (u32 - bvirt) + (_i - bvirt);
    u[3] = u32;
    const Dlen = sum2(C2len, C2, 4, u, D2);
    return D2[Dlen - 1];
  }
  function orient2d(ax, ay, bx, by, cx, cy) {
    const detleft = (ay - cy) * (bx - cx);
    const detright = (ax - cx) * (by - cy);
    const det = detleft - detright;
    const detsum = Math.abs(detleft + detright);
    if (Math.abs(det) >= ccwerrboundA * detsum) return det;
    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
  }

  // node_modules/robust-predicates/esm/orient3d.js
  var o3derrboundA = (7 + 56 * epsilon5) * epsilon5;
  var o3derrboundB = (3 + 28 * epsilon5) * epsilon5;
  var o3derrboundC = (26 + 288 * epsilon5) * epsilon5 * epsilon5;
  var bc = vec(4);
  var ca = vec(4);
  var ab = vec(4);
  var at_b = vec(4);
  var at_c = vec(4);
  var bt_c = vec(4);
  var bt_a = vec(4);
  var ct_a = vec(4);
  var ct_b = vec(4);
  var bct = vec(8);
  var cat = vec(8);
  var abt = vec(8);
  var u2 = vec(4);
  var _8 = vec(8);
  var _8b = vec(8);
  var _16 = vec(8);
  var _12 = vec(12);
  var fin = vec(192);
  var fin2 = vec(192);

  // node_modules/robust-predicates/esm/incircle.js
  var iccerrboundA = (10 + 96 * epsilon5) * epsilon5;
  var iccerrboundB = (4 + 48 * epsilon5) * epsilon5;
  var iccerrboundC = (44 + 576 * epsilon5) * epsilon5 * epsilon5;
  var bc2 = vec(4);
  var ca2 = vec(4);
  var ab2 = vec(4);
  var aa = vec(4);
  var bb = vec(4);
  var cc = vec(4);
  var u3 = vec(4);
  var v = vec(4);
  var axtbc = vec(8);
  var aytbc = vec(8);
  var bxtca = vec(8);
  var bytca = vec(8);
  var cxtab = vec(8);
  var cytab = vec(8);
  var abt2 = vec(8);
  var bct2 = vec(8);
  var cat2 = vec(8);
  var abtt = vec(4);
  var bctt = vec(4);
  var catt = vec(4);
  var _82 = vec(8);
  var _162 = vec(16);
  var _16b = vec(16);
  var _16c = vec(16);
  var _32 = vec(32);
  var _32b = vec(32);
  var _48 = vec(48);
  var _64 = vec(64);
  var fin3 = vec(1152);
  var fin22 = vec(1152);

  // node_modules/robust-predicates/esm/insphere.js
  var isperrboundA = (16 + 224 * epsilon5) * epsilon5;
  var isperrboundB = (5 + 72 * epsilon5) * epsilon5;
  var isperrboundC = (71 + 1408 * epsilon5) * epsilon5 * epsilon5;
  var ab3 = vec(4);
  var bc3 = vec(4);
  var cd = vec(4);
  var de = vec(4);
  var ea = vec(4);
  var ac = vec(4);
  var bd = vec(4);
  var ce = vec(4);
  var da = vec(4);
  var eb = vec(4);
  var abc = vec(24);
  var bcd = vec(24);
  var cde = vec(24);
  var dea = vec(24);
  var eab = vec(24);
  var abd = vec(24);
  var bce = vec(24);
  var cda = vec(24);
  var deb = vec(24);
  var eac = vec(24);
  var adet = vec(1152);
  var bdet = vec(1152);
  var cdet = vec(1152);
  var ddet = vec(1152);
  var edet = vec(1152);
  var abdet = vec(2304);
  var cddet = vec(2304);
  var cdedet = vec(3456);
  var deter = vec(5760);
  var _83 = vec(8);
  var _8b2 = vec(8);
  var _8c = vec(8);
  var _163 = vec(16);
  var _24 = vec(24);
  var _482 = vec(48);
  var _48b = vec(48);
  var _96 = vec(96);
  var _192 = vec(192);
  var _384x = vec(384);
  var _384y = vec(384);
  var _384z = vec(384);
  var _768 = vec(768);
  var xdet = vec(96);
  var ydet = vec(96);
  var zdet = vec(96);
  var fin4 = vec(1152);

  // node_modules/delaunator/index.js
  var EPSILON = Math.pow(2, -52);
  var EDGE_STACK = new Uint32Array(512);
  var Delaunator = class _Delaunator {
    static from(points, getX = defaultGetX, getY = defaultGetY) {
      const n = points.length;
      const coords = new Float64Array(n * 2);
      for (let i = 0; i < n; i++) {
        const p = points[i];
        coords[2 * i] = getX(p);
        coords[2 * i + 1] = getY(p);
      }
      return new _Delaunator(coords);
    }
    constructor(coords) {
      const n = coords.length >> 1;
      if (n > 0 && typeof coords[0] !== "number") throw new Error("Expected coords to contain numbers.");
      this.coords = coords;
      const maxTriangles = Math.max(2 * n - 5, 0);
      this._triangles = new Uint32Array(maxTriangles * 3);
      this._halfedges = new Int32Array(maxTriangles * 3);
      this._hashSize = Math.ceil(Math.sqrt(n));
      this._hullPrev = new Uint32Array(n);
      this._hullNext = new Uint32Array(n);
      this._hullTri = new Uint32Array(n);
      this._hullHash = new Int32Array(this._hashSize);
      this._ids = new Uint32Array(n);
      this._dists = new Float64Array(n);
      this.update();
    }
    update() {
      const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
      const n = coords.length >> 1;
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY2 = -Infinity;
      for (let i = 0; i < n; i++) {
        const x5 = coords[2 * i];
        const y5 = coords[2 * i + 1];
        if (x5 < minX) minX = x5;
        if (y5 < minY) minY = y5;
        if (x5 > maxX) maxX = x5;
        if (y5 > maxY2) maxY2 = y5;
        this._ids[i] = i;
      }
      const cx = (minX + maxX) / 2;
      const cy = (minY + maxY2) / 2;
      let i0, i1, i2;
      for (let i = 0, minDist = Infinity; i < n; i++) {
        const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
        if (d < minDist) {
          i0 = i;
          minDist = d;
        }
      }
      const i0x = coords[2 * i0];
      const i0y = coords[2 * i0 + 1];
      for (let i = 0, minDist = Infinity; i < n; i++) {
        if (i === i0) continue;
        const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
        if (d < minDist && d > 0) {
          i1 = i;
          minDist = d;
        }
      }
      let i1x = coords[2 * i1];
      let i1y = coords[2 * i1 + 1];
      let minRadius = Infinity;
      for (let i = 0; i < n; i++) {
        if (i === i0 || i === i1) continue;
        const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
        if (r < minRadius) {
          i2 = i;
          minRadius = r;
        }
      }
      let i2x = coords[2 * i2];
      let i2y = coords[2 * i2 + 1];
      if (minRadius === Infinity) {
        for (let i = 0; i < n; i++) {
          this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
        }
        quicksort(this._ids, this._dists, 0, n - 1);
        const hull = new Uint32Array(n);
        let j2 = 0;
        for (let i = 0, d0 = -Infinity; i < n; i++) {
          const id2 = this._ids[i];
          const d = this._dists[id2];
          if (d > d0) {
            hull[j2++] = id2;
            d0 = d;
          }
        }
        this.hull = hull.subarray(0, j2);
        this.triangles = new Uint32Array(0);
        this.halfedges = new Uint32Array(0);
        return;
      }
      if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
        const i = i1;
        const x5 = i1x;
        const y5 = i1y;
        i1 = i2;
        i1x = i2x;
        i1y = i2y;
        i2 = i;
        i2x = x5;
        i2y = y5;
      }
      const center2 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
      this._cx = center2.x;
      this._cy = center2.y;
      for (let i = 0; i < n; i++) {
        this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center2.x, center2.y);
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      this._hullStart = i0;
      let hullSize = 3;
      hullNext[i0] = hullPrev[i2] = i1;
      hullNext[i1] = hullPrev[i0] = i2;
      hullNext[i2] = hullPrev[i1] = i0;
      hullTri[i0] = 0;
      hullTri[i1] = 1;
      hullTri[i2] = 2;
      hullHash.fill(-1);
      hullHash[this._hashKey(i0x, i0y)] = i0;
      hullHash[this._hashKey(i1x, i1y)] = i1;
      hullHash[this._hashKey(i2x, i2y)] = i2;
      this.trianglesLen = 0;
      this._addTriangle(i0, i1, i2, -1, -1, -1);
      for (let k3 = 0, xp, yp; k3 < this._ids.length; k3++) {
        const i = this._ids[k3];
        const x5 = coords[2 * i];
        const y5 = coords[2 * i + 1];
        if (k3 > 0 && Math.abs(x5 - xp) <= EPSILON && Math.abs(y5 - yp) <= EPSILON) continue;
        xp = x5;
        yp = y5;
        if (i === i0 || i === i1 || i === i2) continue;
        let start2 = 0;
        for (let j2 = 0, key = this._hashKey(x5, y5); j2 < this._hashSize; j2++) {
          start2 = hullHash[(key + j2) % this._hashSize];
          if (start2 !== -1 && start2 !== hullNext[start2]) break;
        }
        start2 = hullPrev[start2];
        let e = start2, q2;
        while (q2 = hullNext[e], orient2d(x5, y5, coords[2 * e], coords[2 * e + 1], coords[2 * q2], coords[2 * q2 + 1]) >= 0) {
          e = q2;
          if (e === start2) {
            e = -1;
            break;
          }
        }
        if (e === -1) continue;
        let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
        hullTri[i] = this._legalize(t + 2);
        hullTri[e] = t;
        hullSize++;
        let n2 = hullNext[e];
        while (q2 = hullNext[n2], orient2d(x5, y5, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q2], coords[2 * q2 + 1]) < 0) {
          t = this._addTriangle(n2, i, q2, hullTri[i], -1, hullTri[n2]);
          hullTri[i] = this._legalize(t + 2);
          hullNext[n2] = n2;
          hullSize--;
          n2 = q2;
        }
        if (e === start2) {
          while (q2 = hullPrev[e], orient2d(x5, y5, coords[2 * q2], coords[2 * q2 + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
            t = this._addTriangle(q2, i, e, -1, hullTri[e], hullTri[q2]);
            this._legalize(t + 2);
            hullTri[q2] = t;
            hullNext[e] = e;
            hullSize--;
            e = q2;
          }
        }
        this._hullStart = hullPrev[i] = e;
        hullNext[e] = hullPrev[n2] = i;
        hullNext[i] = n2;
        hullHash[this._hashKey(x5, y5)] = i;
        hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
      }
      this.hull = new Uint32Array(hullSize);
      for (let i = 0, e = this._hullStart; i < hullSize; i++) {
        this.hull[i] = e;
        e = hullNext[e];
      }
      this.triangles = this._triangles.subarray(0, this.trianglesLen);
      this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }
    _hashKey(x5, y5) {
      return Math.floor(pseudoAngle(x5 - this._cx, y5 - this._cy) * this._hashSize) % this._hashSize;
    }
    _legalize(a4) {
      const { _triangles: triangles, _halfedges: halfedges, coords } = this;
      let i = 0;
      let ar = 0;
      while (true) {
        const b10 = halfedges[a4];
        const a0 = a4 - a4 % 3;
        ar = a0 + (a4 + 2) % 3;
        if (b10 === -1) {
          if (i === 0) break;
          a4 = EDGE_STACK[--i];
          continue;
        }
        const b02 = b10 - b10 % 3;
        const al = a0 + (a4 + 1) % 3;
        const bl = b02 + (b10 + 2) % 3;
        const p02 = triangles[ar];
        const pr = triangles[a4];
        const pl = triangles[al];
        const p1 = triangles[bl];
        const illegal = inCircle(
          coords[2 * p02],
          coords[2 * p02 + 1],
          coords[2 * pr],
          coords[2 * pr + 1],
          coords[2 * pl],
          coords[2 * pl + 1],
          coords[2 * p1],
          coords[2 * p1 + 1]
        );
        if (illegal) {
          triangles[a4] = p1;
          triangles[b10] = p02;
          const hbl = halfedges[bl];
          if (hbl === -1) {
            let e = this._hullStart;
            do {
              if (this._hullTri[e] === bl) {
                this._hullTri[e] = a4;
                break;
              }
              e = this._hullPrev[e];
            } while (e !== this._hullStart);
          }
          this._link(a4, hbl);
          this._link(b10, halfedges[ar]);
          this._link(ar, bl);
          const br = b02 + (b10 + 1) % 3;
          if (i < EDGE_STACK.length) {
            EDGE_STACK[i++] = br;
          }
        } else {
          if (i === 0) break;
          a4 = EDGE_STACK[--i];
        }
      }
      return ar;
    }
    _link(a4, b10) {
      this._halfedges[a4] = b10;
      if (b10 !== -1) this._halfedges[b10] = a4;
    }
    // add a new triangle given vertex indices and adjacent half-edge ids
    _addTriangle(i0, i1, i2, a4, b10, c6) {
      const t = this.trianglesLen;
      this._triangles[t] = i0;
      this._triangles[t + 1] = i1;
      this._triangles[t + 2] = i2;
      this._link(t, a4);
      this._link(t + 1, b10);
      this._link(t + 2, c6);
      this.trianglesLen += 3;
      return t;
    }
  };
  function pseudoAngle(dx, dy) {
    const p = dx / (Math.abs(dx) + Math.abs(dy));
    return (dy > 0 ? 3 - p : 1 + p) / 4;
  }
  function dist(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
  }
  function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;
    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;
    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
  }
  function circumradius(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;
    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);
    const x5 = (ey * bl - dy * cl) * d;
    const y5 = (dx * cl - ex * bl) * d;
    return x5 * x5 + y5 * y5;
  }
  function circumcenter(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;
    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);
    const x5 = ax + (ey * bl - dy * cl) * d;
    const y5 = ay + (dx * cl - ex * bl) * d;
    return { x: x5, y: y5 };
  }
  function quicksort(ids, dists, left2, right2) {
    if (right2 - left2 <= 20) {
      for (let i = left2 + 1; i <= right2; i++) {
        const temp = ids[i];
        const tempDist = dists[temp];
        let j2 = i - 1;
        while (j2 >= left2 && dists[ids[j2]] > tempDist) ids[j2 + 1] = ids[j2--];
        ids[j2 + 1] = temp;
      }
    } else {
      const median2 = left2 + right2 >> 1;
      let i = left2 + 1;
      let j2 = right2;
      swap2(ids, median2, i);
      if (dists[ids[left2]] > dists[ids[right2]]) swap2(ids, left2, right2);
      if (dists[ids[i]] > dists[ids[right2]]) swap2(ids, i, right2);
      if (dists[ids[left2]] > dists[ids[i]]) swap2(ids, left2, i);
      const temp = ids[i];
      const tempDist = dists[temp];
      while (true) {
        do
          i++;
        while (dists[ids[i]] < tempDist);
        do
          j2--;
        while (dists[ids[j2]] > tempDist);
        if (j2 < i) break;
        swap2(ids, i, j2);
      }
      ids[left2 + 1] = ids[j2];
      ids[j2] = temp;
      if (right2 - i + 1 >= j2 - left2) {
        quicksort(ids, dists, i, right2);
        quicksort(ids, dists, left2, j2 - 1);
      } else {
        quicksort(ids, dists, left2, j2 - 1);
        quicksort(ids, dists, i, right2);
      }
    }
  }
  function swap2(arr, i, j2) {
    const tmp = arr[i];
    arr[i] = arr[j2];
    arr[j2] = tmp;
  }
  function defaultGetX(p) {
    return p[0];
  }
  function defaultGetY(p) {
    return p[1];
  }

  // node_modules/d3-delaunay/src/path.js
  var epsilon6 = 1e-6;
  var Path2 = class {
    constructor() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null;
      this._ = "";
    }
    moveTo(x5, y5) {
      this._ += `M${this._x0 = this._x1 = +x5},${this._y0 = this._y1 = +y5}`;
    }
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    }
    lineTo(x5, y5) {
      this._ += `L${this._x1 = +x5},${this._y1 = +y5}`;
    }
    arc(x5, y5, r) {
      x5 = +x5, y5 = +y5, r = +r;
      const x06 = x5 + r;
      const y06 = y5;
      if (r < 0) throw new Error("negative radius");
      if (this._x1 === null) this._ += `M${x06},${y06}`;
      else if (Math.abs(this._x1 - x06) > epsilon6 || Math.abs(this._y1 - y06) > epsilon6) this._ += "L" + x06 + "," + y06;
      if (!r) return;
      this._ += `A${r},${r},0,1,1,${x5 - r},${y5}A${r},${r},0,1,1,${this._x1 = x06},${this._y1 = y06}`;
    }
    rect(x5, y5, w, h2) {
      this._ += `M${this._x0 = this._x1 = +x5},${this._y0 = this._y1 = +y5}h${+w}v${+h2}h${-w}Z`;
    }
    value() {
      return this._ || null;
    }
  };

  // node_modules/d3-delaunay/src/polygon.js
  var Polygon = class {
    constructor() {
      this._ = [];
    }
    moveTo(x5, y5) {
      this._.push([x5, y5]);
    }
    closePath() {
      this._.push(this._[0].slice());
    }
    lineTo(x5, y5) {
      this._.push([x5, y5]);
    }
    value() {
      return this._.length ? this._ : null;
    }
  };

  // node_modules/d3-delaunay/src/voronoi.js
  var Voronoi = class {
    constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
      if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
      this.delaunay = delaunay;
      this._circumcenters = new Float64Array(delaunay.points.length * 2);
      this.vectors = new Float64Array(delaunay.points.length * 2);
      this.xmax = xmax, this.xmin = xmin;
      this.ymax = ymax, this.ymin = ymin;
      this._init();
    }
    update() {
      this.delaunay.update();
      this._init();
      return this;
    }
    _init() {
      const { delaunay: { points, hull, triangles }, vectors } = this;
      let bx, by;
      const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
      for (let i = 0, j2 = 0, n = triangles.length, x5, y5; i < n; i += 3, j2 += 2) {
        const t13 = triangles[i] * 2;
        const t22 = triangles[i + 1] * 2;
        const t32 = triangles[i + 2] * 2;
        const x13 = points[t13];
        const y13 = points[t13 + 1];
        const x22 = points[t22];
        const y22 = points[t22 + 1];
        const x32 = points[t32];
        const y32 = points[t32 + 1];
        const dx = x22 - x13;
        const dy = y22 - y13;
        const ex = x32 - x13;
        const ey = y32 - y13;
        const ab4 = (dx * ey - dy * ex) * 2;
        if (Math.abs(ab4) < 1e-9) {
          if (bx === void 0) {
            bx = by = 0;
            for (const i2 of hull) bx += points[i2 * 2], by += points[i2 * 2 + 1];
            bx /= hull.length, by /= hull.length;
          }
          const a4 = 1e9 * Math.sign((bx - x13) * ey - (by - y13) * ex);
          x5 = (x13 + x32) / 2 - a4 * ey;
          y5 = (y13 + y32) / 2 + a4 * ex;
        } else {
          const d = 1 / ab4;
          const bl = dx * dx + dy * dy;
          const cl = ex * ex + ey * ey;
          x5 = x13 + (ey * bl - dy * cl) * d;
          y5 = y13 + (dx * cl - ex * bl) * d;
        }
        circumcenters[j2] = x5;
        circumcenters[j2 + 1] = y5;
      }
      let h2 = hull[hull.length - 1];
      let p02, p1 = h2 * 4;
      let x06, x12 = points[2 * h2];
      let y06, y12 = points[2 * h2 + 1];
      vectors.fill(0);
      for (let i = 0; i < hull.length; ++i) {
        h2 = hull[i];
        p02 = p1, x06 = x12, y06 = y12;
        p1 = h2 * 4, x12 = points[2 * h2], y12 = points[2 * h2 + 1];
        vectors[p02 + 2] = vectors[p1] = y06 - y12;
        vectors[p02 + 3] = vectors[p1 + 1] = x12 - x06;
      }
    }
    render(context) {
      const buffer = context == null ? context = new Path2() : void 0;
      const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
      if (hull.length <= 1) return null;
      for (let i = 0, n = halfedges.length; i < n; ++i) {
        const j2 = halfedges[i];
        if (j2 < i) continue;
        const ti = Math.floor(i / 3) * 2;
        const tj = Math.floor(j2 / 3) * 2;
        const xi = circumcenters[ti];
        const yi = circumcenters[ti + 1];
        const xj = circumcenters[tj];
        const yj = circumcenters[tj + 1];
        this._renderSegment(xi, yi, xj, yj, context);
      }
      let h0, h1 = hull[hull.length - 1];
      for (let i = 0; i < hull.length; ++i) {
        h0 = h1, h1 = hull[i];
        const t = Math.floor(inedges[h1] / 3) * 2;
        const x5 = circumcenters[t];
        const y5 = circumcenters[t + 1];
        const v3 = h0 * 4;
        const p = this._project(x5, y5, vectors[v3 + 2], vectors[v3 + 3]);
        if (p) this._renderSegment(x5, y5, p[0], p[1], context);
      }
      return buffer && buffer.value();
    }
    renderBounds(context) {
      const buffer = context == null ? context = new Path2() : void 0;
      context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
      return buffer && buffer.value();
    }
    renderCell(i, context) {
      const buffer = context == null ? context = new Path2() : void 0;
      const points = this._clip(i);
      if (points === null || !points.length) return;
      context.moveTo(points[0], points[1]);
      let n = points.length;
      while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1) n -= 2;
      for (let i2 = 2; i2 < n; i2 += 2) {
        if (points[i2] !== points[i2 - 2] || points[i2 + 1] !== points[i2 - 1])
          context.lineTo(points[i2], points[i2 + 1]);
      }
      context.closePath();
      return buffer && buffer.value();
    }
    *cellPolygons() {
      const { delaunay: { points } } = this;
      for (let i = 0, n = points.length / 2; i < n; ++i) {
        const cell = this.cellPolygon(i);
        if (cell) cell.index = i, yield cell;
      }
    }
    cellPolygon(i) {
      const polygon = new Polygon();
      this.renderCell(i, polygon);
      return polygon.value();
    }
    _renderSegment(x06, y06, x12, y12, context) {
      let S2;
      const c0 = this._regioncode(x06, y06);
      const c1 = this._regioncode(x12, y12);
      if (c0 === 0 && c1 === 0) {
        context.moveTo(x06, y06);
        context.lineTo(x12, y12);
      } else if (S2 = this._clipSegment(x06, y06, x12, y12, c0, c1)) {
        context.moveTo(S2[0], S2[1]);
        context.lineTo(S2[2], S2[3]);
      }
    }
    contains(i, x5, y5) {
      if ((x5 = +x5, x5 !== x5) || (y5 = +y5, y5 !== y5)) return false;
      return this.delaunay._step(i, x5, y5) === i;
    }
    *neighbors(i) {
      const ci = this._clip(i);
      if (ci) for (const j2 of this.delaunay.neighbors(i)) {
        const cj = this._clip(j2);
        if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
          for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
            if (ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
              yield j2;
              break loop;
            }
          }
        }
      }
    }
    _cell(i) {
      const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
      const e0 = inedges[i];
      if (e0 === -1) return null;
      const points = [];
      let e = e0;
      do {
        const t = Math.floor(e / 3);
        points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
        e = e % 3 === 2 ? e - 2 : e + 1;
        if (triangles[e] !== i) break;
        e = halfedges[e];
      } while (e !== e0 && e !== -1);
      return points;
    }
    _clip(i) {
      if (i === 0 && this.delaunay.hull.length === 1) {
        return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
      }
      const points = this._cell(i);
      if (points === null) return null;
      const { vectors: V2 } = this;
      const v3 = i * 4;
      return this._simplify(V2[v3] || V2[v3 + 1] ? this._clipInfinite(i, points, V2[v3], V2[v3 + 1], V2[v3 + 2], V2[v3 + 3]) : this._clipFinite(i, points));
    }
    _clipFinite(i, points) {
      const n = points.length;
      let P2 = null;
      let x06, y06, x12 = points[n - 2], y12 = points[n - 1];
      let c0, c1 = this._regioncode(x12, y12);
      let e0, e1 = 0;
      for (let j2 = 0; j2 < n; j2 += 2) {
        x06 = x12, y06 = y12, x12 = points[j2], y12 = points[j2 + 1];
        c0 = c1, c1 = this._regioncode(x12, y12);
        if (c0 === 0 && c1 === 0) {
          e0 = e1, e1 = 0;
          if (P2) P2.push(x12, y12);
          else P2 = [x12, y12];
        } else {
          let S2, sx0, sy0, sx1, sy1;
          if (c0 === 0) {
            if ((S2 = this._clipSegment(x06, y06, x12, y12, c0, c1)) === null) continue;
            [sx0, sy0, sx1, sy1] = S2;
          } else {
            if ((S2 = this._clipSegment(x12, y12, x06, y06, c1, c0)) === null) continue;
            [sx1, sy1, sx0, sy0] = S2;
            e0 = e1, e1 = this._edgecode(sx0, sy0);
            if (e0 && e1) this._edge(i, e0, e1, P2, P2.length);
            if (P2) P2.push(sx0, sy0);
            else P2 = [sx0, sy0];
          }
          e0 = e1, e1 = this._edgecode(sx1, sy1);
          if (e0 && e1) this._edge(i, e0, e1, P2, P2.length);
          if (P2) P2.push(sx1, sy1);
          else P2 = [sx1, sy1];
        }
      }
      if (P2) {
        e0 = e1, e1 = this._edgecode(P2[0], P2[1]);
        if (e0 && e1) this._edge(i, e0, e1, P2, P2.length);
      } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
        return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
      }
      return P2;
    }
    _clipSegment(x06, y06, x12, y12, c0, c1) {
      const flip = c0 < c1;
      if (flip) [x06, y06, x12, y12, c0, c1] = [x12, y12, x06, y06, c1, c0];
      while (true) {
        if (c0 === 0 && c1 === 0) return flip ? [x12, y12, x06, y06] : [x06, y06, x12, y12];
        if (c0 & c1) return null;
        let x5, y5, c6 = c0 || c1;
        if (c6 & 8) x5 = x06 + (x12 - x06) * (this.ymax - y06) / (y12 - y06), y5 = this.ymax;
        else if (c6 & 4) x5 = x06 + (x12 - x06) * (this.ymin - y06) / (y12 - y06), y5 = this.ymin;
        else if (c6 & 2) y5 = y06 + (y12 - y06) * (this.xmax - x06) / (x12 - x06), x5 = this.xmax;
        else y5 = y06 + (y12 - y06) * (this.xmin - x06) / (x12 - x06), x5 = this.xmin;
        if (c0) x06 = x5, y06 = y5, c0 = this._regioncode(x06, y06);
        else x12 = x5, y12 = y5, c1 = this._regioncode(x12, y12);
      }
    }
    _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
      let P2 = Array.from(points), p;
      if (p = this._project(P2[0], P2[1], vx0, vy0)) P2.unshift(p[0], p[1]);
      if (p = this._project(P2[P2.length - 2], P2[P2.length - 1], vxn, vyn)) P2.push(p[0], p[1]);
      if (P2 = this._clipFinite(i, P2)) {
        for (let j2 = 0, n = P2.length, c0, c1 = this._edgecode(P2[n - 2], P2[n - 1]); j2 < n; j2 += 2) {
          c0 = c1, c1 = this._edgecode(P2[j2], P2[j2 + 1]);
          if (c0 && c1) j2 = this._edge(i, c0, c1, P2, j2), n = P2.length;
        }
      } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
        P2 = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
      }
      return P2;
    }
    _edge(i, e0, e1, P2, j2) {
      while (e0 !== e1) {
        let x5, y5;
        switch (e0) {
          case 5:
            e0 = 4;
            continue;
          // top-left
          case 4:
            e0 = 6, x5 = this.xmax, y5 = this.ymin;
            break;
          // top
          case 6:
            e0 = 2;
            continue;
          // top-right
          case 2:
            e0 = 10, x5 = this.xmax, y5 = this.ymax;
            break;
          // right
          case 10:
            e0 = 8;
            continue;
          // bottom-right
          case 8:
            e0 = 9, x5 = this.xmin, y5 = this.ymax;
            break;
          // bottom
          case 9:
            e0 = 1;
            continue;
          // bottom-left
          case 1:
            e0 = 5, x5 = this.xmin, y5 = this.ymin;
            break;
        }
        if ((P2[j2] !== x5 || P2[j2 + 1] !== y5) && this.contains(i, x5, y5)) {
          P2.splice(j2, 0, x5, y5), j2 += 2;
        }
      }
      return j2;
    }
    _project(x06, y06, vx, vy) {
      let t = Infinity, c6, x5, y5;
      if (vy < 0) {
        if (y06 <= this.ymin) return null;
        if ((c6 = (this.ymin - y06) / vy) < t) y5 = this.ymin, x5 = x06 + (t = c6) * vx;
      } else if (vy > 0) {
        if (y06 >= this.ymax) return null;
        if ((c6 = (this.ymax - y06) / vy) < t) y5 = this.ymax, x5 = x06 + (t = c6) * vx;
      }
      if (vx > 0) {
        if (x06 >= this.xmax) return null;
        if ((c6 = (this.xmax - x06) / vx) < t) x5 = this.xmax, y5 = y06 + (t = c6) * vy;
      } else if (vx < 0) {
        if (x06 <= this.xmin) return null;
        if ((c6 = (this.xmin - x06) / vx) < t) x5 = this.xmin, y5 = y06 + (t = c6) * vy;
      }
      return [x5, y5];
    }
    _edgecode(x5, y5) {
      return (x5 === this.xmin ? 1 : x5 === this.xmax ? 2 : 0) | (y5 === this.ymin ? 4 : y5 === this.ymax ? 8 : 0);
    }
    _regioncode(x5, y5) {
      return (x5 < this.xmin ? 1 : x5 > this.xmax ? 2 : 0) | (y5 < this.ymin ? 4 : y5 > this.ymax ? 8 : 0);
    }
    _simplify(P2) {
      if (P2 && P2.length > 4) {
        for (let i = 0; i < P2.length; i += 2) {
          const j2 = (i + 2) % P2.length, k3 = (i + 4) % P2.length;
          if (P2[i] === P2[j2] && P2[j2] === P2[k3] || P2[i + 1] === P2[j2 + 1] && P2[j2 + 1] === P2[k3 + 1]) {
            P2.splice(j2, 2), i -= 2;
          }
        }
        if (!P2.length) P2 = null;
      }
      return P2;
    }
  };

  // node_modules/d3-delaunay/src/delaunay.js
  var tau4 = 2 * Math.PI;
  var pow = Math.pow;
  function pointX(p) {
    return p[0];
  }
  function pointY(p) {
    return p[1];
  }
  function collinear2(d) {
    const { triangles, coords } = d;
    for (let i = 0; i < triangles.length; i += 3) {
      const a4 = 2 * triangles[i], b10 = 2 * triangles[i + 1], c6 = 2 * triangles[i + 2], cross2 = (coords[c6] - coords[a4]) * (coords[b10 + 1] - coords[a4 + 1]) - (coords[b10] - coords[a4]) * (coords[c6 + 1] - coords[a4 + 1]);
      if (cross2 > 1e-10) return false;
    }
    return true;
  }
  function jitter(x5, y5, r) {
    return [x5 + Math.sin(x5 + y5) * r, y5 + Math.cos(x5 - y5) * r];
  }
  var Delaunay = class _Delaunay {
    static from(points, fx = pointX, fy = pointY, that) {
      return new _Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
    }
    constructor(points) {
      this._delaunator = new Delaunator(points);
      this.inedges = new Int32Array(points.length / 2);
      this._hullIndex = new Int32Array(points.length / 2);
      this.points = this._delaunator.coords;
      this._init();
    }
    update() {
      this._delaunator.update();
      this._init();
      return this;
    }
    _init() {
      const d = this._delaunator, points = this.points;
      if (d.hull && d.hull.length > 2 && collinear2(d)) {
        this.collinear = Int32Array.from({ length: points.length / 2 }, (_25, i) => i).sort((i, j2) => points[2 * i] - points[2 * j2] || points[2 * i + 1] - points[2 * j2 + 1]);
        const e = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]], r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
        for (let i = 0, n = points.length / 2; i < n; ++i) {
          const p = jitter(points[2 * i], points[2 * i + 1], r);
          points[2 * i] = p[0];
          points[2 * i + 1] = p[1];
        }
        this._delaunator = new Delaunator(points);
      } else {
        delete this.collinear;
      }
      const halfedges = this.halfedges = this._delaunator.halfedges;
      const hull = this.hull = this._delaunator.hull;
      const triangles = this.triangles = this._delaunator.triangles;
      const inedges = this.inedges.fill(-1);
      const hullIndex = this._hullIndex.fill(-1);
      for (let e = 0, n = halfedges.length; e < n; ++e) {
        const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
        if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
      }
      for (let i = 0, n = hull.length; i < n; ++i) {
        hullIndex[hull[i]] = i;
      }
      if (hull.length <= 2 && hull.length > 0) {
        this.triangles = new Int32Array(3).fill(-1);
        this.halfedges = new Int32Array(3).fill(-1);
        this.triangles[0] = hull[0];
        inedges[hull[0]] = 1;
        if (hull.length === 2) {
          inedges[hull[1]] = 0;
          this.triangles[1] = hull[1];
          this.triangles[2] = hull[1];
        }
      }
    }
    voronoi(bounds) {
      return new Voronoi(this, bounds);
    }
    *neighbors(i) {
      const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear3 } = this;
      if (collinear3) {
        const l2 = collinear3.indexOf(i);
        if (l2 > 0) yield collinear3[l2 - 1];
        if (l2 < collinear3.length - 1) yield collinear3[l2 + 1];
        return;
      }
      const e0 = inedges[i];
      if (e0 === -1) return;
      let e = e0, p02 = -1;
      do {
        yield p02 = triangles[e];
        e = e % 3 === 2 ? e - 2 : e + 1;
        if (triangles[e] !== i) return;
        e = halfedges[e];
        if (e === -1) {
          const p = hull[(_hullIndex[i] + 1) % hull.length];
          if (p !== p02) yield p;
          return;
        }
      } while (e !== e0);
    }
    find(x5, y5, i = 0) {
      if ((x5 = +x5, x5 !== x5) || (y5 = +y5, y5 !== y5)) return -1;
      const i0 = i;
      let c6;
      while ((c6 = this._step(i, x5, y5)) >= 0 && c6 !== i && c6 !== i0) i = c6;
      return c6;
    }
    _step(i, x5, y5) {
      const { inedges, hull, _hullIndex, halfedges, triangles, points } = this;
      if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
      let c6 = i;
      let dc = pow(x5 - points[i * 2], 2) + pow(y5 - points[i * 2 + 1], 2);
      const e0 = inedges[i];
      let e = e0;
      do {
        let t = triangles[e];
        const dt2 = pow(x5 - points[t * 2], 2) + pow(y5 - points[t * 2 + 1], 2);
        if (dt2 < dc) dc = dt2, c6 = t;
        e = e % 3 === 2 ? e - 2 : e + 1;
        if (triangles[e] !== i) break;
        e = halfedges[e];
        if (e === -1) {
          e = hull[(_hullIndex[i] + 1) % hull.length];
          if (e !== t) {
            if (pow(x5 - points[e * 2], 2) + pow(y5 - points[e * 2 + 1], 2) < dc) return e;
          }
          break;
        }
      } while (e !== e0);
      return c6;
    }
    render(context) {
      const buffer = context == null ? context = new Path2() : void 0;
      const { points, halfedges, triangles } = this;
      for (let i = 0, n = halfedges.length; i < n; ++i) {
        const j2 = halfedges[i];
        if (j2 < i) continue;
        const ti = triangles[i] * 2;
        const tj = triangles[j2] * 2;
        context.moveTo(points[ti], points[ti + 1]);
        context.lineTo(points[tj], points[tj + 1]);
      }
      this.renderHull(context);
      return buffer && buffer.value();
    }
    renderPoints(context, r) {
      if (r === void 0 && (!context || typeof context.moveTo !== "function")) r = context, context = null;
      r = r == void 0 ? 2 : +r;
      const buffer = context == null ? context = new Path2() : void 0;
      const { points } = this;
      for (let i = 0, n = points.length; i < n; i += 2) {
        const x5 = points[i], y5 = points[i + 1];
        context.moveTo(x5 + r, y5);
        context.arc(x5, y5, r, 0, tau4);
      }
      return buffer && buffer.value();
    }
    renderHull(context) {
      const buffer = context == null ? context = new Path2() : void 0;
      const { hull, points } = this;
      const h2 = hull[0] * 2, n = hull.length;
      context.moveTo(points[h2], points[h2 + 1]);
      for (let i = 1; i < n; ++i) {
        const h3 = 2 * hull[i];
        context.lineTo(points[h3], points[h3 + 1]);
      }
      context.closePath();
      return buffer && buffer.value();
    }
    hullPolygon() {
      const polygon = new Polygon();
      this.renderHull(polygon);
      return polygon.value();
    }
    renderTriangle(i, context) {
      const buffer = context == null ? context = new Path2() : void 0;
      const { points, triangles } = this;
      const t03 = triangles[i *= 3] * 2;
      const t13 = triangles[i + 1] * 2;
      const t22 = triangles[i + 2] * 2;
      context.moveTo(points[t03], points[t03 + 1]);
      context.lineTo(points[t13], points[t13 + 1]);
      context.lineTo(points[t22], points[t22 + 1]);
      context.closePath();
      return buffer && buffer.value();
    }
    *trianglePolygons() {
      const { triangles } = this;
      for (let i = 0, n = triangles.length / 3; i < n; ++i) {
        yield this.trianglePolygon(i);
      }
    }
    trianglePolygon(i) {
      const polygon = new Polygon();
      this.renderTriangle(i, polygon);
      return polygon.value();
    }
  };
  function flatArray(points, fx, fy, that) {
    const n = points.length;
    const array4 = new Float64Array(n * 2);
    for (let i = 0; i < n; ++i) {
      const p = points[i];
      array4[i * 2] = fx.call(that, p, i, points);
      array4[i * 2 + 1] = fy.call(that, p, i, points);
    }
    return array4;
  }
  function* flatIterable(points, fx, fy, that) {
    let i = 0;
    for (const p of points) {
      yield fx.call(that, p, i, points);
      yield fy.call(that, p, i, points);
      ++i;
    }
  }

  // node_modules/d3-dsv/src/dsv.js
  var EOL = {};
  var EOF = {};
  var QUOTE = 34;
  var NEWLINE = 10;
  var RETURN = 13;
  function objectConverter(columns) {
    return new Function("d", "return {" + columns.map(function(name, i) {
      return JSON.stringify(name) + ": d[" + i + '] || ""';
    }).join(",") + "}");
  }
  function customConverter(columns, f) {
    var object2 = objectConverter(columns);
    return function(row, i) {
      return f(object2(row), i, columns);
    };
  }
  function inferColumns(rows) {
    var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
    rows.forEach(function(row) {
      for (var column in row) {
        if (!(column in columnSet)) {
          columns.push(columnSet[column] = column);
        }
      }
    });
    return columns;
  }
  function pad(value, width2) {
    var s2 = value + "", length3 = s2.length;
    return length3 < width2 ? new Array(width2 - length3 + 1).join(0) + s2 : s2;
  }
  function formatYear(year) {
    return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
  }
  function formatDate(date2) {
    var hours = date2.getUTCHours(), minutes = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();
    return isNaN(date2) ? "Invalid Date" : formatYear(date2.getUTCFullYear(), 4) + "-" + pad(date2.getUTCMonth() + 1, 2) + "-" + pad(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds2, 2) + "." + pad(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds2, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
  }
  function dsv_default(delimiter) {
    var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
    function parse(text2, f) {
      var convert, columns, rows = parseRows(text2, function(row, i) {
        if (convert) return convert(row, i - 1);
        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
      });
      rows.columns = columns || [];
      return rows;
    }
    function parseRows(text2, f) {
      var rows = [], N2 = text2.length, I2 = 0, n = 0, t, eof = N2 <= 0, eol = false;
      if (text2.charCodeAt(N2 - 1) === NEWLINE) --N2;
      if (text2.charCodeAt(N2 - 1) === RETURN) --N2;
      function token() {
        if (eof) return EOF;
        if (eol) return eol = false, EOL;
        var i, j2 = I2, c6;
        if (text2.charCodeAt(j2) === QUOTE) {
          while (I2++ < N2 && text2.charCodeAt(I2) !== QUOTE || text2.charCodeAt(++I2) === QUOTE) ;
          if ((i = I2) >= N2) eof = true;
          else if ((c6 = text2.charCodeAt(I2++)) === NEWLINE) eol = true;
          else if (c6 === RETURN) {
            eol = true;
            if (text2.charCodeAt(I2) === NEWLINE) ++I2;
          }
          return text2.slice(j2 + 1, i - 1).replace(/""/g, '"');
        }
        while (I2 < N2) {
          if ((c6 = text2.charCodeAt(i = I2++)) === NEWLINE) eol = true;
          else if (c6 === RETURN) {
            eol = true;
            if (text2.charCodeAt(I2) === NEWLINE) ++I2;
          } else if (c6 !== DELIMITER) continue;
          return text2.slice(j2, i);
        }
        return eof = true, text2.slice(j2, N2);
      }
      while ((t = token()) !== EOF) {
        var row = [];
        while (t !== EOL && t !== EOF) row.push(t), t = token();
        if (f && (row = f(row, n++)) == null) continue;
        rows.push(row);
      }
      return rows;
    }
    function preformatBody(rows, columns) {
      return rows.map(function(row) {
        return columns.map(function(column) {
          return formatValue(row[column]);
        }).join(delimiter);
      });
    }
    function format2(rows, columns) {
      if (columns == null) columns = inferColumns(rows);
      return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
    }
    function formatBody(rows, columns) {
      if (columns == null) columns = inferColumns(rows);
      return preformatBody(rows, columns).join("\n");
    }
    function formatRows(rows) {
      return rows.map(formatRow).join("\n");
    }
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(value) {
      return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
    }
    return {
      parse,
      parseRows,
      format: format2,
      formatBody,
      formatRows,
      formatRow,
      formatValue
    };
  }

  // node_modules/d3-dsv/src/csv.js
  var csv = dsv_default(",");
  var csvParse = csv.parse;
  var csvParseRows = csv.parseRows;
  var csvFormat = csv.format;
  var csvFormatBody = csv.formatBody;
  var csvFormatRows = csv.formatRows;
  var csvFormatRow = csv.formatRow;
  var csvFormatValue = csv.formatValue;

  // node_modules/d3-dsv/src/tsv.js
  var tsv = dsv_default("	");
  var tsvParse = tsv.parse;
  var tsvParseRows = tsv.parseRows;
  var tsvFormat = tsv.format;
  var tsvFormatBody = tsv.formatBody;
  var tsvFormatRows = tsv.formatRows;
  var tsvFormatRow = tsv.formatRow;
  var tsvFormatValue = tsv.formatValue;

  // node_modules/d3-dsv/src/autoType.js
  function autoType(object2) {
    for (var key in object2) {
      var value = object2[key].trim(), number5, m4;
      if (!value) value = null;
      else if (value === "true") value = true;
      else if (value === "false") value = false;
      else if (value === "NaN") value = NaN;
      else if (!isNaN(number5 = +value)) value = number5;
      else if (m4 = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
        if (fixtz && !!m4[4] && !m4[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
        value = new Date(value);
      } else continue;
      object2[key] = value;
    }
    return object2;
  }
  var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

  // node_modules/d3-fetch/src/blob.js
  function responseBlob(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    return response.blob();
  }
  function blob_default(input, init3) {
    return fetch(input, init3).then(responseBlob);
  }

  // node_modules/d3-fetch/src/buffer.js
  function responseArrayBuffer(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    return response.arrayBuffer();
  }
  function buffer_default(input, init3) {
    return fetch(input, init3).then(responseArrayBuffer);
  }

  // node_modules/d3-fetch/src/text.js
  function responseText(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    return response.text();
  }
  function text_default3(input, init3) {
    return fetch(input, init3).then(responseText);
  }

  // node_modules/d3-fetch/src/dsv.js
  function dsvParse(parse) {
    return function(input, init3, row) {
      if (arguments.length === 2 && typeof init3 === "function") row = init3, init3 = void 0;
      return text_default3(input, init3).then(function(response) {
        return parse(response, row);
      });
    };
  }
  function dsv(delimiter, input, init3, row) {
    if (arguments.length === 3 && typeof init3 === "function") row = init3, init3 = void 0;
    var format2 = dsv_default(delimiter);
    return text_default3(input, init3).then(function(response) {
      return format2.parse(response, row);
    });
  }
  var csv2 = dsvParse(csvParse);
  var tsv2 = dsvParse(tsvParse);

  // node_modules/d3-fetch/src/image.js
  function image_default(input, init3) {
    return new Promise(function(resolve, reject) {
      var image = new Image();
      for (var key in init3) image[key] = init3[key];
      image.onerror = reject;
      image.onload = function() {
        resolve(image);
      };
      image.src = input;
    });
  }

  // node_modules/d3-fetch/src/json.js
  function responseJson(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    if (response.status === 204 || response.status === 205) return;
    return response.json();
  }
  function json_default(input, init3) {
    return fetch(input, init3).then(responseJson);
  }

  // node_modules/d3-fetch/src/xml.js
  function parser(type2) {
    return (input, init3) => text_default3(input, init3).then((text2) => new DOMParser().parseFromString(text2, type2));
  }
  var xml_default = parser("application/xml");
  var html2 = parser("text/html");
  var svg = parser("image/svg+xml");

  // node_modules/d3-force/src/center.js
  function center_default(x5, y5) {
    var nodes, strength = 1;
    if (x5 == null) x5 = 0;
    if (y5 == null) y5 = 0;
    function force() {
      var i, n = nodes.length, node, sx = 0, sy = 0;
      for (i = 0; i < n; ++i) {
        node = nodes[i], sx += node.x, sy += node.y;
      }
      for (sx = (sx / n - x5) * strength, sy = (sy / n - y5) * strength, i = 0; i < n; ++i) {
        node = nodes[i], node.x -= sx, node.y -= sy;
      }
    }
    force.initialize = function(_25) {
      nodes = _25;
    };
    force.x = function(_25) {
      return arguments.length ? (x5 = +_25, force) : x5;
    };
    force.y = function(_25) {
      return arguments.length ? (y5 = +_25, force) : y5;
    };
    force.strength = function(_25) {
      return arguments.length ? (strength = +_25, force) : strength;
    };
    return force;
  }

  // node_modules/d3-quadtree/src/add.js
  function add_default(d) {
    const x5 = +this._x.call(null, d), y5 = +this._y.call(null, d);
    return add(this.cover(x5, y5), x5, y5, d);
  }
  function add(tree, x5, y5, d) {
    if (isNaN(x5) || isNaN(y5)) return tree;
    var parent, node = tree._root, leaf = { data: d }, x06 = tree._x0, y06 = tree._y0, x12 = tree._x1, y12 = tree._y1, xm, ym, xp, yp, right2, bottom2, i, j2;
    if (!node) return tree._root = leaf, tree;
    while (node.length) {
      if (right2 = x5 >= (xm = (x06 + x12) / 2)) x06 = xm;
      else x12 = xm;
      if (bottom2 = y5 >= (ym = (y06 + y12) / 2)) y06 = ym;
      else y12 = ym;
      if (parent = node, !(node = node[i = bottom2 << 1 | right2])) return parent[i] = leaf, tree;
    }
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    if (x5 === xp && y5 === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
    do {
      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
      if (right2 = x5 >= (xm = (x06 + x12) / 2)) x06 = xm;
      else x12 = xm;
      if (bottom2 = y5 >= (ym = (y06 + y12) / 2)) y06 = ym;
      else y12 = ym;
    } while ((i = bottom2 << 1 | right2) === (j2 = (yp >= ym) << 1 | xp >= xm));
    return parent[j2] = node, parent[i] = leaf, tree;
  }
  function addAll(data2) {
    var d, i, n = data2.length, x5, y5, xz = new Array(n), yz = new Array(n), x06 = Infinity, y06 = Infinity, x12 = -Infinity, y12 = -Infinity;
    for (i = 0; i < n; ++i) {
      if (isNaN(x5 = +this._x.call(null, d = data2[i])) || isNaN(y5 = +this._y.call(null, d))) continue;
      xz[i] = x5;
      yz[i] = y5;
      if (x5 < x06) x06 = x5;
      if (x5 > x12) x12 = x5;
      if (y5 < y06) y06 = y5;
      if (y5 > y12) y12 = y5;
    }
    if (x06 > x12 || y06 > y12) return this;
    this.cover(x06, y06).cover(x12, y12);
    for (i = 0; i < n; ++i) {
      add(this, xz[i], yz[i], data2[i]);
    }
    return this;
  }

  // node_modules/d3-quadtree/src/cover.js
  function cover_default(x5, y5) {
    if (isNaN(x5 = +x5) || isNaN(y5 = +y5)) return this;
    var x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1;
    if (isNaN(x06)) {
      x12 = (x06 = Math.floor(x5)) + 1;
      y12 = (y06 = Math.floor(y5)) + 1;
    } else {
      var z2 = x12 - x06 || 1, node = this._root, parent, i;
      while (x06 > x5 || x5 >= x12 || y06 > y5 || y5 >= y12) {
        i = (y5 < y06) << 1 | x5 < x06;
        parent = new Array(4), parent[i] = node, node = parent, z2 *= 2;
        switch (i) {
          case 0:
            x12 = x06 + z2, y12 = y06 + z2;
            break;
          case 1:
            x06 = x12 - z2, y12 = y06 + z2;
            break;
          case 2:
            x12 = x06 + z2, y06 = y12 - z2;
            break;
          case 3:
            x06 = x12 - z2, y06 = y12 - z2;
            break;
        }
      }
      if (this._root && this._root.length) this._root = node;
    }
    this._x0 = x06;
    this._y0 = y06;
    this._x1 = x12;
    this._y1 = y12;
    return this;
  }

  // node_modules/d3-quadtree/src/data.js
  function data_default2() {
    var data2 = [];
    this.visit(function(node) {
      if (!node.length) do
        data2.push(node.data);
      while (node = node.next);
    });
    return data2;
  }

  // node_modules/d3-quadtree/src/extent.js
  function extent_default(_25) {
    return arguments.length ? this.cover(+_25[0][0], +_25[0][1]).cover(+_25[1][0], +_25[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
  }

  // node_modules/d3-quadtree/src/quad.js
  function quad_default(node, x06, y06, x12, y12) {
    this.node = node;
    this.x0 = x06;
    this.y0 = y06;
    this.x1 = x12;
    this.y1 = y12;
  }

  // node_modules/d3-quadtree/src/find.js
  function find_default(x5, y5, radius) {
    var data2, x06 = this._x0, y06 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q2, i;
    if (node) quads.push(new quad_default(node, x06, y06, x32, y32));
    if (radius == null) radius = Infinity;
    else {
      x06 = x5 - radius, y06 = y5 - radius;
      x32 = x5 + radius, y32 = y5 + radius;
      radius *= radius;
    }
    while (q2 = quads.pop()) {
      if (!(node = q2.node) || (x12 = q2.x0) > x32 || (y12 = q2.y0) > y32 || (x22 = q2.x1) < x06 || (y22 = q2.y1) < y06) continue;
      if (node.length) {
        var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
        quads.push(
          new quad_default(node[3], xm, ym, x22, y22),
          new quad_default(node[2], x12, ym, xm, y22),
          new quad_default(node[1], xm, y12, x22, ym),
          new quad_default(node[0], x12, y12, xm, ym)
        );
        if (i = (y5 >= ym) << 1 | x5 >= xm) {
          q2 = quads[quads.length - 1];
          quads[quads.length - 1] = quads[quads.length - 1 - i];
          quads[quads.length - 1 - i] = q2;
        }
      } else {
        var dx = x5 - +this._x.call(null, node.data), dy = y5 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
        if (d2 < radius) {
          var d = Math.sqrt(radius = d2);
          x06 = x5 - d, y06 = y5 - d;
          x32 = x5 + d, y32 = y5 + d;
          data2 = node.data;
        }
      }
    }
    return data2;
  }

  // node_modules/d3-quadtree/src/remove.js
  function remove_default3(d) {
    if (isNaN(x5 = +this._x.call(null, d)) || isNaN(y5 = +this._y.call(null, d))) return this;
    var parent, node = this._root, retainer, previous, next2, x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1, x5, y5, xm, ym, right2, bottom2, i, j2;
    if (!node) return this;
    if (node.length) while (true) {
      if (right2 = x5 >= (xm = (x06 + x12) / 2)) x06 = xm;
      else x12 = xm;
      if (bottom2 = y5 >= (ym = (y06 + y12) / 2)) y06 = ym;
      else y12 = ym;
      if (!(parent = node, node = node[i = bottom2 << 1 | right2])) return this;
      if (!node.length) break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j2 = i;
    }
    while (node.data !== d) if (!(previous = node, node = node.next)) return this;
    if (next2 = node.next) delete node.next;
    if (previous) return next2 ? previous.next = next2 : delete previous.next, this;
    if (!parent) return this._root = next2, this;
    next2 ? parent[i] = next2 : delete parent[i];
    if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
      if (retainer) retainer[j2] = node;
      else this._root = node;
    }
    return this;
  }
  function removeAll(data2) {
    for (var i = 0, n = data2.length; i < n; ++i) this.remove(data2[i]);
    return this;
  }

  // node_modules/d3-quadtree/src/root.js
  function root_default() {
    return this._root;
  }

  // node_modules/d3-quadtree/src/size.js
  function size_default2() {
    var size2 = 0;
    this.visit(function(node) {
      if (!node.length) do
        ++size2;
      while (node = node.next);
    });
    return size2;
  }

  // node_modules/d3-quadtree/src/visit.js
  function visit_default(callback) {
    var quads = [], q2, node = this._root, child2, x06, y06, x12, y12;
    if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
    while (q2 = quads.pop()) {
      if (!callback(node = q2.node, x06 = q2.x0, y06 = q2.y0, x12 = q2.x1, y12 = q2.y1) && node.length) {
        var xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
        if (child2 = node[3]) quads.push(new quad_default(child2, xm, ym, x12, y12));
        if (child2 = node[2]) quads.push(new quad_default(child2, x06, ym, xm, y12));
        if (child2 = node[1]) quads.push(new quad_default(child2, xm, y06, x12, ym));
        if (child2 = node[0]) quads.push(new quad_default(child2, x06, y06, xm, ym));
      }
    }
    return this;
  }

  // node_modules/d3-quadtree/src/visitAfter.js
  function visitAfter_default(callback) {
    var quads = [], next2 = [], q2;
    if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
    while (q2 = quads.pop()) {
      var node = q2.node;
      if (node.length) {
        var child2, x06 = q2.x0, y06 = q2.y0, x12 = q2.x1, y12 = q2.y1, xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
        if (child2 = node[0]) quads.push(new quad_default(child2, x06, y06, xm, ym));
        if (child2 = node[1]) quads.push(new quad_default(child2, xm, y06, x12, ym));
        if (child2 = node[2]) quads.push(new quad_default(child2, x06, ym, xm, y12));
        if (child2 = node[3]) quads.push(new quad_default(child2, xm, ym, x12, y12));
      }
      next2.push(q2);
    }
    while (q2 = next2.pop()) {
      callback(q2.node, q2.x0, q2.y0, q2.x1, q2.y1);
    }
    return this;
  }

  // node_modules/d3-quadtree/src/x.js
  function defaultX2(d) {
    return d[0];
  }
  function x_default(_25) {
    return arguments.length ? (this._x = _25, this) : this._x;
  }

  // node_modules/d3-quadtree/src/y.js
  function defaultY2(d) {
    return d[1];
  }
  function y_default(_25) {
    return arguments.length ? (this._y = _25, this) : this._y;
  }

  // node_modules/d3-quadtree/src/quadtree.js
  function quadtree(nodes, x5, y5) {
    var tree = new Quadtree(x5 == null ? defaultX2 : x5, y5 == null ? defaultY2 : y5, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }
  function Quadtree(x5, y5, x06, y06, x12, y12) {
    this._x = x5;
    this._y = y5;
    this._x0 = x06;
    this._y0 = y06;
    this._x1 = x12;
    this._y1 = y12;
    this._root = void 0;
  }
  function leaf_copy(leaf) {
    var copy3 = { data: leaf.data }, next2 = copy3;
    while (leaf = leaf.next) next2 = next2.next = { data: leaf.data };
    return copy3;
  }
  var treeProto = quadtree.prototype = Quadtree.prototype;
  treeProto.copy = function() {
    var copy3 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child2;
    if (!node) return copy3;
    if (!node.length) return copy3._root = leaf_copy(node), copy3;
    nodes = [{ source: node, target: copy3._root = new Array(4) }];
    while (node = nodes.pop()) {
      for (var i = 0; i < 4; ++i) {
        if (child2 = node.source[i]) {
          if (child2.length) nodes.push({ source: child2, target: node.target[i] = new Array(4) });
          else node.target[i] = leaf_copy(child2);
        }
      }
    }
    return copy3;
  };
  treeProto.add = add_default;
  treeProto.addAll = addAll;
  treeProto.cover = cover_default;
  treeProto.data = data_default2;
  treeProto.extent = extent_default;
  treeProto.find = find_default;
  treeProto.remove = remove_default3;
  treeProto.removeAll = removeAll;
  treeProto.root = root_default;
  treeProto.size = size_default2;
  treeProto.visit = visit_default;
  treeProto.visitAfter = visitAfter_default;
  treeProto.x = x_default;
  treeProto.y = y_default;

  // node_modules/d3-force/src/constant.js
  function constant_default7(x5) {
    return function() {
      return x5;
    };
  }

  // node_modules/d3-force/src/jiggle.js
  function jiggle_default(random) {
    return (random() - 0.5) * 1e-6;
  }

  // node_modules/d3-force/src/collide.js
  function x(d) {
    return d.x + d.vx;
  }
  function y(d) {
    return d.y + d.vy;
  }
  function collide_default(radius) {
    var nodes, radii, random, strength = 1, iterations2 = 1;
    if (typeof radius !== "function") radius = constant_default7(radius == null ? 1 : +radius);
    function force() {
      var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
      for (var k3 = 0; k3 < iterations2; ++k3) {
        tree = quadtree(nodes, x, y).visitAfter(prepare);
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          ri = radii[node.index], ri2 = ri * ri;
          xi = node.x + node.vx;
          yi = node.y + node.vy;
          tree.visit(apply2);
        }
      }
      function apply2(quad, x06, y06, x12, y12) {
        var data2 = quad.data, rj = quad.r, r = ri + rj;
        if (data2) {
          if (data2.index > node.index) {
            var x5 = xi - data2.x - data2.vx, y5 = yi - data2.y - data2.vy, l2 = x5 * x5 + y5 * y5;
            if (l2 < r * r) {
              if (x5 === 0) x5 = jiggle_default(random), l2 += x5 * x5;
              if (y5 === 0) y5 = jiggle_default(random), l2 += y5 * y5;
              l2 = (r - (l2 = Math.sqrt(l2))) / l2 * strength;
              node.vx += (x5 *= l2) * (r = (rj *= rj) / (ri2 + rj));
              node.vy += (y5 *= l2) * r;
              data2.vx -= x5 * (r = 1 - r);
              data2.vy -= y5 * r;
            }
          }
          return;
        }
        return x06 > xi + r || x12 < xi - r || y06 > yi + r || y12 < yi - r;
      }
    }
    function prepare(quad) {
      if (quad.data) return quad.r = radii[quad.data.index];
      for (var i = quad.r = 0; i < 4; ++i) {
        if (quad[i] && quad[i].r > quad.r) {
          quad.r = quad[i].r;
        }
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length, node;
      radii = new Array(n);
      for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };
    force.iterations = function(_25) {
      return arguments.length ? (iterations2 = +_25, force) : iterations2;
    };
    force.strength = function(_25) {
      return arguments.length ? (strength = +_25, force) : strength;
    };
    force.radius = function(_25) {
      return arguments.length ? (radius = typeof _25 === "function" ? _25 : constant_default7(+_25), initialize(), force) : radius;
    };
    return force;
  }

  // node_modules/d3-force/src/link.js
  function index3(d) {
    return d.index;
  }
  function find2(nodeById, nodeId) {
    var node = nodeById.get(nodeId);
    if (!node) throw new Error("node not found: " + nodeId);
    return node;
  }
  function link_default(links) {
    var id2 = index3, strength = defaultStrength, strengths, distance = constant_default7(30), distances, nodes, count3, bias, random, iterations2 = 1;
    if (links == null) links = [];
    function defaultStrength(link4) {
      return 1 / Math.min(count3[link4.source.index], count3[link4.target.index]);
    }
    function force(alpha) {
      for (var k3 = 0, n = links.length; k3 < iterations2; ++k3) {
        for (var i = 0, link4, source2, target, x5, y5, l2, b10; i < n; ++i) {
          link4 = links[i], source2 = link4.source, target = link4.target;
          x5 = target.x + target.vx - source2.x - source2.vx || jiggle_default(random);
          y5 = target.y + target.vy - source2.y - source2.vy || jiggle_default(random);
          l2 = Math.sqrt(x5 * x5 + y5 * y5);
          l2 = (l2 - distances[i]) / l2 * alpha * strengths[i];
          x5 *= l2, y5 *= l2;
          target.vx -= x5 * (b10 = bias[i]);
          target.vy -= y5 * b10;
          source2.vx += x5 * (b10 = 1 - b10);
          source2.vy += y5 * b10;
        }
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length, m4 = links.length, nodeById = new Map(nodes.map((d, i2) => [id2(d, i2, nodes), d])), link4;
      for (i = 0, count3 = new Array(n); i < m4; ++i) {
        link4 = links[i], link4.index = i;
        if (typeof link4.source !== "object") link4.source = find2(nodeById, link4.source);
        if (typeof link4.target !== "object") link4.target = find2(nodeById, link4.target);
        count3[link4.source.index] = (count3[link4.source.index] || 0) + 1;
        count3[link4.target.index] = (count3[link4.target.index] || 0) + 1;
      }
      for (i = 0, bias = new Array(m4); i < m4; ++i) {
        link4 = links[i], bias[i] = count3[link4.source.index] / (count3[link4.source.index] + count3[link4.target.index]);
      }
      strengths = new Array(m4), initializeStrength();
      distances = new Array(m4), initializeDistance();
    }
    function initializeStrength() {
      if (!nodes) return;
      for (var i = 0, n = links.length; i < n; ++i) {
        strengths[i] = +strength(links[i], i, links);
      }
    }
    function initializeDistance() {
      if (!nodes) return;
      for (var i = 0, n = links.length; i < n; ++i) {
        distances[i] = +distance(links[i], i, links);
      }
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };
    force.links = function(_25) {
      return arguments.length ? (links = _25, initialize(), force) : links;
    };
    force.id = function(_25) {
      return arguments.length ? (id2 = _25, force) : id2;
    };
    force.iterations = function(_25) {
      return arguments.length ? (iterations2 = +_25, force) : iterations2;
    };
    force.strength = function(_25) {
      return arguments.length ? (strength = typeof _25 === "function" ? _25 : constant_default7(+_25), initializeStrength(), force) : strength;
    };
    force.distance = function(_25) {
      return arguments.length ? (distance = typeof _25 === "function" ? _25 : constant_default7(+_25), initializeDistance(), force) : distance;
    };
    return force;
  }

  // node_modules/d3-force/src/lcg.js
  var a = 1664525;
  var c = 1013904223;
  var m = 4294967296;
  function lcg_default() {
    let s2 = 1;
    return () => (s2 = (a * s2 + c) % m) / m;
  }

  // node_modules/d3-force/src/simulation.js
  function x2(d) {
    return d.x;
  }
  function y2(d) {
    return d.y;
  }
  var initialRadius = 10;
  var initialAngle = Math.PI * (3 - Math.sqrt(5));
  function simulation_default(nodes) {
    var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event2 = dispatch_default("tick", "end"), random = lcg_default();
    if (nodes == null) nodes = [];
    function step() {
      tick2();
      event2.call("tick", simulation);
      if (alpha < alphaMin) {
        stepper.stop();
        event2.call("end", simulation);
      }
    }
    function tick2(iterations2) {
      var i, n = nodes.length, node;
      if (iterations2 === void 0) iterations2 = 1;
      for (var k3 = 0; k3 < iterations2; ++k3) {
        alpha += (alphaTarget - alpha) * alphaDecay;
        forces.forEach(function(force) {
          force(alpha);
        });
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (node.fx == null) node.x += node.vx *= velocityDecay;
          else node.x = node.fx, node.vx = 0;
          if (node.fy == null) node.y += node.vy *= velocityDecay;
          else node.y = node.fy, node.vy = 0;
        }
      }
      return simulation;
    }
    function initializeNodes() {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.index = i;
        if (node.fx != null) node.x = node.fx;
        if (node.fy != null) node.y = node.fy;
        if (isNaN(node.x) || isNaN(node.y)) {
          var radius = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;
          node.x = radius * Math.cos(angle2);
          node.y = radius * Math.sin(angle2);
        }
        if (isNaN(node.vx) || isNaN(node.vy)) {
          node.vx = node.vy = 0;
        }
      }
    }
    function initializeForce(force) {
      if (force.initialize) force.initialize(nodes, random);
      return force;
    }
    initializeNodes();
    return simulation = {
      tick: tick2,
      restart: function() {
        return stepper.restart(step), simulation;
      },
      stop: function() {
        return stepper.stop(), simulation;
      },
      nodes: function(_25) {
        return arguments.length ? (nodes = _25, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
      },
      alpha: function(_25) {
        return arguments.length ? (alpha = +_25, simulation) : alpha;
      },
      alphaMin: function(_25) {
        return arguments.length ? (alphaMin = +_25, simulation) : alphaMin;
      },
      alphaDecay: function(_25) {
        return arguments.length ? (alphaDecay = +_25, simulation) : +alphaDecay;
      },
      alphaTarget: function(_25) {
        return arguments.length ? (alphaTarget = +_25, simulation) : alphaTarget;
      },
      velocityDecay: function(_25) {
        return arguments.length ? (velocityDecay = 1 - _25, simulation) : 1 - velocityDecay;
      },
      randomSource: function(_25) {
        return arguments.length ? (random = _25, forces.forEach(initializeForce), simulation) : random;
      },
      force: function(name, _25) {
        return arguments.length > 1 ? (_25 == null ? forces.delete(name) : forces.set(name, initializeForce(_25)), simulation) : forces.get(name);
      },
      find: function(x5, y5, radius) {
        var i = 0, n = nodes.length, dx, dy, d2, node, closest;
        if (radius == null) radius = Infinity;
        else radius *= radius;
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dx = x5 - node.x;
          dy = y5 - node.y;
          d2 = dx * dx + dy * dy;
          if (d2 < radius) closest = node, radius = d2;
        }
        return closest;
      },
      on: function(name, _25) {
        return arguments.length > 1 ? (event2.on(name, _25), simulation) : event2.on(name);
      }
    };
  }

  // node_modules/d3-force/src/manyBody.js
  function manyBody_default() {
    var nodes, node, random, alpha, strength = constant_default7(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
    function force(_25) {
      var i, n = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
      for (alpha = _25, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply2);
    }
    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length, node2;
      strengths = new Array(n);
      for (i = 0; i < n; ++i) node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
    }
    function accumulate(quad) {
      var strength2 = 0, q2, c6, weight = 0, x5, y5, i;
      if (quad.length) {
        for (x5 = y5 = i = 0; i < 4; ++i) {
          if ((q2 = quad[i]) && (c6 = Math.abs(q2.value))) {
            strength2 += q2.value, weight += c6, x5 += c6 * q2.x, y5 += c6 * q2.y;
          }
        }
        quad.x = x5 / weight;
        quad.y = y5 / weight;
      } else {
        q2 = quad;
        q2.x = q2.data.x;
        q2.y = q2.data.y;
        do
          strength2 += strengths[q2.data.index];
        while (q2 = q2.next);
      }
      quad.value = strength2;
    }
    function apply2(quad, x12, _25, x22) {
      if (!quad.value) return true;
      var x5 = quad.x - node.x, y5 = quad.y - node.y, w = x22 - x12, l2 = x5 * x5 + y5 * y5;
      if (w * w / theta2 < l2) {
        if (l2 < distanceMax2) {
          if (x5 === 0) x5 = jiggle_default(random), l2 += x5 * x5;
          if (y5 === 0) y5 = jiggle_default(random), l2 += y5 * y5;
          if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
          node.vx += x5 * quad.value * alpha / l2;
          node.vy += y5 * quad.value * alpha / l2;
        }
        return true;
      } else if (quad.length || l2 >= distanceMax2) return;
      if (quad.data !== node || quad.next) {
        if (x5 === 0) x5 = jiggle_default(random), l2 += x5 * x5;
        if (y5 === 0) y5 = jiggle_default(random), l2 += y5 * y5;
        if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
      }
      do
        if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l2;
          node.vx += x5 * w;
          node.vy += y5 * w;
        }
      while (quad = quad.next);
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };
    force.strength = function(_25) {
      return arguments.length ? (strength = typeof _25 === "function" ? _25 : constant_default7(+_25), initialize(), force) : strength;
    };
    force.distanceMin = function(_25) {
      return arguments.length ? (distanceMin2 = _25 * _25, force) : Math.sqrt(distanceMin2);
    };
    force.distanceMax = function(_25) {
      return arguments.length ? (distanceMax2 = _25 * _25, force) : Math.sqrt(distanceMax2);
    };
    force.theta = function(_25) {
      return arguments.length ? (theta2 = _25 * _25, force) : Math.sqrt(theta2);
    };
    return force;
  }

  // node_modules/d3-force/src/radial.js
  function radial_default(radius, x5, y5) {
    var nodes, strength = constant_default7(0.1), strengths, radiuses;
    if (typeof radius !== "function") radius = constant_default7(+radius);
    if (x5 == null) x5 = 0;
    if (y5 == null) y5 = 0;
    function force(alpha) {
      for (var i = 0, n = nodes.length; i < n; ++i) {
        var node = nodes[i], dx = node.x - x5 || 1e-6, dy = node.y - y5 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k3 = (radiuses[i] - r) * strengths[i] * alpha / r;
        node.vx += dx * k3;
        node.vy += dy * k3;
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length;
      strengths = new Array(n);
      radiuses = new Array(n);
      for (i = 0; i < n; ++i) {
        radiuses[i] = +radius(nodes[i], i, nodes);
        strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_25) {
      nodes = _25, initialize();
    };
    force.strength = function(_25) {
      return arguments.length ? (strength = typeof _25 === "function" ? _25 : constant_default7(+_25), initialize(), force) : strength;
    };
    force.radius = function(_25) {
      return arguments.length ? (radius = typeof _25 === "function" ? _25 : constant_default7(+_25), initialize(), force) : radius;
    };
    force.x = function(_25) {
      return arguments.length ? (x5 = +_25, force) : x5;
    };
    force.y = function(_25) {
      return arguments.length ? (y5 = +_25, force) : y5;
    };
    return force;
  }

  // node_modules/d3-force/src/x.js
  function x_default2(x5) {
    var strength = constant_default7(0.1), nodes, strengths, xz;
    if (typeof x5 !== "function") x5 = constant_default7(x5 == null ? 0 : +x5);
    function force(alpha) {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length;
      strengths = new Array(n);
      xz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(xz[i] = +x5(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_25) {
      nodes = _25;
      initialize();
    };
    force.strength = function(_25) {
      return arguments.length ? (strength = typeof _25 === "function" ? _25 : constant_default7(+_25), initialize(), force) : strength;
    };
    force.x = function(_25) {
      return arguments.length ? (x5 = typeof _25 === "function" ? _25 : constant_default7(+_25), initialize(), force) : x5;
    };
    return force;
  }

  // node_modules/d3-force/src/y.js
  function y_default2(y5) {
    var strength = constant_default7(0.1), nodes, strengths, yz;
    if (typeof y5 !== "function") y5 = constant_default7(y5 == null ? 0 : +y5);
    function force(alpha) {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length;
      strengths = new Array(n);
      yz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(yz[i] = +y5(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_25) {
      nodes = _25;
      initialize();
    };
    force.strength = function(_25) {
      return arguments.length ? (strength = typeof _25 === "function" ? _25 : constant_default7(+_25), initialize(), force) : strength;
    };
    force.y = function(_25) {
      return arguments.length ? (y5 = typeof _25 === "function" ? _25 : constant_default7(+_25), initialize(), force) : y5;
    };
    return force;
  }

  // node_modules/d3-format/src/formatDecimal.js
  function formatDecimal_default(x5) {
    return Math.abs(x5 = Math.round(x5)) >= 1e21 ? x5.toLocaleString("en").replace(/,/g, "") : x5.toString(10);
  }
  function formatDecimalParts(x5, p) {
    if ((i = (x5 = p ? x5.toExponential(p - 1) : x5.toExponential()).indexOf("e")) < 0) return null;
    var i, coefficient = x5.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x5.slice(i + 1)
    ];
  }

  // node_modules/d3-format/src/exponent.js
  function exponent_default(x5) {
    return x5 = formatDecimalParts(Math.abs(x5)), x5 ? x5[1] : NaN;
  }

  // node_modules/d3-format/src/formatGroup.js
  function formatGroup_default(grouping, thousands) {
    return function(value, width2) {
      var i = value.length, t = [], j2 = 0, g = grouping[0], length3 = 0;
      while (i > 0 && g > 0) {
        if (length3 + g + 1 > width2) g = Math.max(1, width2 - length3);
        t.push(value.substring(i -= g, i + g));
        if ((length3 += g + 1) > width2) break;
        g = grouping[j2 = (j2 + 1) % grouping.length];
      }
      return t.reverse().join(thousands);
    };
  }

  // node_modules/d3-format/src/formatNumerals.js
  function formatNumerals_default(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // node_modules/d3-format/src/formatSpecifier.js
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match2 = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match2;
    return new FormatSpecifier({
      fill: match2[1],
      align: match2[2],
      sign: match2[3],
      symbol: match2[4],
      zero: match2[5],
      width: match2[6],
      comma: match2[7],
      precision: match2[8] && match2[8].slice(1),
      trim: match2[9],
      type: match2[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // node_modules/d3-format/src/formatTrim.js
  function formatTrim_default(s2) {
    out: for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0) i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i]) break out;
          if (i0 > 0) i0 = 0;
          break;
      }
    }
    return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
  }

  // node_modules/d3-format/src/formatPrefixAuto.js
  var prefixExponent;
  function formatPrefixAuto_default(x5, p) {
    var d = formatDecimalParts(x5, p);
    if (!d) return x5 + "";
    var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x5, Math.max(0, p + i - 1))[0];
  }

  // node_modules/d3-format/src/formatRounded.js
  function formatRounded_default(x5, p) {
    var d = formatDecimalParts(x5, p);
    if (!d) return x5 + "";
    var coefficient = d[0], exponent2 = d[1];
    return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
  }

  // node_modules/d3-format/src/formatTypes.js
  var formatTypes_default = {
    "%": (x5, p) => (x5 * 100).toFixed(p),
    "b": (x5) => Math.round(x5).toString(2),
    "c": (x5) => x5 + "",
    "d": formatDecimal_default,
    "e": (x5, p) => x5.toExponential(p),
    "f": (x5, p) => x5.toFixed(p),
    "g": (x5, p) => x5.toPrecision(p),
    "o": (x5) => Math.round(x5).toString(8),
    "p": (x5, p) => formatRounded_default(x5 * 100, p),
    "r": formatRounded_default,
    "s": formatPrefixAuto_default,
    "X": (x5) => Math.round(x5).toString(16).toUpperCase(),
    "x": (x5) => Math.round(x5).toString(16)
  };

  // node_modules/d3-format/src/identity.js
  function identity_default2(x5) {
    return x5;
  }

  // node_modules/d3-format/src/locale.js
  var map3 = Array.prototype.map;
  var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function locale_default(locale4) {
    var group2 = locale4.grouping === void 0 || locale4.thousands === void 0 ? identity_default2 : formatGroup_default(map3.call(locale4.grouping, Number), locale4.thousands + ""), currencyPrefix = locale4.currency === void 0 ? "" : locale4.currency[0] + "", currencySuffix = locale4.currency === void 0 ? "" : locale4.currency[1] + "", decimal = locale4.decimal === void 0 ? "." : locale4.decimal + "", numerals = locale4.numerals === void 0 ? identity_default2 : formatNumerals_default(map3.call(locale4.numerals, String)), percent = locale4.percent === void 0 ? "%" : locale4.percent + "", minus = locale4.minus === void 0 ? "\u2212" : locale4.minus + "", nan = locale4.nan === void 0 ? "NaN" : locale4.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
      if (type2 === "n") comma = true, type2 = "g";
      else if (!formatTypes_default[type2]) precision === void 0 && (precision = 12), trim = true, type2 = "g";
      if (zero3 || fill === "0" && align === "=") zero3 = true, fill = "0", align = "=";
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
      var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format2(value) {
        var valuePrefix = prefix, valueSuffix = suffix, i, n, c6;
        if (type2 === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
          if (trim) value = formatTrim_default(value);
          if (valueNegative && +value === 0 && sign3 !== "+") valueNegative = false;
          valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
          valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c6 = value.charCodeAt(i), 48 > c6 || c6 > 57) {
                valueSuffix = (c6 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma && !zero3) value = group2(value, Infinity);
        var length3 = valuePrefix.length + value.length + valueSuffix.length, padding = length3 < width2 ? new Array(width2 - length3 + 1).join(fill) : "";
        if (comma && zero3) value = group2(padding + value, padding.length ? width2 - valueSuffix.length : Infinity), padding = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding;
            break;
          case "=":
            value = valuePrefix + padding + value + valueSuffix;
            break;
          case "^":
            value = padding.slice(0, length3 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length3);
            break;
          default:
            value = padding + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format2.toString = function() {
        return specifier + "";
      };
      return format2;
    }
    function formatPrefix2(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k3 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
      return function(value2) {
        return f(k3 * value2) + prefix;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }

  // node_modules/d3-format/src/defaultLocale.js
  var locale;
  var format;
  var formatPrefix;
  defaultLocale({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale(definition) {
    locale = locale_default(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // node_modules/d3-format/src/precisionFixed.js
  function precisionFixed_default(step) {
    return Math.max(0, -exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionPrefix.js
  function precisionPrefix_default(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionRound.js
  function precisionRound_default(step, max5) {
    step = Math.abs(step), max5 = Math.abs(max5) - step;
    return Math.max(0, exponent_default(max5) - exponent_default(step)) + 1;
  }

  // node_modules/d3-geo/src/math.js
  var epsilon7 = 1e-6;
  var epsilon22 = 1e-12;
  var pi4 = Math.PI;
  var halfPi3 = pi4 / 2;
  var quarterPi = pi4 / 4;
  var tau5 = pi4 * 2;
  var degrees3 = 180 / pi4;
  var radians2 = pi4 / 180;
  var abs3 = Math.abs;
  var atan = Math.atan;
  var atan2 = Math.atan2;
  var cos2 = Math.cos;
  var ceil = Math.ceil;
  var exp = Math.exp;
  var hypot = Math.hypot;
  var log = Math.log;
  var pow2 = Math.pow;
  var sin2 = Math.sin;
  var sign = Math.sign || function(x5) {
    return x5 > 0 ? 1 : x5 < 0 ? -1 : 0;
  };
  var sqrt = Math.sqrt;
  var tan = Math.tan;
  function acos(x5) {
    return x5 > 1 ? 0 : x5 < -1 ? pi4 : Math.acos(x5);
  }
  function asin(x5) {
    return x5 > 1 ? halfPi3 : x5 < -1 ? -halfPi3 : Math.asin(x5);
  }
  function haversin(x5) {
    return (x5 = sin2(x5 / 2)) * x5;
  }

  // node_modules/d3-geo/src/noop.js
  function noop3() {
  }

  // node_modules/d3-geo/src/stream.js
  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }
  var streamObjectType = {
    Feature: function(object2, stream) {
      streamGeometry(object2.geometry, stream);
    },
    FeatureCollection: function(object2, stream) {
      var features = object2.features, i = -1, n = features.length;
      while (++i < n) streamGeometry(features[i].geometry, stream);
    }
  };
  var streamGeometryType = {
    Sphere: function(object2, stream) {
      stream.sphere();
    },
    Point: function(object2, stream) {
      object2 = object2.coordinates;
      stream.point(object2[0], object2[1], object2[2]);
    },
    MultiPoint: function(object2, stream) {
      var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
      while (++i < n) object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
    },
    LineString: function(object2, stream) {
      streamLine(object2.coordinates, stream, 0);
    },
    MultiLineString: function(object2, stream) {
      var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
      while (++i < n) streamLine(coordinates2[i], stream, 0);
    },
    Polygon: function(object2, stream) {
      streamPolygon(object2.coordinates, stream);
    },
    MultiPolygon: function(object2, stream) {
      var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
      while (++i < n) streamPolygon(coordinates2[i], stream);
    },
    GeometryCollection: function(object2, stream) {
      var geometries = object2.geometries, i = -1, n = geometries.length;
      while (++i < n) streamGeometry(geometries[i], stream);
    }
  };
  function streamLine(coordinates2, stream, closed) {
    var i = -1, n = coordinates2.length - closed, coordinate;
    stream.lineStart();
    while (++i < n) coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }
  function streamPolygon(coordinates2, stream) {
    var i = -1, n = coordinates2.length;
    stream.polygonStart();
    while (++i < n) streamLine(coordinates2[i], stream, 1);
    stream.polygonEnd();
  }
  function stream_default(object2, stream) {
    if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
      streamObjectType[object2.type](object2, stream);
    } else {
      streamGeometry(object2, stream);
    }
  }

  // node_modules/d3-geo/src/area.js
  var areaRingSum = new Adder();
  var areaSum = new Adder();
  var lambda00;
  var phi00;
  var lambda0;
  var cosPhi0;
  var sinPhi0;
  var areaStream = {
    point: noop3,
    lineStart: noop3,
    lineEnd: noop3,
    polygonStart: function() {
      areaRingSum = new Adder();
      areaStream.lineStart = areaRingStart;
      areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
      var areaRing = +areaRingSum;
      areaSum.add(areaRing < 0 ? tau5 + areaRing : areaRing);
      this.lineStart = this.lineEnd = this.point = noop3;
    },
    sphere: function() {
      areaSum.add(tau5);
    }
  };
  function areaRingStart() {
    areaStream.point = areaPointFirst;
  }
  function areaRingEnd() {
    areaPoint(lambda00, phi00);
  }
  function areaPointFirst(lambda, phi2) {
    areaStream.point = areaPoint;
    lambda00 = lambda, phi00 = phi2;
    lambda *= radians2, phi2 *= radians2;
    lambda0 = lambda, cosPhi0 = cos2(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin2(phi2);
  }
  function areaPoint(lambda, phi2) {
    lambda *= radians2, phi2 *= radians2;
    phi2 = phi2 / 2 + quarterPi;
    var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos2(phi2), sinPhi = sin2(phi2), k3 = sinPhi0 * sinPhi, u5 = cosPhi0 * cosPhi + k3 * cos2(adLambda), v3 = k3 * sdLambda * sin2(adLambda);
    areaRingSum.add(atan2(v3, u5));
    lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
  }
  function area_default2(object2) {
    areaSum = new Adder();
    stream_default(object2, areaStream);
    return areaSum * 2;
  }

  // node_modules/d3-geo/src/cartesian.js
  function spherical(cartesian2) {
    return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
  }
  function cartesian(spherical2) {
    var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
    return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
  }
  function cartesianDot(a4, b10) {
    return a4[0] * b10[0] + a4[1] * b10[1] + a4[2] * b10[2];
  }
  function cartesianCross(a4, b10) {
    return [a4[1] * b10[2] - a4[2] * b10[1], a4[2] * b10[0] - a4[0] * b10[2], a4[0] * b10[1] - a4[1] * b10[0]];
  }
  function cartesianAddInPlace(a4, b10) {
    a4[0] += b10[0], a4[1] += b10[1], a4[2] += b10[2];
  }
  function cartesianScale(vector, k3) {
    return [vector[0] * k3, vector[1] * k3, vector[2] * k3];
  }
  function cartesianNormalizeInPlace(d) {
    var l2 = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l2, d[1] /= l2, d[2] /= l2;
  }

  // node_modules/d3-geo/src/bounds.js
  var lambda02;
  var phi0;
  var lambda1;
  var phi1;
  var lambda2;
  var lambda002;
  var phi002;
  var p0;
  var deltaSum;
  var ranges;
  var range3;
  var boundsStream = {
    point: boundsPoint,
    lineStart: boundsLineStart,
    lineEnd: boundsLineEnd,
    polygonStart: function() {
      boundsStream.point = boundsRingPoint;
      boundsStream.lineStart = boundsRingStart;
      boundsStream.lineEnd = boundsRingEnd;
      deltaSum = new Adder();
      areaStream.polygonStart();
    },
    polygonEnd: function() {
      areaStream.polygonEnd();
      boundsStream.point = boundsPoint;
      boundsStream.lineStart = boundsLineStart;
      boundsStream.lineEnd = boundsLineEnd;
      if (areaRingSum < 0) lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      else if (deltaSum > epsilon7) phi1 = 90;
      else if (deltaSum < -epsilon7) phi0 = -90;
      range3[0] = lambda02, range3[1] = lambda1;
    },
    sphere: function() {
      lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    }
  };
  function boundsPoint(lambda, phi2) {
    ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);
    if (phi2 < phi0) phi0 = phi2;
    if (phi2 > phi1) phi1 = phi2;
  }
  function linePoint(lambda, phi2) {
    var p = cartesian([lambda * radians2, phi2 * radians2]);
    if (p0) {
      var normal2 = cartesianCross(p0, p), equatorial = [normal2[1], -normal2[0], 0], inflection = cartesianCross(equatorial, normal2);
      cartesianNormalizeInPlace(inflection);
      inflection = spherical(inflection);
      var delta = lambda - lambda2, sign3 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees3 * sign3, phii, antimeridian = abs3(delta) > 180;
      if (antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {
        phii = inflection[1] * degrees3;
        if (phii > phi1) phi1 = phii;
      } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {
        phii = -inflection[1] * degrees3;
        if (phii < phi0) phi0 = phii;
      } else {
        if (phi2 < phi0) phi0 = phi2;
        if (phi2 > phi1) phi1 = phi2;
      }
      if (antimeridian) {
        if (lambda < lambda2) {
          if (angle(lambda02, lambda) > angle(lambda02, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda02, lambda1)) lambda02 = lambda;
        }
      } else {
        if (lambda1 >= lambda02) {
          if (lambda < lambda02) lambda02 = lambda;
          if (lambda > lambda1) lambda1 = lambda;
        } else {
          if (lambda > lambda2) {
            if (angle(lambda02, lambda) > angle(lambda02, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda02, lambda1)) lambda02 = lambda;
          }
        }
      }
    } else {
      ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);
    }
    if (phi2 < phi0) phi0 = phi2;
    if (phi2 > phi1) phi1 = phi2;
    p0 = p, lambda2 = lambda;
  }
  function boundsLineStart() {
    boundsStream.point = linePoint;
  }
  function boundsLineEnd() {
    range3[0] = lambda02, range3[1] = lambda1;
    boundsStream.point = boundsPoint;
    p0 = null;
  }
  function boundsRingPoint(lambda, phi2) {
    if (p0) {
      var delta = lambda - lambda2;
      deltaSum.add(abs3(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
    } else {
      lambda002 = lambda, phi002 = phi2;
    }
    areaStream.point(lambda, phi2);
    linePoint(lambda, phi2);
  }
  function boundsRingStart() {
    areaStream.lineStart();
  }
  function boundsRingEnd() {
    boundsRingPoint(lambda002, phi002);
    areaStream.lineEnd();
    if (abs3(deltaSum) > epsilon7) lambda02 = -(lambda1 = 180);
    range3[0] = lambda02, range3[1] = lambda1;
    p0 = null;
  }
  function angle(lambda04, lambda12) {
    return (lambda12 -= lambda04) < 0 ? lambda12 + 360 : lambda12;
  }
  function rangeCompare(a4, b10) {
    return a4[0] - b10[0];
  }
  function rangeContains(range6, x5) {
    return range6[0] <= range6[1] ? range6[0] <= x5 && x5 <= range6[1] : x5 < range6[0] || range6[1] < x5;
  }
  function bounds_default(feature) {
    var i, n, a4, b10, merged, deltaMax, delta;
    phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
    ranges = [];
    stream_default(feature, boundsStream);
    if (n = ranges.length) {
      ranges.sort(rangeCompare);
      for (i = 1, a4 = ranges[0], merged = [a4]; i < n; ++i) {
        b10 = ranges[i];
        if (rangeContains(a4, b10[0]) || rangeContains(a4, b10[1])) {
          if (angle(a4[0], b10[1]) > angle(a4[0], a4[1])) a4[1] = b10[1];
          if (angle(b10[0], a4[1]) > angle(a4[0], a4[1])) a4[0] = b10[0];
        } else {
          merged.push(a4 = b10);
        }
      }
      for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a4 = merged[n]; i <= n; a4 = b10, ++i) {
        b10 = merged[i];
        if ((delta = angle(a4[1], b10[0])) > deltaMax) deltaMax = delta, lambda02 = b10[0], lambda1 = a4[1];
      }
    }
    ranges = range3 = null;
    return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];
  }

  // node_modules/d3-geo/src/centroid.js
  var W0;
  var W1;
  var X0;
  var Y0;
  var Z0;
  var X1;
  var Y1;
  var Z1;
  var X2;
  var Y2;
  var Z2;
  var lambda003;
  var phi003;
  var x0;
  var y0;
  var z0;
  var centroidStream = {
    sphere: noop3,
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function() {
      centroidStream.lineStart = centroidRingStart;
      centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function() {
      centroidStream.lineStart = centroidLineStart;
      centroidStream.lineEnd = centroidLineEnd;
    }
  };
  function centroidPoint(lambda, phi2) {
    lambda *= radians2, phi2 *= radians2;
    var cosPhi = cos2(phi2);
    centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));
  }
  function centroidPointCartesian(x5, y5, z2) {
    ++W0;
    X0 += (x5 - X0) / W0;
    Y0 += (y5 - Y0) / W0;
    Z0 += (z2 - Z0) / W0;
  }
  function centroidLineStart() {
    centroidStream.point = centroidLinePointFirst;
  }
  function centroidLinePointFirst(lambda, phi2) {
    lambda *= radians2, phi2 *= radians2;
    var cosPhi = cos2(phi2);
    x0 = cosPhi * cos2(lambda);
    y0 = cosPhi * sin2(lambda);
    z0 = sin2(phi2);
    centroidStream.point = centroidLinePoint;
    centroidPointCartesian(x0, y0, z0);
  }
  function centroidLinePoint(lambda, phi2) {
    lambda *= radians2, phi2 *= radians2;
    var cosPhi = cos2(phi2), x5 = cosPhi * cos2(lambda), y5 = cosPhi * sin2(lambda), z2 = sin2(phi2), w = atan2(sqrt((w = y0 * z2 - z0 * y5) * w + (w = z0 * x5 - x0 * z2) * w + (w = x0 * y5 - y0 * x5) * w), x0 * x5 + y0 * y5 + z0 * z2);
    W1 += w;
    X1 += w * (x0 + (x0 = x5));
    Y1 += w * (y0 + (y0 = y5));
    Z1 += w * (z0 + (z0 = z2));
    centroidPointCartesian(x0, y0, z0);
  }
  function centroidLineEnd() {
    centroidStream.point = centroidPoint;
  }
  function centroidRingStart() {
    centroidStream.point = centroidRingPointFirst;
  }
  function centroidRingEnd() {
    centroidRingPoint(lambda003, phi003);
    centroidStream.point = centroidPoint;
  }
  function centroidRingPointFirst(lambda, phi2) {
    lambda003 = lambda, phi003 = phi2;
    lambda *= radians2, phi2 *= radians2;
    centroidStream.point = centroidRingPoint;
    var cosPhi = cos2(phi2);
    x0 = cosPhi * cos2(lambda);
    y0 = cosPhi * sin2(lambda);
    z0 = sin2(phi2);
    centroidPointCartesian(x0, y0, z0);
  }
  function centroidRingPoint(lambda, phi2) {
    lambda *= radians2, phi2 *= radians2;
    var cosPhi = cos2(phi2), x5 = cosPhi * cos2(lambda), y5 = cosPhi * sin2(lambda), z2 = sin2(phi2), cx = y0 * z2 - z0 * y5, cy = z0 * x5 - x0 * z2, cz = x0 * y5 - y0 * x5, m4 = hypot(cx, cy, cz), w = asin(m4), v3 = m4 && -w / m4;
    X2.add(v3 * cx);
    Y2.add(v3 * cy);
    Z2.add(v3 * cz);
    W1 += w;
    X1 += w * (x0 + (x0 = x5));
    Y1 += w * (y0 + (y0 = y5));
    Z1 += w * (z0 + (z0 = z2));
    centroidPointCartesian(x0, y0, z0);
  }
  function centroid_default(object2) {
    W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
    X2 = new Adder();
    Y2 = new Adder();
    Z2 = new Adder();
    stream_default(object2, centroidStream);
    var x5 = +X2, y5 = +Y2, z2 = +Z2, m4 = hypot(x5, y5, z2);
    if (m4 < epsilon22) {
      x5 = X1, y5 = Y1, z2 = Z1;
      if (W1 < epsilon7) x5 = X0, y5 = Y0, z2 = Z0;
      m4 = hypot(x5, y5, z2);
      if (m4 < epsilon22) return [NaN, NaN];
    }
    return [atan2(y5, x5) * degrees3, asin(z2 / m4) * degrees3];
  }

  // node_modules/d3-geo/src/constant.js
  function constant_default8(x5) {
    return function() {
      return x5;
    };
  }

  // node_modules/d3-geo/src/compose.js
  function compose_default(a4, b10) {
    function compose(x5, y5) {
      return x5 = a4(x5, y5), b10(x5[0], x5[1]);
    }
    if (a4.invert && b10.invert) compose.invert = function(x5, y5) {
      return x5 = b10.invert(x5, y5), x5 && a4.invert(x5[0], x5[1]);
    };
    return compose;
  }

  // node_modules/d3-geo/src/rotation.js
  function rotationIdentity(lambda, phi2) {
    if (abs3(lambda) > pi4) lambda -= Math.round(lambda / tau5) * tau5;
    return [lambda, phi2];
  }
  rotationIdentity.invert = rotationIdentity;
  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
    return (deltaLambda %= tau5) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
  }
  function forwardRotationLambda(deltaLambda) {
    return function(lambda, phi2) {
      lambda += deltaLambda;
      if (abs3(lambda) > pi4) lambda -= Math.round(lambda / tau5) * tau5;
      return [lambda, phi2];
    };
  }
  function rotationLambda(deltaLambda) {
    var rotation = forwardRotationLambda(deltaLambda);
    rotation.invert = forwardRotationLambda(-deltaLambda);
    return rotation;
  }
  function rotationPhiGamma(deltaPhi, deltaGamma) {
    var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
    function rotation(lambda, phi2) {
      var cosPhi = cos2(phi2), x5 = cos2(lambda) * cosPhi, y5 = sin2(lambda) * cosPhi, z2 = sin2(phi2), k3 = z2 * cosDeltaPhi + x5 * sinDeltaPhi;
      return [
        atan2(y5 * cosDeltaGamma - k3 * sinDeltaGamma, x5 * cosDeltaPhi - z2 * sinDeltaPhi),
        asin(k3 * cosDeltaGamma + y5 * sinDeltaGamma)
      ];
    }
    rotation.invert = function(lambda, phi2) {
      var cosPhi = cos2(phi2), x5 = cos2(lambda) * cosPhi, y5 = sin2(lambda) * cosPhi, z2 = sin2(phi2), k3 = z2 * cosDeltaGamma - y5 * sinDeltaGamma;
      return [
        atan2(y5 * cosDeltaGamma + z2 * sinDeltaGamma, x5 * cosDeltaPhi + k3 * sinDeltaPhi),
        asin(k3 * cosDeltaPhi - x5 * sinDeltaPhi)
      ];
    };
    return rotation;
  }
  function rotation_default(rotate) {
    rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
    function forward(coordinates2) {
      coordinates2 = rotate(coordinates2[0] * radians2, coordinates2[1] * radians2);
      return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;
    }
    forward.invert = function(coordinates2) {
      coordinates2 = rotate.invert(coordinates2[0] * radians2, coordinates2[1] * radians2);
      return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;
    };
    return forward;
  }

  // node_modules/d3-geo/src/circle.js
  function circleStream(stream, radius, delta, direction, t03, t13) {
    if (!delta) return;
    var cosRadius = cos2(radius), sinRadius = sin2(radius), step = direction * delta;
    if (t03 == null) {
      t03 = radius + direction * tau5;
      t13 = radius - step / 2;
    } else {
      t03 = circleRadius(cosRadius, t03);
      t13 = circleRadius(cosRadius, t13);
      if (direction > 0 ? t03 < t13 : t03 > t13) t03 += direction * tau5;
    }
    for (var point6, t = t03; direction > 0 ? t > t13 : t < t13; t -= step) {
      point6 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
      stream.point(point6[0], point6[1]);
    }
  }
  function circleRadius(cosRadius, point6) {
    point6 = cartesian(point6), point6[0] -= cosRadius;
    cartesianNormalizeInPlace(point6);
    var radius = acos(-point6[1]);
    return ((-point6[2] < 0 ? -radius : radius) + tau5 - epsilon7) % tau5;
  }
  function circle_default() {
    var center2 = constant_default8([0, 0]), radius = constant_default8(90), precision = constant_default8(2), ring, rotate, stream = { point: point6 };
    function point6(x5, y5) {
      ring.push(x5 = rotate(x5, y5));
      x5[0] *= degrees3, x5[1] *= degrees3;
    }
    function circle() {
      var c6 = center2.apply(this, arguments), r = radius.apply(this, arguments) * radians2, p = precision.apply(this, arguments) * radians2;
      ring = [];
      rotate = rotateRadians(-c6[0] * radians2, -c6[1] * radians2, 0).invert;
      circleStream(stream, r, p, 1);
      c6 = { type: "Polygon", coordinates: [ring] };
      ring = rotate = null;
      return c6;
    }
    circle.center = function(_25) {
      return arguments.length ? (center2 = typeof _25 === "function" ? _25 : constant_default8([+_25[0], +_25[1]]), circle) : center2;
    };
    circle.radius = function(_25) {
      return arguments.length ? (radius = typeof _25 === "function" ? _25 : constant_default8(+_25), circle) : radius;
    };
    circle.precision = function(_25) {
      return arguments.length ? (precision = typeof _25 === "function" ? _25 : constant_default8(+_25), circle) : precision;
    };
    return circle;
  }

  // node_modules/d3-geo/src/clip/buffer.js
  function buffer_default2() {
    var lines = [], line;
    return {
      point: function(x5, y5, m4) {
        line.push([x5, y5, m4]);
      },
      lineStart: function() {
        lines.push(line = []);
      },
      lineEnd: noop3,
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line = null;
        return result;
      }
    };
  }

  // node_modules/d3-geo/src/pointEqual.js
  function pointEqual_default(a4, b10) {
    return abs3(a4[0] - b10[0]) < epsilon7 && abs3(a4[1] - b10[1]) < epsilon7;
  }

  // node_modules/d3-geo/src/clip/rejoin.js
  function Intersection(point6, points, other2, entry) {
    this.x = point6;
    this.z = points;
    this.o = other2;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
    var subject = [], clip = [], i, n;
    segments.forEach(function(segment) {
      if ((n2 = segment.length - 1) <= 0) return;
      var n2, p02 = segment[0], p1 = segment[n2], x5;
      if (pointEqual_default(p02, p1)) {
        if (!p02[2] && !p1[2]) {
          stream.lineStart();
          for (i = 0; i < n2; ++i) stream.point((p02 = segment[i])[0], p02[1]);
          stream.lineEnd();
          return;
        }
        p1[0] += 2 * epsilon7;
      }
      subject.push(x5 = new Intersection(p02, segment, null, true));
      clip.push(x5.o = new Intersection(p02, null, x5, false));
      subject.push(x5 = new Intersection(p1, segment, null, false));
      clip.push(x5.o = new Intersection(p1, null, x5, true));
    });
    if (!subject.length) return;
    clip.sort(compareIntersection2);
    link2(subject);
    link2(clip);
    for (i = 0, n = clip.length; i < n; ++i) {
      clip[i].e = startInside = !startInside;
    }
    var start2 = subject[0], points, point6;
    while (1) {
      var current = start2, isSubject = true;
      while (current.v) if ((current = current.n) === start2) return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n = points.length; i < n; ++i) stream.point((point6 = points[i])[0], point6[1]);
          } else {
            interpolate(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i) stream.point((point6 = points[i])[0], point6[1]);
          } else {
            interpolate(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }
  function link2(array4) {
    if (!(n = array4.length)) return;
    var n, i = 0, a4 = array4[0], b10;
    while (++i < n) {
      a4.n = b10 = array4[i];
      b10.p = a4;
      a4 = b10;
    }
    a4.n = b10 = array4[0];
    b10.p = a4;
  }

  // node_modules/d3-geo/src/polygonContains.js
  function longitude(point6) {
    return abs3(point6[0]) <= pi4 ? point6[0] : sign(point6[0]) * ((abs3(point6[0]) + pi4) % tau5 - pi4);
  }
  function polygonContains_default(polygon, point6) {
    var lambda = longitude(point6), phi2 = point6[1], sinPhi = sin2(phi2), normal2 = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;
    var sum4 = new Adder();
    if (sinPhi === 1) phi2 = halfPi3 + epsilon7;
    else if (sinPhi === -1) phi2 = -halfPi3 - epsilon7;
    for (var i = 0, n = polygon.length; i < n; ++i) {
      if (!(m4 = (ring = polygon[i]).length)) continue;
      var ring, m4, point0 = ring[m4 - 1], lambda04 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi03 = sin2(phi02), cosPhi03 = cos2(phi02);
      for (var j2 = 0; j2 < m4; ++j2, lambda04 = lambda12, sinPhi03 = sinPhi1, cosPhi03 = cosPhi1, point0 = point1) {
        var point1 = ring[j2], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi12), cosPhi1 = cos2(phi12), delta = lambda12 - lambda04, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi4, k3 = sinPhi03 * sinPhi1;
        sum4.add(atan2(k3 * sign3 * sin2(absDelta), cosPhi03 * cosPhi1 + k3 * cos2(absDelta)));
        angle2 += antimeridian ? delta + sign3 * tau5 : delta;
        if (antimeridian ^ lambda04 >= lambda ^ lambda12 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection2 = cartesianCross(normal2, arc);
          cartesianNormalizeInPlace(intersection2);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection2[2]);
          if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }
    return (angle2 < -epsilon7 || angle2 < epsilon7 && sum4 < -epsilon22) ^ winding & 1;
  }

  // node_modules/d3-geo/src/clip/index.js
  function clip_default(pointVisible, clipLine, interpolate, start2) {
    return function(sink) {
      var line = clipLine(sink), ringBuffer = buffer_default2(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
      var clip = {
        point: point6,
        lineStart,
        lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point6;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge(segments);
          var startInside = polygonContains_default(polygon, start2);
          if (segments.length) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
          } else if (startInside) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };
      function point6(lambda, phi2) {
        if (pointVisible(lambda, phi2)) sink.point(lambda, phi2);
      }
      function pointLine(lambda, phi2) {
        line.point(lambda, phi2);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point6;
        line.lineEnd();
      }
      function pointRing(lambda, phi2) {
        ring.push([lambda, phi2]);
        ringSink.point(lambda, phi2);
      }
      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();
        var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m4, segment, point7;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m4 = segment.length - 1) > 0) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m4; ++i) sink.point((point7 = segment[i])[0], point7[1]);
            sink.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(validSegment));
      }
      return clip;
    };
  }
  function validSegment(segment) {
    return segment.length > 1;
  }
  function compareIntersection(a4, b10) {
    return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi3 - epsilon7 : halfPi3 - a4[1]) - ((b10 = b10.x)[0] < 0 ? b10[1] - halfPi3 - epsilon7 : halfPi3 - b10[1]);
  }

  // node_modules/d3-geo/src/clip/antimeridian.js
  var antimeridian_default = clip_default(
    function() {
      return true;
    },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi4, -halfPi3]
  );
  function clipAntimeridianLine(stream) {
    var lambda04 = NaN, phi02 = NaN, sign0 = NaN, clean;
    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda12, phi12) {
        var sign1 = lambda12 > 0 ? pi4 : -pi4, delta = abs3(lambda12 - lambda04);
        if (abs3(delta - pi4) < epsilon7) {
          stream.point(lambda04, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi3 : -halfPi3);
          stream.point(sign0, phi02);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi02);
          stream.point(lambda12, phi02);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi4) {
          if (abs3(lambda04 - sign0) < epsilon7) lambda04 -= sign0 * epsilon7;
          if (abs3(lambda12 - sign1) < epsilon7) lambda12 -= sign1 * epsilon7;
          phi02 = clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12);
          stream.point(sign0, phi02);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi02);
          clean = 0;
        }
        stream.point(lambda04 = lambda12, phi02 = phi12);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda04 = phi02 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12) {
    var cosPhi03, cosPhi1, sinLambda0Lambda1 = sin2(lambda04 - lambda12);
    return abs3(sinLambda0Lambda1) > epsilon7 ? atan((sin2(phi02) * (cosPhi1 = cos2(phi12)) * sin2(lambda12) - sin2(phi12) * (cosPhi03 = cos2(phi02)) * sin2(lambda04)) / (cosPhi03 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
  }
  function clipAntimeridianInterpolate(from, to, direction, stream) {
    var phi2;
    if (from == null) {
      phi2 = direction * halfPi3;
      stream.point(-pi4, phi2);
      stream.point(0, phi2);
      stream.point(pi4, phi2);
      stream.point(pi4, 0);
      stream.point(pi4, -phi2);
      stream.point(0, -phi2);
      stream.point(-pi4, -phi2);
      stream.point(-pi4, 0);
      stream.point(-pi4, phi2);
    } else if (abs3(from[0] - to[0]) > epsilon7) {
      var lambda = from[0] < to[0] ? pi4 : -pi4;
      phi2 = direction * lambda / 2;
      stream.point(-lambda, phi2);
      stream.point(0, phi2);
      stream.point(lambda, phi2);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  // node_modules/d3-geo/src/clip/circle.js
  function circle_default2(radius) {
    var cr = cos2(radius), delta = 2 * radians2, smallRadius = cr > 0, notHemisphere = abs3(cr) > epsilon7;
    function interpolate(from, to, direction, stream) {
      circleStream(stream, radius, delta, direction, from, to);
    }
    function visible(lambda, phi2) {
      return cos2(lambda) * cos2(phi2) > cr;
    }
    function clipLine(stream) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(lambda, phi2) {
          var point1 = [lambda, phi2], point22, v3 = visible(lambda, phi2), c6 = smallRadius ? v3 ? 0 : code(lambda, phi2) : v3 ? code(lambda + (lambda < 0 ? pi4 : -pi4), phi2) : 0;
          if (!point0 && (v00 = v0 = v3)) stream.lineStart();
          if (v3 !== v0) {
            point22 = intersect2(point0, point1);
            if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
              point1[2] = 1;
          }
          if (v3 !== v0) {
            clean = 0;
            if (v3) {
              stream.lineStart();
              point22 = intersect2(point1, point0);
              stream.point(point22[0], point22[1]);
            } else {
              point22 = intersect2(point0, point1);
              stream.point(point22[0], point22[1], 2);
              stream.lineEnd();
            }
            point0 = point22;
          } else if (notHemisphere && point0 && smallRadius ^ v3) {
            var t;
            if (!(c6 & c0) && (t = intersect2(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                stream.lineStart();
                stream.point(t[0][0], t[0][1]);
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
              } else {
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
                stream.lineStart();
                stream.point(t[0][0], t[0][1], 3);
              }
            }
          }
          if (v3 && (!point0 || !pointEqual_default(point0, point1))) {
            stream.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v3, c0 = c6;
        },
        lineEnd: function() {
          if (v0) stream.lineEnd();
          point0 = null;
        },
        // Rejoin first and last segments if there were intersections and the first
        // and last points were visible.
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect2(a4, b10, two) {
      var pa = cartesian(a4), pb = cartesian(b10);
      var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a4;
      var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A6 = cartesianScale(n1, c1), B4 = cartesianScale(n2, c22);
      cartesianAddInPlace(A6, B4);
      var u5 = n1xn2, w = cartesianDot(A6, u5), uu = cartesianDot(u5, u5), t22 = w * w - uu * (cartesianDot(A6, A6) - 1);
      if (t22 < 0) return;
      var t = sqrt(t22), q2 = cartesianScale(u5, (-w - t) / uu);
      cartesianAddInPlace(q2, A6);
      q2 = spherical(q2);
      if (!two) return q2;
      var lambda04 = a4[0], lambda12 = b10[0], phi02 = a4[1], phi12 = b10[1], z2;
      if (lambda12 < lambda04) z2 = lambda04, lambda04 = lambda12, lambda12 = z2;
      var delta2 = lambda12 - lambda04, polar = abs3(delta2 - pi4) < epsilon7, meridian = polar || delta2 < epsilon7;
      if (!polar && phi12 < phi02) z2 = phi02, phi02 = phi12, phi12 = z2;
      if (meridian ? polar ? phi02 + phi12 > 0 ^ q2[1] < (abs3(q2[0] - lambda04) < epsilon7 ? phi02 : phi12) : phi02 <= q2[1] && q2[1] <= phi12 : delta2 > pi4 ^ (lambda04 <= q2[0] && q2[0] <= lambda12)) {
        var q1 = cartesianScale(u5, (-w + t) / uu);
        cartesianAddInPlace(q1, A6);
        return [q2, spherical(q1)];
      }
    }
    function code(lambda, phi2) {
      var r = smallRadius ? radius : pi4 - radius, code2 = 0;
      if (lambda < -r) code2 |= 1;
      else if (lambda > r) code2 |= 2;
      if (phi2 < -r) code2 |= 4;
      else if (phi2 > r) code2 |= 8;
      return code2;
    }
    return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi4, radius - pi4]);
  }

  // node_modules/d3-geo/src/clip/line.js
  function line_default(a4, b10, x06, y06, x12, y12) {
    var ax = a4[0], ay = a4[1], bx = b10[0], by = b10[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r;
    r = x06 - ax;
    if (!dx && r > 0) return;
    r /= dx;
    if (dx < 0) {
      if (r < t03) return;
      if (r < t13) t13 = r;
    } else if (dx > 0) {
      if (r > t13) return;
      if (r > t03) t03 = r;
    }
    r = x12 - ax;
    if (!dx && r < 0) return;
    r /= dx;
    if (dx < 0) {
      if (r > t13) return;
      if (r > t03) t03 = r;
    } else if (dx > 0) {
      if (r < t03) return;
      if (r < t13) t13 = r;
    }
    r = y06 - ay;
    if (!dy && r > 0) return;
    r /= dy;
    if (dy < 0) {
      if (r < t03) return;
      if (r < t13) t13 = r;
    } else if (dy > 0) {
      if (r > t13) return;
      if (r > t03) t03 = r;
    }
    r = y12 - ay;
    if (!dy && r < 0) return;
    r /= dy;
    if (dy < 0) {
      if (r > t13) return;
      if (r > t03) t03 = r;
    } else if (dy > 0) {
      if (r < t03) return;
      if (r < t13) t13 = r;
    }
    if (t03 > 0) a4[0] = ax + t03 * dx, a4[1] = ay + t03 * dy;
    if (t13 < 1) b10[0] = ax + t13 * dx, b10[1] = ay + t13 * dy;
    return true;
  }

  // node_modules/d3-geo/src/clip/rectangle.js
  var clipMax = 1e9;
  var clipMin = -clipMax;
  function clipRectangle(x06, y06, x12, y12) {
    function visible(x5, y5) {
      return x06 <= x5 && x5 <= x12 && y06 <= y5 && y5 <= y12;
    }
    function interpolate(from, to, direction, stream) {
      var a4 = 0, a1 = 0;
      if (from == null || (a4 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
        do
          stream.point(a4 === 0 || a4 === 3 ? x06 : x12, a4 > 1 ? y12 : y06);
        while ((a4 = (a4 + direction + 4) % 4) !== a1);
      } else {
        stream.point(to[0], to[1]);
      }
    }
    function corner(p, direction) {
      return abs3(p[0] - x06) < epsilon7 ? direction > 0 ? 0 : 3 : abs3(p[0] - x12) < epsilon7 ? direction > 0 ? 2 : 1 : abs3(p[1] - y06) < epsilon7 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compareIntersection2(a4, b10) {
      return comparePoint(a4.x, b10.x);
    }
    function comparePoint(a4, b10) {
      var ca3 = corner(a4, 1), cb = corner(b10, 1);
      return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b10[1] - a4[1] : ca3 === 1 ? a4[0] - b10[0] : ca3 === 2 ? a4[1] - b10[1] : b10[0] - a4[0];
    }
    return function(stream) {
      var activeStream = stream, bufferStream = buffer_default2(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
      var clipStream = {
        point: point6,
        lineStart,
        lineEnd,
        polygonStart,
        polygonEnd
      };
      function point6(x5, y5) {
        if (visible(x5, y5)) activeStream.point(x5, y5);
      }
      function polygonInside() {
        var winding = 0;
        for (var i = 0, n = polygon.length; i < n; ++i) {
          for (var ring2 = polygon[i], j2 = 1, m4 = ring2.length, point7 = ring2[0], a0, a1, b02 = point7[0], b12 = point7[1]; j2 < m4; ++j2) {
            a0 = b02, a1 = b12, point7 = ring2[j2], b02 = point7[0], b12 = point7[1];
            if (a1 <= y12) {
              if (b12 > y12 && (b02 - a0) * (y12 - a1) > (b12 - a1) * (x06 - a0)) ++winding;
            } else {
              if (b12 <= y12 && (b02 - a0) * (y12 - a1) < (b12 - a1) * (x06 - a0)) --winding;
            }
          }
        }
        return winding;
      }
      function polygonStart() {
        activeStream = bufferStream, segments = [], polygon = [], clean = true;
      }
      function polygonEnd() {
        var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
        if (cleanInside || visible2) {
          stream.polygonStart();
          if (cleanInside) {
            stream.lineStart();
            interpolate(null, null, 1, stream);
            stream.lineEnd();
          }
          if (visible2) {
            rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
          }
          stream.polygonEnd();
        }
        activeStream = stream, segments = polygon = ring = null;
      }
      function lineStart() {
        clipStream.point = linePoint2;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint2(x__, y__);
          if (v__ && v_) bufferStream.rejoin();
          segments.push(bufferStream.result());
        }
        clipStream.point = point6;
        if (v_) activeStream.lineEnd();
      }
      function linePoint2(x5, y5) {
        var v3 = visible(x5, y5);
        if (polygon) ring.push([x5, y5]);
        if (first) {
          x__ = x5, y__ = y5, v__ = v3;
          first = false;
          if (v3) {
            activeStream.lineStart();
            activeStream.point(x5, y5);
          }
        } else {
          if (v3 && v_) activeStream.point(x5, y5);
          else {
            var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b10 = [x5 = Math.max(clipMin, Math.min(clipMax, x5)), y5 = Math.max(clipMin, Math.min(clipMax, y5))];
            if (line_default(a4, b10, x06, y06, x12, y12)) {
              if (!v_) {
                activeStream.lineStart();
                activeStream.point(a4[0], a4[1]);
              }
              activeStream.point(b10[0], b10[1]);
              if (!v3) activeStream.lineEnd();
              clean = false;
            } else if (v3) {
              activeStream.lineStart();
              activeStream.point(x5, y5);
              clean = false;
            }
          }
        }
        x_ = x5, y_ = y5, v_ = v3;
      }
      return clipStream;
    };
  }

  // node_modules/d3-geo/src/clip/extent.js
  function extent_default2() {
    var x06 = 0, y06 = 0, x12 = 960, y12 = 500, cache2, cacheStream, clip;
    return clip = {
      stream: function(stream) {
        return cache2 && cacheStream === stream ? cache2 : cache2 = clipRectangle(x06, y06, x12, y12)(cacheStream = stream);
      },
      extent: function(_25) {
        return arguments.length ? (x06 = +_25[0][0], y06 = +_25[0][1], x12 = +_25[1][0], y12 = +_25[1][1], cache2 = cacheStream = null, clip) : [[x06, y06], [x12, y12]];
      }
    };
  }

  // node_modules/d3-geo/src/length.js
  var lengthSum;
  var lambda03;
  var sinPhi02;
  var cosPhi02;
  var lengthStream = {
    sphere: noop3,
    point: noop3,
    lineStart: lengthLineStart,
    lineEnd: noop3,
    polygonStart: noop3,
    polygonEnd: noop3
  };
  function lengthLineStart() {
    lengthStream.point = lengthPointFirst;
    lengthStream.lineEnd = lengthLineEnd;
  }
  function lengthLineEnd() {
    lengthStream.point = lengthStream.lineEnd = noop3;
  }
  function lengthPointFirst(lambda, phi2) {
    lambda *= radians2, phi2 *= radians2;
    lambda03 = lambda, sinPhi02 = sin2(phi2), cosPhi02 = cos2(phi2);
    lengthStream.point = lengthPoint;
  }
  function lengthPoint(lambda, phi2) {
    lambda *= radians2, phi2 *= radians2;
    var sinPhi = sin2(phi2), cosPhi = cos2(phi2), delta = abs3(lambda - lambda03), cosDelta = cos2(delta), sinDelta = sin2(delta), x5 = cosPhi * sinDelta, y5 = cosPhi02 * sinPhi - sinPhi02 * cosPhi * cosDelta, z2 = sinPhi02 * sinPhi + cosPhi02 * cosPhi * cosDelta;
    lengthSum.add(atan2(sqrt(x5 * x5 + y5 * y5), z2));
    lambda03 = lambda, sinPhi02 = sinPhi, cosPhi02 = cosPhi;
  }
  function length_default(object2) {
    lengthSum = new Adder();
    stream_default(object2, lengthStream);
    return +lengthSum;
  }

  // node_modules/d3-geo/src/distance.js
  var coordinates = [null, null];
  var object = { type: "LineString", coordinates };
  function distance_default(a4, b10) {
    coordinates[0] = a4;
    coordinates[1] = b10;
    return length_default(object);
  }

  // node_modules/d3-geo/src/contains.js
  var containsObjectType = {
    Feature: function(object2, point6) {
      return containsGeometry(object2.geometry, point6);
    },
    FeatureCollection: function(object2, point6) {
      var features = object2.features, i = -1, n = features.length;
      while (++i < n) if (containsGeometry(features[i].geometry, point6)) return true;
      return false;
    }
  };
  var containsGeometryType = {
    Sphere: function() {
      return true;
    },
    Point: function(object2, point6) {
      return containsPoint(object2.coordinates, point6);
    },
    MultiPoint: function(object2, point6) {
      var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
      while (++i < n) if (containsPoint(coordinates2[i], point6)) return true;
      return false;
    },
    LineString: function(object2, point6) {
      return containsLine(object2.coordinates, point6);
    },
    MultiLineString: function(object2, point6) {
      var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
      while (++i < n) if (containsLine(coordinates2[i], point6)) return true;
      return false;
    },
    Polygon: function(object2, point6) {
      return containsPolygon(object2.coordinates, point6);
    },
    MultiPolygon: function(object2, point6) {
      var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
      while (++i < n) if (containsPolygon(coordinates2[i], point6)) return true;
      return false;
    },
    GeometryCollection: function(object2, point6) {
      var geometries = object2.geometries, i = -1, n = geometries.length;
      while (++i < n) if (containsGeometry(geometries[i], point6)) return true;
      return false;
    }
  };
  function containsGeometry(geometry, point6) {
    return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point6) : false;
  }
  function containsPoint(coordinates2, point6) {
    return distance_default(coordinates2, point6) === 0;
  }
  function containsLine(coordinates2, point6) {
    var ao, bo, ab4;
    for (var i = 0, n = coordinates2.length; i < n; i++) {
      bo = distance_default(coordinates2[i], point6);
      if (bo === 0) return true;
      if (i > 0) {
        ab4 = distance_default(coordinates2[i], coordinates2[i - 1]);
        if (ab4 > 0 && ao <= ab4 && bo <= ab4 && (ao + bo - ab4) * (1 - Math.pow((ao - bo) / ab4, 2)) < epsilon22 * ab4)
          return true;
      }
      ao = bo;
    }
    return false;
  }
  function containsPolygon(coordinates2, point6) {
    return !!polygonContains_default(coordinates2.map(ringRadians), pointRadians(point6));
  }
  function ringRadians(ring) {
    return ring = ring.map(pointRadians), ring.pop(), ring;
  }
  function pointRadians(point6) {
    return [point6[0] * radians2, point6[1] * radians2];
  }
  function contains_default2(object2, point6) {
    return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point6);
  }

  // node_modules/d3-geo/src/graticule.js
  function graticuleX(y06, y12, dy) {
    var y5 = range(y06, y12 - epsilon7, dy).concat(y12);
    return function(x5) {
      return y5.map(function(y6) {
        return [x5, y6];
      });
    };
  }
  function graticuleY(x06, x12, dx) {
    var x5 = range(x06, x12 - epsilon7, dx).concat(x12);
    return function(y5) {
      return x5.map(function(x6) {
        return [x6, y5];
      });
    };
  }
  function graticule() {
    var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x5, y5, X4, Y4, precision = 2.5;
    function graticule2() {
      return { type: "MultiLineString", coordinates: lines() };
    }
    function lines() {
      return range(ceil(X03 / DX) * DX, X13, DX).map(X4).concat(range(ceil(Y03 / DY) * DY, Y13, DY).map(Y4)).concat(range(ceil(x06 / dx) * dx, x12, dx).filter(function(x6) {
        return abs3(x6 % DX) > epsilon7;
      }).map(x5)).concat(range(ceil(y06 / dy) * dy, y12, dy).filter(function(y6) {
        return abs3(y6 % DY) > epsilon7;
      }).map(y5));
    }
    graticule2.lines = function() {
      return lines().map(function(coordinates2) {
        return { type: "LineString", coordinates: coordinates2 };
      });
    };
    graticule2.outline = function() {
      return {
        type: "Polygon",
        coordinates: [
          X4(X03).concat(
            Y4(Y13).slice(1),
            X4(X13).reverse().slice(1),
            Y4(Y03).reverse().slice(1)
          )
        ]
      };
    };
    graticule2.extent = function(_25) {
      if (!arguments.length) return graticule2.extentMinor();
      return graticule2.extentMajor(_25).extentMinor(_25);
    };
    graticule2.extentMajor = function(_25) {
      if (!arguments.length) return [[X03, Y03], [X13, Y13]];
      X03 = +_25[0][0], X13 = +_25[1][0];
      Y03 = +_25[0][1], Y13 = +_25[1][1];
      if (X03 > X13) _25 = X03, X03 = X13, X13 = _25;
      if (Y03 > Y13) _25 = Y03, Y03 = Y13, Y13 = _25;
      return graticule2.precision(precision);
    };
    graticule2.extentMinor = function(_25) {
      if (!arguments.length) return [[x06, y06], [x12, y12]];
      x06 = +_25[0][0], x12 = +_25[1][0];
      y06 = +_25[0][1], y12 = +_25[1][1];
      if (x06 > x12) _25 = x06, x06 = x12, x12 = _25;
      if (y06 > y12) _25 = y06, y06 = y12, y12 = _25;
      return graticule2.precision(precision);
    };
    graticule2.step = function(_25) {
      if (!arguments.length) return graticule2.stepMinor();
      return graticule2.stepMajor(_25).stepMinor(_25);
    };
    graticule2.stepMajor = function(_25) {
      if (!arguments.length) return [DX, DY];
      DX = +_25[0], DY = +_25[1];
      return graticule2;
    };
    graticule2.stepMinor = function(_25) {
      if (!arguments.length) return [dx, dy];
      dx = +_25[0], dy = +_25[1];
      return graticule2;
    };
    graticule2.precision = function(_25) {
      if (!arguments.length) return precision;
      precision = +_25;
      x5 = graticuleX(y06, y12, 90);
      y5 = graticuleY(x06, x12, precision);
      X4 = graticuleX(Y03, Y13, 90);
      Y4 = graticuleY(X03, X13, precision);
      return graticule2;
    };
    return graticule2.extentMajor([[-180, -90 + epsilon7], [180, 90 - epsilon7]]).extentMinor([[-180, -80 - epsilon7], [180, 80 + epsilon7]]);
  }
  function graticule10() {
    return graticule()();
  }

  // node_modules/d3-geo/src/interpolate.js
  function interpolate_default2(a4, b10) {
    var x06 = a4[0] * radians2, y06 = a4[1] * radians2, x12 = b10[0] * radians2, y12 = b10[1] * radians2, cy0 = cos2(y06), sy0 = sin2(y06), cy1 = cos2(y12), sy1 = sin2(y12), kx0 = cy0 * cos2(x06), ky0 = cy0 * sin2(x06), kx1 = cy1 * cos2(x12), ky1 = cy1 * sin2(x12), d = 2 * asin(sqrt(haversin(y12 - y06) + cy0 * cy1 * haversin(x12 - x06))), k3 = sin2(d);
    var interpolate = d ? function(t) {
      var B4 = sin2(t *= d) / k3, A6 = sin2(d - t) / k3, x5 = A6 * kx0 + B4 * kx1, y5 = A6 * ky0 + B4 * ky1, z2 = A6 * sy0 + B4 * sy1;
      return [
        atan2(y5, x5) * degrees3,
        atan2(z2, sqrt(x5 * x5 + y5 * y5)) * degrees3
      ];
    } : function() {
      return [x06 * degrees3, y06 * degrees3];
    };
    interpolate.distance = d;
    return interpolate;
  }

  // node_modules/d3-geo/src/identity.js
  var identity_default3 = (x5) => x5;

  // node_modules/d3-geo/src/path/area.js
  var areaSum2 = new Adder();
  var areaRingSum2 = new Adder();
  var x00;
  var y00;
  var x02;
  var y02;
  var areaStream2 = {
    point: noop3,
    lineStart: noop3,
    lineEnd: noop3,
    polygonStart: function() {
      areaStream2.lineStart = areaRingStart2;
      areaStream2.lineEnd = areaRingEnd2;
    },
    polygonEnd: function() {
      areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop3;
      areaSum2.add(abs3(areaRingSum2));
      areaRingSum2 = new Adder();
    },
    result: function() {
      var area = areaSum2 / 2;
      areaSum2 = new Adder();
      return area;
    }
  };
  function areaRingStart2() {
    areaStream2.point = areaPointFirst2;
  }
  function areaPointFirst2(x5, y5) {
    areaStream2.point = areaPoint2;
    x00 = x02 = x5, y00 = y02 = y5;
  }
  function areaPoint2(x5, y5) {
    areaRingSum2.add(y02 * x5 - x02 * y5);
    x02 = x5, y02 = y5;
  }
  function areaRingEnd2() {
    areaPoint2(x00, y00);
  }
  var area_default3 = areaStream2;

  // node_modules/d3-geo/src/path/bounds.js
  var x03 = Infinity;
  var y03 = x03;
  var x1 = -x03;
  var y1 = x1;
  var boundsStream2 = {
    point: boundsPoint2,
    lineStart: noop3,
    lineEnd: noop3,
    polygonStart: noop3,
    polygonEnd: noop3,
    result: function() {
      var bounds = [[x03, y03], [x1, y1]];
      x1 = y1 = -(y03 = x03 = Infinity);
      return bounds;
    }
  };
  function boundsPoint2(x5, y5) {
    if (x5 < x03) x03 = x5;
    if (x5 > x1) x1 = x5;
    if (y5 < y03) y03 = y5;
    if (y5 > y1) y1 = y5;
  }
  var bounds_default2 = boundsStream2;

  // node_modules/d3-geo/src/path/centroid.js
  var X02 = 0;
  var Y02 = 0;
  var Z02 = 0;
  var X12 = 0;
  var Y12 = 0;
  var Z12 = 0;
  var X22 = 0;
  var Y22 = 0;
  var Z22 = 0;
  var x002;
  var y002;
  var x04;
  var y04;
  var centroidStream2 = {
    point: centroidPoint2,
    lineStart: centroidLineStart2,
    lineEnd: centroidLineEnd2,
    polygonStart: function() {
      centroidStream2.lineStart = centroidRingStart2;
      centroidStream2.lineEnd = centroidRingEnd2;
    },
    polygonEnd: function() {
      centroidStream2.point = centroidPoint2;
      centroidStream2.lineStart = centroidLineStart2;
      centroidStream2.lineEnd = centroidLineEnd2;
    },
    result: function() {
      var centroid = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
      X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
      return centroid;
    }
  };
  function centroidPoint2(x5, y5) {
    X02 += x5;
    Y02 += y5;
    ++Z02;
  }
  function centroidLineStart2() {
    centroidStream2.point = centroidPointFirstLine;
  }
  function centroidPointFirstLine(x5, y5) {
    centroidStream2.point = centroidPointLine;
    centroidPoint2(x04 = x5, y04 = y5);
  }
  function centroidPointLine(x5, y5) {
    var dx = x5 - x04, dy = y5 - y04, z2 = sqrt(dx * dx + dy * dy);
    X12 += z2 * (x04 + x5) / 2;
    Y12 += z2 * (y04 + y5) / 2;
    Z12 += z2;
    centroidPoint2(x04 = x5, y04 = y5);
  }
  function centroidLineEnd2() {
    centroidStream2.point = centroidPoint2;
  }
  function centroidRingStart2() {
    centroidStream2.point = centroidPointFirstRing;
  }
  function centroidRingEnd2() {
    centroidPointRing(x002, y002);
  }
  function centroidPointFirstRing(x5, y5) {
    centroidStream2.point = centroidPointRing;
    centroidPoint2(x002 = x04 = x5, y002 = y04 = y5);
  }
  function centroidPointRing(x5, y5) {
    var dx = x5 - x04, dy = y5 - y04, z2 = sqrt(dx * dx + dy * dy);
    X12 += z2 * (x04 + x5) / 2;
    Y12 += z2 * (y04 + y5) / 2;
    Z12 += z2;
    z2 = y04 * x5 - x04 * y5;
    X22 += z2 * (x04 + x5);
    Y22 += z2 * (y04 + y5);
    Z22 += z2 * 3;
    centroidPoint2(x04 = x5, y04 = y5);
  }
  var centroid_default2 = centroidStream2;

  // node_modules/d3-geo/src/path/context.js
  function PathContext(context) {
    this._context = context;
  }
  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_25) {
      return this._radius = _25, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0) this._context.closePath();
      this._point = NaN;
    },
    point: function(x5, y5) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x5, y5);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x5, y5);
          break;
        }
        default: {
          this._context.moveTo(x5 + this._radius, y5);
          this._context.arc(x5, y5, this._radius, 0, tau5);
          break;
        }
      }
    },
    result: noop3
  };

  // node_modules/d3-geo/src/path/measure.js
  var lengthSum2 = new Adder();
  var lengthRing;
  var x003;
  var y003;
  var x05;
  var y05;
  var lengthStream2 = {
    point: noop3,
    lineStart: function() {
      lengthStream2.point = lengthPointFirst2;
    },
    lineEnd: function() {
      if (lengthRing) lengthPoint2(x003, y003);
      lengthStream2.point = noop3;
    },
    polygonStart: function() {
      lengthRing = true;
    },
    polygonEnd: function() {
      lengthRing = null;
    },
    result: function() {
      var length3 = +lengthSum2;
      lengthSum2 = new Adder();
      return length3;
    }
  };
  function lengthPointFirst2(x5, y5) {
    lengthStream2.point = lengthPoint2;
    x003 = x05 = x5, y003 = y05 = y5;
  }
  function lengthPoint2(x5, y5) {
    x05 -= x5, y05 -= y5;
    lengthSum2.add(sqrt(x05 * x05 + y05 * y05));
    x05 = x5, y05 = y5;
  }
  var measure_default = lengthStream2;

  // node_modules/d3-geo/src/path/string.js
  var cacheDigits;
  var cacheAppend;
  var cacheRadius;
  var cacheCircle;
  var PathString = class {
    constructor(digits) {
      this._append = digits == null ? append3 : appendRound2(digits);
      this._radius = 4.5;
      this._ = "";
    }
    pointRadius(_25) {
      this._radius = +_25;
      return this;
    }
    polygonStart() {
      this._line = 0;
    }
    polygonEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      if (this._line === 0) this._ += "Z";
      this._point = NaN;
    }
    point(x5, y5) {
      switch (this._point) {
        case 0: {
          this._append`M${x5},${y5}`;
          this._point = 1;
          break;
        }
        case 1: {
          this._append`L${x5},${y5}`;
          break;
        }
        default: {
          this._append`M${x5},${y5}`;
          if (this._radius !== cacheRadius || this._append !== cacheAppend) {
            const r = this._radius;
            const s2 = this._;
            this._ = "";
            this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
            cacheRadius = r;
            cacheAppend = this._append;
            cacheCircle = this._;
            this._ = s2;
          }
          this._ += cacheCircle;
          break;
        }
      }
    }
    result() {
      const result = this._;
      this._ = "";
      return result.length ? result : null;
    }
  };
  function append3(strings) {
    let i = 1;
    this._ += strings[0];
    for (const j2 = strings.length; i < j2; ++i) {
      this._ += arguments[i] + strings[i];
    }
  }
  function appendRound2(digits) {
    const d = Math.floor(digits);
    if (!(d >= 0)) throw new RangeError(`invalid digits: ${digits}`);
    if (d > 15) return append3;
    if (d !== cacheDigits) {
      const k3 = 10 ** d;
      cacheDigits = d;
      cacheAppend = function append4(strings) {
        let i = 1;
        this._ += strings[0];
        for (const j2 = strings.length; i < j2; ++i) {
          this._ += Math.round(arguments[i] * k3) / k3 + strings[i];
        }
      };
    }
    return cacheAppend;
  }

  // node_modules/d3-geo/src/path/index.js
  function path_default(projection2, context) {
    let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
    function path2(object2) {
      if (object2) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        stream_default(object2, projectionStream(contextStream));
      }
      return contextStream.result();
    }
    path2.area = function(object2) {
      stream_default(object2, projectionStream(area_default3));
      return area_default3.result();
    };
    path2.measure = function(object2) {
      stream_default(object2, projectionStream(measure_default));
      return measure_default.result();
    };
    path2.bounds = function(object2) {
      stream_default(object2, projectionStream(bounds_default2));
      return bounds_default2.result();
    };
    path2.centroid = function(object2) {
      stream_default(object2, projectionStream(centroid_default2));
      return centroid_default2.result();
    };
    path2.projection = function(_25) {
      if (!arguments.length) return projection2;
      projectionStream = _25 == null ? (projection2 = null, identity_default3) : (projection2 = _25).stream;
      return path2;
    };
    path2.context = function(_25) {
      if (!arguments.length) return context;
      contextStream = _25 == null ? (context = null, new PathString(digits)) : new PathContext(context = _25);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return path2;
    };
    path2.pointRadius = function(_25) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _25 === "function" ? _25 : (contextStream.pointRadius(+_25), +_25);
      return path2;
    };
    path2.digits = function(_25) {
      if (!arguments.length) return digits;
      if (_25 == null) digits = null;
      else {
        const d = Math.floor(_25);
        if (!(d >= 0)) throw new RangeError(`invalid digits: ${_25}`);
        digits = d;
      }
      if (context === null) contextStream = new PathString(digits);
      return path2;
    };
    return path2.projection(projection2).digits(digits).context(context);
  }

  // node_modules/d3-geo/src/transform.js
  function transform_default(methods) {
    return {
      stream: transformer(methods)
    };
  }
  function transformer(methods) {
    return function(stream) {
      var s2 = new TransformStream();
      for (var key in methods) s2[key] = methods[key];
      s2.stream = stream;
      return s2;
    };
  }
  function TransformStream() {
  }
  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x5, y5) {
      this.stream.point(x5, y5);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };

  // node_modules/d3-geo/src/projection/fit.js
  function fit(projection2, fitBounds, object2) {
    var clip = projection2.clipExtent && projection2.clipExtent();
    projection2.scale(150).translate([0, 0]);
    if (clip != null) projection2.clipExtent(null);
    stream_default(object2, projection2.stream(bounds_default2));
    fitBounds(bounds_default2.result());
    if (clip != null) projection2.clipExtent(clip);
    return projection2;
  }
  function fitExtent(projection2, extent2, object2) {
    return fit(projection2, function(b10) {
      var w = extent2[1][0] - extent2[0][0], h2 = extent2[1][1] - extent2[0][1], k3 = Math.min(w / (b10[1][0] - b10[0][0]), h2 / (b10[1][1] - b10[0][1])), x5 = +extent2[0][0] + (w - k3 * (b10[1][0] + b10[0][0])) / 2, y5 = +extent2[0][1] + (h2 - k3 * (b10[1][1] + b10[0][1])) / 2;
      projection2.scale(150 * k3).translate([x5, y5]);
    }, object2);
  }
  function fitSize(projection2, size2, object2) {
    return fitExtent(projection2, [[0, 0], size2], object2);
  }
  function fitWidth(projection2, width2, object2) {
    return fit(projection2, function(b10) {
      var w = +width2, k3 = w / (b10[1][0] - b10[0][0]), x5 = (w - k3 * (b10[1][0] + b10[0][0])) / 2, y5 = -k3 * b10[0][1];
      projection2.scale(150 * k3).translate([x5, y5]);
    }, object2);
  }
  function fitHeight(projection2, height2, object2) {
    return fit(projection2, function(b10) {
      var h2 = +height2, k3 = h2 / (b10[1][1] - b10[0][1]), x5 = -k3 * b10[0][0], y5 = (h2 - k3 * (b10[1][1] + b10[0][1])) / 2;
      projection2.scale(150 * k3).translate([x5, y5]);
    }, object2);
  }

  // node_modules/d3-geo/src/projection/resample.js
  var maxDepth = 16;
  var cosMinDistance = cos2(30 * radians2);
  function resample_default(project, delta2) {
    return +delta2 ? resample(project, delta2) : resampleNone(project);
  }
  function resampleNone(project) {
    return transformer({
      point: function(x5, y5) {
        x5 = project(x5, y5);
        this.stream.point(x5[0], x5[1]);
      }
    });
  }
  function resample(project, delta2) {
    function resampleLineTo(x06, y06, lambda04, a0, b02, c0, x12, y12, lambda12, a1, b12, c1, depth, stream) {
      var dx = x12 - x06, dy = y12 - y06, d2 = dx * dx + dy * dy;
      if (d2 > 4 * delta2 && depth--) {
        var a4 = a0 + a1, b10 = b02 + b12, c6 = c0 + c1, m4 = sqrt(a4 * a4 + b10 * b10 + c6 * c6), phi2 = asin(c6 /= m4), lambda22 = abs3(abs3(c6) - 1) < epsilon7 || abs3(lambda04 - lambda12) < epsilon7 ? (lambda04 + lambda12) / 2 : atan2(b10, a4), p = project(lambda22, phi2), x22 = p[0], y22 = p[1], dx2 = x22 - x06, dy2 = y22 - y06, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > delta2 || abs3((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b02 * b12 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x06, y06, lambda04, a0, b02, c0, x22, y22, lambda22, a4 /= m4, b10 /= m4, c6, depth, stream);
          stream.point(x22, y22);
          resampleLineTo(x22, y22, lambda22, a4, b10, c6, x12, y12, lambda12, a1, b12, c1, depth, stream);
        }
      }
    }
    return function(stream) {
      var lambda004, x004, y004, a00, b00, c00, lambda04, x06, y06, a0, b02, c0;
      var resampleStream = {
        point: point6,
        lineStart,
        lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resampleStream.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resampleStream.lineStart = lineStart;
        }
      };
      function point6(x5, y5) {
        x5 = project(x5, y5);
        stream.point(x5[0], x5[1]);
      }
      function lineStart() {
        x06 = NaN;
        resampleStream.point = linePoint2;
        stream.lineStart();
      }
      function linePoint2(lambda, phi2) {
        var c6 = cartesian([lambda, phi2]), p = project(lambda, phi2);
        resampleLineTo(x06, y06, lambda04, a0, b02, c0, x06 = p[0], y06 = p[1], lambda04 = lambda, a0 = c6[0], b02 = c6[1], c0 = c6[2], maxDepth, stream);
        stream.point(x06, y06);
      }
      function lineEnd() {
        resampleStream.point = point6;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resampleStream.point = ringPoint;
        resampleStream.lineEnd = ringEnd;
      }
      function ringPoint(lambda, phi2) {
        linePoint2(lambda004 = lambda, phi2), x004 = x06, y004 = y06, a00 = a0, b00 = b02, c00 = c0;
        resampleStream.point = linePoint2;
      }
      function ringEnd() {
        resampleLineTo(x06, y06, lambda04, a0, b02, c0, x004, y004, lambda004, a00, b00, c00, maxDepth, stream);
        resampleStream.lineEnd = lineEnd;
        lineEnd();
      }
      return resampleStream;
    };
  }

  // node_modules/d3-geo/src/projection/index.js
  var transformRadians = transformer({
    point: function(x5, y5) {
      this.stream.point(x5 * radians2, y5 * radians2);
    }
  });
  function transformRotate(rotate) {
    return transformer({
      point: function(x5, y5) {
        var r = rotate(x5, y5);
        return this.stream.point(r[0], r[1]);
      }
    });
  }
  function scaleTranslate(k3, dx, dy, sx, sy) {
    function transform2(x5, y5) {
      x5 *= sx;
      y5 *= sy;
      return [dx + k3 * x5, dy - k3 * y5];
    }
    transform2.invert = function(x5, y5) {
      return [(x5 - dx) / k3 * sx, (dy - y5) / k3 * sy];
    };
    return transform2;
  }
  function scaleTranslateRotate(k3, dx, dy, sx, sy, alpha) {
    if (!alpha) return scaleTranslate(k3, dx, dy, sx, sy);
    var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a4 = cosAlpha * k3, b10 = sinAlpha * k3, ai = cosAlpha / k3, bi = sinAlpha / k3, ci = (sinAlpha * dy - cosAlpha * dx) / k3, fi = (sinAlpha * dx + cosAlpha * dy) / k3;
    function transform2(x5, y5) {
      x5 *= sx;
      y5 *= sy;
      return [a4 * x5 - b10 * y5 + dx, dy - b10 * x5 - a4 * y5];
    }
    transform2.invert = function(x5, y5) {
      return [sx * (ai * x5 - bi * y5 + ci), sy * (fi - bi * x5 - ai * y5)];
    };
    return transform2;
  }
  function projection(project) {
    return projectionMutator(function() {
      return project;
    })();
  }
  function projectionMutator(projectAt) {
    var project, k3 = 150, x5 = 480, y5 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
    function projection2(point6) {
      return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);
    }
    function invert(point6) {
      point6 = projectRotateTransform.invert(point6[0], point6[1]);
      return point6 && [point6[0] * degrees3, point6[1] * degrees3];
    }
    projection2.stream = function(stream) {
      return cache2 && cacheStream === stream ? cache2 : cache2 = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
    };
    projection2.preclip = function(_25) {
      return arguments.length ? (preclip = _25, theta = void 0, reset2()) : preclip;
    };
    projection2.postclip = function(_25) {
      return arguments.length ? (postclip = _25, x06 = y06 = x12 = y12 = null, reset2()) : postclip;
    };
    projection2.clipAngle = function(_25) {
      return arguments.length ? (preclip = +_25 ? circle_default2(theta = _25 * radians2) : (theta = null, antimeridian_default), reset2()) : theta * degrees3;
    };
    projection2.clipExtent = function(_25) {
      return arguments.length ? (postclip = _25 == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_25[0][0], y06 = +_25[0][1], x12 = +_25[1][0], y12 = +_25[1][1]), reset2()) : x06 == null ? null : [[x06, y06], [x12, y12]];
    };
    projection2.scale = function(_25) {
      return arguments.length ? (k3 = +_25, recenter()) : k3;
    };
    projection2.translate = function(_25) {
      return arguments.length ? (x5 = +_25[0], y5 = +_25[1], recenter()) : [x5, y5];
    };
    projection2.center = function(_25) {
      return arguments.length ? (lambda = _25[0] % 360 * radians2, phi2 = _25[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];
    };
    projection2.rotate = function(_25) {
      return arguments.length ? (deltaLambda = _25[0] % 360 * radians2, deltaPhi = _25[1] % 360 * radians2, deltaGamma = _25.length > 2 ? _25[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
    };
    projection2.angle = function(_25) {
      return arguments.length ? (alpha = _25 % 360 * radians2, recenter()) : alpha * degrees3;
    };
    projection2.reflectX = function(_25) {
      return arguments.length ? (sx = _25 ? -1 : 1, recenter()) : sx < 0;
    };
    projection2.reflectY = function(_25) {
      return arguments.length ? (sy = _25 ? -1 : 1, recenter()) : sy < 0;
    };
    projection2.precision = function(_25) {
      return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _25 * _25), reset2()) : sqrt(delta2);
    };
    projection2.fitExtent = function(extent2, object2) {
      return fitExtent(projection2, extent2, object2);
    };
    projection2.fitSize = function(size2, object2) {
      return fitSize(projection2, size2, object2);
    };
    projection2.fitWidth = function(width2, object2) {
      return fitWidth(projection2, width2, object2);
    };
    projection2.fitHeight = function(height2, object2) {
      return fitHeight(projection2, height2, object2);
    };
    function recenter() {
      var center2 = scaleTranslateRotate(k3, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform2 = scaleTranslateRotate(k3, x5 - center2[0], y5 - center2[1], sx, sy, alpha);
      rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
      projectTransform = compose_default(project, transform2);
      projectRotateTransform = compose_default(rotate, projectTransform);
      projectResample = resample_default(projectTransform, delta2);
      return reset2();
    }
    function reset2() {
      cache2 = cacheStream = null;
      return projection2;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection2.invert = project.invert && invert;
      return recenter();
    };
  }

  // node_modules/d3-geo/src/projection/conic.js
  function conicProjection(projectAt) {
    var phi02 = 0, phi12 = pi4 / 3, m4 = projectionMutator(projectAt), p = m4(phi02, phi12);
    p.parallels = function(_25) {
      return arguments.length ? m4(phi02 = _25[0] * radians2, phi12 = _25[1] * radians2) : [phi02 * degrees3, phi12 * degrees3];
    };
    return p;
  }

  // node_modules/d3-geo/src/projection/cylindricalEqualArea.js
  function cylindricalEqualAreaRaw(phi02) {
    var cosPhi03 = cos2(phi02);
    function forward(lambda, phi2) {
      return [lambda * cosPhi03, sin2(phi2) / cosPhi03];
    }
    forward.invert = function(x5, y5) {
      return [x5 / cosPhi03, asin(y5 * cosPhi03)];
    };
    return forward;
  }

  // node_modules/d3-geo/src/projection/conicEqualArea.js
  function conicEqualAreaRaw(y06, y12) {
    var sy0 = sin2(y06), n = (sy0 + sin2(y12)) / 2;
    if (abs3(n) < epsilon7) return cylindricalEqualAreaRaw(y06);
    var c6 = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c6) / n;
    function project(x5, y5) {
      var r = sqrt(c6 - 2 * n * sin2(y5)) / n;
      return [r * sin2(x5 *= n), r0 - r * cos2(x5)];
    }
    project.invert = function(x5, y5) {
      var r0y = r0 - y5, l2 = atan2(x5, abs3(r0y)) * sign(r0y);
      if (r0y * n < 0)
        l2 -= pi4 * sign(x5) * sign(r0y);
      return [l2 / n, asin((c6 - (x5 * x5 + r0y * r0y) * n * n) / (2 * n))];
    };
    return project;
  }
  function conicEqualArea_default() {
    return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
  }

  // node_modules/d3-geo/src/projection/albers.js
  function albers_default() {
    return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
  }

  // node_modules/d3-geo/src/projection/albersUsa.js
  function multiplex(streams) {
    var n = streams.length;
    return {
      point: function(x5, y5) {
        var i = -1;
        while (++i < n) streams[i].point(x5, y5);
      },
      sphere: function() {
        var i = -1;
        while (++i < n) streams[i].sphere();
      },
      lineStart: function() {
        var i = -1;
        while (++i < n) streams[i].lineStart();
      },
      lineEnd: function() {
        var i = -1;
        while (++i < n) streams[i].lineEnd();
      },
      polygonStart: function() {
        var i = -1;
        while (++i < n) streams[i].polygonStart();
      },
      polygonEnd: function() {
        var i = -1;
        while (++i < n) streams[i].polygonEnd();
      }
    };
  }
  function albersUsa_default() {
    var cache2, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x5, y5) {
      point6 = [x5, y5];
    } };
    function albersUsa(coordinates2) {
      var x5 = coordinates2[0], y5 = coordinates2[1];
      return point6 = null, (lower48Point.point(x5, y5), point6) || (alaskaPoint.point(x5, y5), point6) || (hawaiiPoint.point(x5, y5), point6);
    }
    albersUsa.invert = function(coordinates2) {
      var k3 = lower48.scale(), t = lower48.translate(), x5 = (coordinates2[0] - t[0]) / k3, y5 = (coordinates2[1] - t[1]) / k3;
      return (y5 >= 0.12 && y5 < 0.234 && x5 >= -0.425 && x5 < -0.214 ? alaska : y5 >= 0.166 && y5 < 0.234 && x5 >= -0.214 && x5 < -0.115 ? hawaii : lower48).invert(coordinates2);
    };
    albersUsa.stream = function(stream) {
      return cache2 && cacheStream === stream ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
    };
    albersUsa.precision = function(_25) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_25), alaska.precision(_25), hawaii.precision(_25);
      return reset2();
    };
    albersUsa.scale = function(_25) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_25), alaska.scale(_25 * 0.35), hawaii.scale(_25);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_25) {
      if (!arguments.length) return lower48.translate();
      var k3 = lower48.scale(), x5 = +_25[0], y5 = +_25[1];
      lower48Point = lower48.translate(_25).clipExtent([[x5 - 0.455 * k3, y5 - 0.238 * k3], [x5 + 0.455 * k3, y5 + 0.238 * k3]]).stream(pointStream);
      alaskaPoint = alaska.translate([x5 - 0.307 * k3, y5 + 0.201 * k3]).clipExtent([[x5 - 0.425 * k3 + epsilon7, y5 + 0.12 * k3 + epsilon7], [x5 - 0.214 * k3 - epsilon7, y5 + 0.234 * k3 - epsilon7]]).stream(pointStream);
      hawaiiPoint = hawaii.translate([x5 - 0.205 * k3, y5 + 0.212 * k3]).clipExtent([[x5 - 0.214 * k3 + epsilon7, y5 + 0.166 * k3 + epsilon7], [x5 - 0.115 * k3 - epsilon7, y5 + 0.234 * k3 - epsilon7]]).stream(pointStream);
      return reset2();
    };
    albersUsa.fitExtent = function(extent2, object2) {
      return fitExtent(albersUsa, extent2, object2);
    };
    albersUsa.fitSize = function(size2, object2) {
      return fitSize(albersUsa, size2, object2);
    };
    albersUsa.fitWidth = function(width2, object2) {
      return fitWidth(albersUsa, width2, object2);
    };
    albersUsa.fitHeight = function(height2, object2) {
      return fitHeight(albersUsa, height2, object2);
    };
    function reset2() {
      cache2 = cacheStream = null;
      return albersUsa;
    }
    return albersUsa.scale(1070);
  }

  // node_modules/d3-geo/src/projection/azimuthal.js
  function azimuthalRaw(scale2) {
    return function(x5, y5) {
      var cx = cos2(x5), cy = cos2(y5), k3 = scale2(cx * cy);
      if (k3 === Infinity) return [2, 0];
      return [
        k3 * cy * sin2(x5),
        k3 * sin2(y5)
      ];
    };
  }
  function azimuthalInvert(angle2) {
    return function(x5, y5) {
      var z2 = sqrt(x5 * x5 + y5 * y5), c6 = angle2(z2), sc = sin2(c6), cc2 = cos2(c6);
      return [
        atan2(x5 * sc, z2 * cc2),
        asin(z2 && y5 * sc / z2)
      ];
    };
  }

  // node_modules/d3-geo/src/projection/azimuthalEqualArea.js
  var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
    return sqrt(2 / (1 + cxcy));
  });
  azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z2) {
    return 2 * asin(z2 / 2);
  });
  function azimuthalEqualArea_default() {
    return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
  }

  // node_modules/d3-geo/src/projection/azimuthalEquidistant.js
  var azimuthalEquidistantRaw = azimuthalRaw(function(c6) {
    return (c6 = acos(c6)) && c6 / sin2(c6);
  });
  azimuthalEquidistantRaw.invert = azimuthalInvert(function(z2) {
    return z2;
  });
  function azimuthalEquidistant_default() {
    return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
  }

  // node_modules/d3-geo/src/projection/mercator.js
  function mercatorRaw(lambda, phi2) {
    return [lambda, log(tan((halfPi3 + phi2) / 2))];
  }
  mercatorRaw.invert = function(x5, y5) {
    return [x5, 2 * atan(exp(y5)) - halfPi3];
  };
  function mercator_default() {
    return mercatorProjection(mercatorRaw).scale(961 / tau5);
  }
  function mercatorProjection(project) {
    var m4 = projection(project), center2 = m4.center, scale2 = m4.scale, translate = m4.translate, clipExtent = m4.clipExtent, x06 = null, y06, x12, y12;
    m4.scale = function(_25) {
      return arguments.length ? (scale2(_25), reclip()) : scale2();
    };
    m4.translate = function(_25) {
      return arguments.length ? (translate(_25), reclip()) : translate();
    };
    m4.center = function(_25) {
      return arguments.length ? (center2(_25), reclip()) : center2();
    };
    m4.clipExtent = function(_25) {
      return arguments.length ? (_25 == null ? x06 = y06 = x12 = y12 = null : (x06 = +_25[0][0], y06 = +_25[0][1], x12 = +_25[1][0], y12 = +_25[1][1]), reclip()) : x06 == null ? null : [[x06, y06], [x12, y12]];
    };
    function reclip() {
      var k3 = pi4 * scale2(), t = m4(rotation_default(m4.rotate()).invert([0, 0]));
      return clipExtent(x06 == null ? [[t[0] - k3, t[1] - k3], [t[0] + k3, t[1] + k3]] : project === mercatorRaw ? [[Math.max(t[0] - k3, x06), y06], [Math.min(t[0] + k3, x12), y12]] : [[x06, Math.max(t[1] - k3, y06)], [x12, Math.min(t[1] + k3, y12)]]);
    }
    return reclip();
  }

  // node_modules/d3-geo/src/projection/conicConformal.js
  function tany(y5) {
    return tan((halfPi3 + y5) / 2);
  }
  function conicConformalRaw(y06, y12) {
    var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y06)), f = cy0 * pow2(tany(y06), n) / n;
    if (!n) return mercatorRaw;
    function project(x5, y5) {
      if (f > 0) {
        if (y5 < -halfPi3 + epsilon7) y5 = -halfPi3 + epsilon7;
      } else {
        if (y5 > halfPi3 - epsilon7) y5 = halfPi3 - epsilon7;
      }
      var r = f / pow2(tany(y5), n);
      return [r * sin2(n * x5), f - r * cos2(n * x5)];
    }
    project.invert = function(x5, y5) {
      var fy = f - y5, r = sign(n) * sqrt(x5 * x5 + fy * fy), l2 = atan2(x5, abs3(fy)) * sign(fy);
      if (fy * n < 0)
        l2 -= pi4 * sign(x5) * sign(fy);
      return [l2 / n, 2 * atan(pow2(f / r, 1 / n)) - halfPi3];
    };
    return project;
  }
  function conicConformal_default() {
    return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
  }

  // node_modules/d3-geo/src/projection/equirectangular.js
  function equirectangularRaw(lambda, phi2) {
    return [lambda, phi2];
  }
  equirectangularRaw.invert = equirectangularRaw;
  function equirectangular_default() {
    return projection(equirectangularRaw).scale(152.63);
  }

  // node_modules/d3-geo/src/projection/conicEquidistant.js
  function conicEquidistantRaw(y06, y12) {
    var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : (cy0 - cos2(y12)) / (y12 - y06), g = cy0 / n + y06;
    if (abs3(n) < epsilon7) return equirectangularRaw;
    function project(x5, y5) {
      var gy = g - y5, nx = n * x5;
      return [gy * sin2(nx), g - gy * cos2(nx)];
    }
    project.invert = function(x5, y5) {
      var gy = g - y5, l2 = atan2(x5, abs3(gy)) * sign(gy);
      if (gy * n < 0)
        l2 -= pi4 * sign(x5) * sign(gy);
      return [l2 / n, g - sign(n) * sqrt(x5 * x5 + gy * gy)];
    };
    return project;
  }
  function conicEquidistant_default() {
    return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
  }

  // node_modules/d3-geo/src/projection/equalEarth.js
  var A1 = 1.340264;
  var A2 = -0.081106;
  var A3 = 893e-6;
  var A4 = 3796e-6;
  var M = sqrt(3) / 2;
  var iterations = 12;
  function equalEarthRaw(lambda, phi2) {
    var l2 = asin(M * sin2(phi2)), l22 = l2 * l2, l6 = l22 * l22 * l22;
    return [
      lambda * cos2(l2) / (M * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22))),
      l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22))
    ];
  }
  equalEarthRaw.invert = function(x5, y5) {
    var l2 = y5, l22 = l2 * l2, l6 = l22 * l22 * l22;
    for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
      fy = l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22)) - y5;
      fpy = A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22);
      l2 -= delta = fy / fpy, l22 = l2 * l2, l6 = l22 * l22 * l22;
      if (abs3(delta) < epsilon22) break;
    }
    return [
      M * x5 * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22)) / cos2(l2),
      asin(sin2(l2) / M)
    ];
  };
  function equalEarth_default() {
    return projection(equalEarthRaw).scale(177.158);
  }

  // node_modules/d3-geo/src/projection/gnomonic.js
  function gnomonicRaw(x5, y5) {
    var cy = cos2(y5), k3 = cos2(x5) * cy;
    return [cy * sin2(x5) / k3, sin2(y5) / k3];
  }
  gnomonicRaw.invert = azimuthalInvert(atan);
  function gnomonic_default() {
    return projection(gnomonicRaw).scale(144.049).clipAngle(60);
  }

  // node_modules/d3-geo/src/projection/identity.js
  function identity_default4() {
    var k3 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca3, sa, x06 = null, y06, x12, y12, kx2 = 1, ky2 = 1, transform2 = transformer({
      point: function(x5, y5) {
        var p = projection2([x5, y5]);
        this.stream.point(p[0], p[1]);
      }
    }), postclip = identity_default3, cache2, cacheStream;
    function reset2() {
      kx2 = k3 * sx;
      ky2 = k3 * sy;
      cache2 = cacheStream = null;
      return projection2;
    }
    function projection2(p) {
      var x5 = p[0] * kx2, y5 = p[1] * ky2;
      if (alpha) {
        var t = y5 * ca3 - x5 * sa;
        x5 = x5 * ca3 + y5 * sa;
        y5 = t;
      }
      return [x5 + tx, y5 + ty];
    }
    projection2.invert = function(p) {
      var x5 = p[0] - tx, y5 = p[1] - ty;
      if (alpha) {
        var t = y5 * ca3 + x5 * sa;
        x5 = x5 * ca3 - y5 * sa;
        y5 = t;
      }
      return [x5 / kx2, y5 / ky2];
    };
    projection2.stream = function(stream) {
      return cache2 && cacheStream === stream ? cache2 : cache2 = transform2(postclip(cacheStream = stream));
    };
    projection2.postclip = function(_25) {
      return arguments.length ? (postclip = _25, x06 = y06 = x12 = y12 = null, reset2()) : postclip;
    };
    projection2.clipExtent = function(_25) {
      return arguments.length ? (postclip = _25 == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_25[0][0], y06 = +_25[0][1], x12 = +_25[1][0], y12 = +_25[1][1]), reset2()) : x06 == null ? null : [[x06, y06], [x12, y12]];
    };
    projection2.scale = function(_25) {
      return arguments.length ? (k3 = +_25, reset2()) : k3;
    };
    projection2.translate = function(_25) {
      return arguments.length ? (tx = +_25[0], ty = +_25[1], reset2()) : [tx, ty];
    };
    projection2.angle = function(_25) {
      return arguments.length ? (alpha = _25 % 360 * radians2, sa = sin2(alpha), ca3 = cos2(alpha), reset2()) : alpha * degrees3;
    };
    projection2.reflectX = function(_25) {
      return arguments.length ? (sx = _25 ? -1 : 1, reset2()) : sx < 0;
    };
    projection2.reflectY = function(_25) {
      return arguments.length ? (sy = _25 ? -1 : 1, reset2()) : sy < 0;
    };
    projection2.fitExtent = function(extent2, object2) {
      return fitExtent(projection2, extent2, object2);
    };
    projection2.fitSize = function(size2, object2) {
      return fitSize(projection2, size2, object2);
    };
    projection2.fitWidth = function(width2, object2) {
      return fitWidth(projection2, width2, object2);
    };
    projection2.fitHeight = function(height2, object2) {
      return fitHeight(projection2, height2, object2);
    };
    return projection2;
  }

  // node_modules/d3-geo/src/projection/naturalEarth1.js
  function naturalEarth1Raw(lambda, phi2) {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    return [
      lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
      phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
    ];
  }
  naturalEarth1Raw.invert = function(x5, y5) {
    var phi2 = y5, i = 25, delta;
    do {
      var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
      phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y5) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
    } while (abs3(delta) > epsilon7 && --i > 0);
    return [
      x5 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
      phi2
    ];
  };
  function naturalEarth1_default() {
    return projection(naturalEarth1Raw).scale(175.295);
  }

  // node_modules/d3-geo/src/projection/orthographic.js
  function orthographicRaw(x5, y5) {
    return [cos2(y5) * sin2(x5), sin2(y5)];
  }
  orthographicRaw.invert = azimuthalInvert(asin);
  function orthographic_default() {
    return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon7);
  }

  // node_modules/d3-geo/src/projection/stereographic.js
  function stereographicRaw(x5, y5) {
    var cy = cos2(y5), k3 = 1 + cos2(x5) * cy;
    return [cy * sin2(x5) / k3, sin2(y5) / k3];
  }
  stereographicRaw.invert = azimuthalInvert(function(z2) {
    return 2 * atan(z2);
  });
  function stereographic_default() {
    return projection(stereographicRaw).scale(250).clipAngle(142);
  }

  // node_modules/d3-geo/src/projection/transverseMercator.js
  function transverseMercatorRaw(lambda, phi2) {
    return [log(tan((halfPi3 + phi2) / 2)), -lambda];
  }
  transverseMercatorRaw.invert = function(x5, y5) {
    return [-y5, 2 * atan(exp(x5)) - halfPi3];
  };
  function transverseMercator_default() {
    var m4 = mercatorProjection(transverseMercatorRaw), center2 = m4.center, rotate = m4.rotate;
    m4.center = function(_25) {
      return arguments.length ? center2([-_25[1], _25[0]]) : (_25 = center2(), [_25[1], -_25[0]]);
    };
    m4.rotate = function(_25) {
      return arguments.length ? rotate([_25[0], _25[1], _25.length > 2 ? _25[2] + 90 : 90]) : (_25 = rotate(), [_25[0], _25[1], _25[2] - 90]);
    };
    return rotate([0, 0, 90]).scale(159.155);
  }

  // node_modules/d3-hierarchy/src/cluster.js
  function defaultSeparation(a4, b10) {
    return a4.parent === b10.parent ? 1 : 2;
  }
  function meanX(children2) {
    return children2.reduce(meanXReduce, 0) / children2.length;
  }
  function meanXReduce(x5, c6) {
    return x5 + c6.x;
  }
  function maxY(children2) {
    return 1 + children2.reduce(maxYReduce, 0);
  }
  function maxYReduce(y5, c6) {
    return Math.max(y5, c6.y);
  }
  function leafLeft(node) {
    var children2;
    while (children2 = node.children) node = children2[0];
    return node;
  }
  function leafRight(node) {
    var children2;
    while (children2 = node.children) node = children2[children2.length - 1];
    return node;
  }
  function cluster_default() {
    var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
    function cluster(root21) {
      var previousNode, x5 = 0;
      root21.eachAfter(function(node) {
        var children2 = node.children;
        if (children2) {
          node.x = meanX(children2);
          node.y = maxY(children2);
        } else {
          node.x = previousNode ? x5 += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left2 = leafLeft(root21), right2 = leafRight(root21), x06 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
      return root21.eachAfter(nodeSize ? function(node) {
        node.x = (node.x - root21.x) * dx;
        node.y = (root21.y - node.y) * dy;
      } : function(node) {
        node.x = (node.x - x06) / (x12 - x06) * dx;
        node.y = (1 - (root21.y ? node.y / root21.y : 1)) * dy;
      });
    }
    cluster.separation = function(x5) {
      return arguments.length ? (separation = x5, cluster) : separation;
    };
    cluster.size = function(x5) {
      return arguments.length ? (nodeSize = false, dx = +x5[0], dy = +x5[1], cluster) : nodeSize ? null : [dx, dy];
    };
    cluster.nodeSize = function(x5) {
      return arguments.length ? (nodeSize = true, dx = +x5[0], dy = +x5[1], cluster) : nodeSize ? [dx, dy] : null;
    };
    return cluster;
  }

  // node_modules/d3-hierarchy/src/hierarchy/count.js
  function count2(node) {
    var sum4 = 0, children2 = node.children, i = children2 && children2.length;
    if (!i) sum4 = 1;
    else while (--i >= 0) sum4 += children2[i].value;
    node.value = sum4;
  }
  function count_default() {
    return this.eachAfter(count2);
  }

  // node_modules/d3-hierarchy/src/hierarchy/each.js
  function each_default2(callback, that) {
    let index4 = -1;
    for (const node of this) {
      callback.call(that, node, ++index4, this);
    }
    return this;
  }

  // node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
  function eachBefore_default(callback, that) {
    var node = this, nodes = [node], children2, i, index4 = -1;
    while (node = nodes.pop()) {
      callback.call(that, node, ++index4, this);
      if (children2 = node.children) {
        for (i = children2.length - 1; i >= 0; --i) {
          nodes.push(children2[i]);
        }
      }
    }
    return this;
  }

  // node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
  function eachAfter_default(callback, that) {
    var node = this, nodes = [node], next2 = [], children2, i, n, index4 = -1;
    while (node = nodes.pop()) {
      next2.push(node);
      if (children2 = node.children) {
        for (i = 0, n = children2.length; i < n; ++i) {
          nodes.push(children2[i]);
        }
      }
    }
    while (node = next2.pop()) {
      callback.call(that, node, ++index4, this);
    }
    return this;
  }

  // node_modules/d3-hierarchy/src/hierarchy/find.js
  function find_default2(callback, that) {
    let index4 = -1;
    for (const node of this) {
      if (callback.call(that, node, ++index4, this)) {
        return node;
      }
    }
  }

  // node_modules/d3-hierarchy/src/hierarchy/sum.js
  function sum_default(value) {
    return this.eachAfter(function(node) {
      var sum4 = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;
      while (--i >= 0) sum4 += children2[i].value;
      node.value = sum4;
    });
  }

  // node_modules/d3-hierarchy/src/hierarchy/sort.js
  function sort_default2(compare) {
    return this.eachBefore(function(node) {
      if (node.children) {
        node.children.sort(compare);
      }
    });
  }

  // node_modules/d3-hierarchy/src/hierarchy/path.js
  function path_default2(end) {
    var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
    while (start2 !== ancestor) {
      start2 = start2.parent;
      nodes.push(start2);
    }
    var k3 = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k3, 0, end);
      end = end.parent;
    }
    return nodes;
  }
  function leastCommonAncestor(a4, b10) {
    if (a4 === b10) return a4;
    var aNodes = a4.ancestors(), bNodes = b10.ancestors(), c6 = null;
    a4 = aNodes.pop();
    b10 = bNodes.pop();
    while (a4 === b10) {
      c6 = a4;
      a4 = aNodes.pop();
      b10 = bNodes.pop();
    }
    return c6;
  }

  // node_modules/d3-hierarchy/src/hierarchy/ancestors.js
  function ancestors_default() {
    var node = this, nodes = [node];
    while (node = node.parent) {
      nodes.push(node);
    }
    return nodes;
  }

  // node_modules/d3-hierarchy/src/hierarchy/descendants.js
  function descendants_default() {
    return Array.from(this);
  }

  // node_modules/d3-hierarchy/src/hierarchy/leaves.js
  function leaves_default() {
    var leaves = [];
    this.eachBefore(function(node) {
      if (!node.children) {
        leaves.push(node);
      }
    });
    return leaves;
  }

  // node_modules/d3-hierarchy/src/hierarchy/links.js
  function links_default() {
    var root21 = this, links = [];
    root21.each(function(node) {
      if (node !== root21) {
        links.push({ source: node.parent, target: node });
      }
    });
    return links;
  }

  // node_modules/d3-hierarchy/src/hierarchy/iterator.js
  function* iterator_default2() {
    var node = this, current, next2 = [node], children2, i, n;
    do {
      current = next2.reverse(), next2 = [];
      while (node = current.pop()) {
        yield node;
        if (children2 = node.children) {
          for (i = 0, n = children2.length; i < n; ++i) {
            next2.push(children2[i]);
          }
        }
      }
    } while (next2.length);
  }

  // node_modules/d3-hierarchy/src/hierarchy/index.js
  function hierarchy(data2, children2) {
    if (data2 instanceof Map) {
      data2 = [void 0, data2];
      if (children2 === void 0) children2 = mapChildren;
    } else if (children2 === void 0) {
      children2 = objectChildren;
    }
    var root21 = new Node2(data2), node, nodes = [root21], child2, childs, i, n;
    while (node = nodes.pop()) {
      if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
        node.children = childs;
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child2 = childs[i] = new Node2(childs[i]));
          child2.parent = node;
          child2.depth = node.depth + 1;
        }
      }
    }
    return root21.eachBefore(computeHeight);
  }
  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }
  function objectChildren(d) {
    return d.children;
  }
  function mapChildren(d) {
    return Array.isArray(d) ? d[1] : null;
  }
  function copyData(node) {
    if (node.data.value !== void 0) node.value = node.data.value;
    node.data = node.data.data;
  }
  function computeHeight(node) {
    var height2 = 0;
    do
      node.height = height2;
    while ((node = node.parent) && node.height < ++height2);
  }
  function Node2(data2) {
    this.data = data2;
    this.depth = this.height = 0;
    this.parent = null;
  }
  Node2.prototype = hierarchy.prototype = {
    constructor: Node2,
    count: count_default,
    each: each_default2,
    eachAfter: eachAfter_default,
    eachBefore: eachBefore_default,
    find: find_default2,
    sum: sum_default,
    sort: sort_default2,
    path: path_default2,
    ancestors: ancestors_default,
    descendants: descendants_default,
    leaves: leaves_default,
    links: links_default,
    copy: node_copy,
    [Symbol.iterator]: iterator_default2
  };

  // node_modules/d3-hierarchy/src/accessors.js
  function optional(f) {
    return f == null ? null : required(f);
  }
  function required(f) {
    if (typeof f !== "function") throw new Error();
    return f;
  }

  // node_modules/d3-hierarchy/src/constant.js
  function constantZero() {
    return 0;
  }
  function constant_default9(x5) {
    return function() {
      return x5;
    };
  }

  // node_modules/d3-hierarchy/src/lcg.js
  var a2 = 1664525;
  var c2 = 1013904223;
  var m2 = 4294967296;
  function lcg_default2() {
    let s2 = 1;
    return () => (s2 = (a2 * s2 + c2) % m2) / m2;
  }

  // node_modules/d3-hierarchy/src/array.js
  function array_default2(x5) {
    return typeof x5 === "object" && "length" in x5 ? x5 : Array.from(x5);
  }
  function shuffle(array4, random) {
    let m4 = array4.length, t, i;
    while (m4) {
      i = random() * m4-- | 0;
      t = array4[m4];
      array4[m4] = array4[i];
      array4[i] = t;
    }
    return array4;
  }

  // node_modules/d3-hierarchy/src/pack/enclose.js
  function enclose_default(circles) {
    return packEncloseRandom(circles, lcg_default2());
  }
  function packEncloseRandom(circles, random) {
    var i = 0, n = (circles = shuffle(Array.from(circles), random)).length, B4 = [], p, e;
    while (i < n) {
      p = circles[i];
      if (e && enclosesWeak(e, p)) ++i;
      else e = encloseBasis(B4 = extendBasis(B4, p)), i = 0;
    }
    return e;
  }
  function extendBasis(B4, p) {
    var i, j2;
    if (enclosesWeakAll(p, B4)) return [p];
    for (i = 0; i < B4.length; ++i) {
      if (enclosesNot(p, B4[i]) && enclosesWeakAll(encloseBasis2(B4[i], p), B4)) {
        return [B4[i], p];
      }
    }
    for (i = 0; i < B4.length - 1; ++i) {
      for (j2 = i + 1; j2 < B4.length; ++j2) {
        if (enclosesNot(encloseBasis2(B4[i], B4[j2]), p) && enclosesNot(encloseBasis2(B4[i], p), B4[j2]) && enclosesNot(encloseBasis2(B4[j2], p), B4[i]) && enclosesWeakAll(encloseBasis3(B4[i], B4[j2], p), B4)) {
          return [B4[i], B4[j2], p];
        }
      }
    }
    throw new Error();
  }
  function enclosesNot(a4, b10) {
    var dr = a4.r - b10.r, dx = b10.x - a4.x, dy = b10.y - a4.y;
    return dr < 0 || dr * dr < dx * dx + dy * dy;
  }
  function enclosesWeak(a4, b10) {
    var dr = a4.r - b10.r + Math.max(a4.r, b10.r, 1) * 1e-9, dx = b10.x - a4.x, dy = b10.y - a4.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }
  function enclosesWeakAll(a4, B4) {
    for (var i = 0; i < B4.length; ++i) {
      if (!enclosesWeak(a4, B4[i])) {
        return false;
      }
    }
    return true;
  }
  function encloseBasis(B4) {
    switch (B4.length) {
      case 1:
        return encloseBasis1(B4[0]);
      case 2:
        return encloseBasis2(B4[0], B4[1]);
      case 3:
        return encloseBasis3(B4[0], B4[1], B4[2]);
    }
  }
  function encloseBasis1(a4) {
    return {
      x: a4.x,
      y: a4.y,
      r: a4.r
    };
  }
  function encloseBasis2(a4, b10) {
    var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b10.x, y22 = b10.y, r2 = b10.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l2 = Math.sqrt(x21 * x21 + y21 * y21);
    return {
      x: (x12 + x22 + x21 / l2 * r21) / 2,
      y: (y12 + y22 + y21 / l2 * r21) / 2,
      r: (l2 + r1 + r2) / 2
    };
  }
  function encloseBasis3(a4, b10, c6) {
    var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b10.x, y22 = b10.y, r2 = b10.r, x32 = c6.x, y32 = c6.y, r3 = c6.r, a22 = x12 - x22, a32 = x12 - x32, b22 = y12 - y22, b32 = y12 - y32, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3, ab4 = a32 * b22 - a22 * b32, xa = (b22 * d3 - b32 * d2) / (ab4 * 2) - x12, xb = (b32 * c22 - b22 * c32) / ab4, ya = (a32 * d2 - a22 * d3) / (ab4 * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab4, A6 = xb * xb + yb * yb - 1, B4 = 2 * (r1 + xa * xb + ya * yb), C4 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A6) > 1e-6 ? (B4 + Math.sqrt(B4 * B4 - 4 * A6 * C4)) / (2 * A6) : C4 / B4);
    return {
      x: x12 + xa + xb * r,
      y: y12 + ya + yb * r,
      r
    };
  }

  // node_modules/d3-hierarchy/src/pack/siblings.js
  function place(b10, a4, c6) {
    var dx = b10.x - a4.x, x5, a22, dy = b10.y - a4.y, y5, b22, d2 = dx * dx + dy * dy;
    if (d2) {
      a22 = a4.r + c6.r, a22 *= a22;
      b22 = b10.r + c6.r, b22 *= b22;
      if (a22 > b22) {
        x5 = (d2 + b22 - a22) / (2 * d2);
        y5 = Math.sqrt(Math.max(0, b22 / d2 - x5 * x5));
        c6.x = b10.x - x5 * dx - y5 * dy;
        c6.y = b10.y - x5 * dy + y5 * dx;
      } else {
        x5 = (d2 + a22 - b22) / (2 * d2);
        y5 = Math.sqrt(Math.max(0, a22 / d2 - x5 * x5));
        c6.x = a4.x + x5 * dx - y5 * dy;
        c6.y = a4.y + x5 * dy + y5 * dx;
      }
    } else {
      c6.x = a4.x + c6.r;
      c6.y = a4.y;
    }
  }
  function intersects(a4, b10) {
    var dr = a4.r + b10.r - 1e-6, dx = b10.x - a4.x, dy = b10.y - a4.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }
  function score(node) {
    var a4 = node._, b10 = node.next._, ab4 = a4.r + b10.r, dx = (a4.x * b10.r + b10.x * a4.r) / ab4, dy = (a4.y * b10.r + b10.y * a4.r) / ab4;
    return dx * dx + dy * dy;
  }
  function Node3(circle) {
    this._ = circle;
    this.next = null;
    this.previous = null;
  }
  function packSiblingsRandom(circles, random) {
    if (!(n = (circles = array_default2(circles)).length)) return 0;
    var a4, b10, c6, n, aa2, ca3, i, j2, k3, sj, sk;
    a4 = circles[0], a4.x = 0, a4.y = 0;
    if (!(n > 1)) return a4.r;
    b10 = circles[1], a4.x = -b10.r, b10.x = a4.r, b10.y = 0;
    if (!(n > 2)) return a4.r + b10.r;
    place(b10, a4, c6 = circles[2]);
    a4 = new Node3(a4), b10 = new Node3(b10), c6 = new Node3(c6);
    a4.next = c6.previous = b10;
    b10.next = a4.previous = c6;
    c6.next = b10.previous = a4;
    pack: for (i = 3; i < n; ++i) {
      place(a4._, b10._, c6 = circles[i]), c6 = new Node3(c6);
      j2 = b10.next, k3 = a4.previous, sj = b10._.r, sk = a4._.r;
      do {
        if (sj <= sk) {
          if (intersects(j2._, c6._)) {
            b10 = j2, a4.next = b10, b10.previous = a4, --i;
            continue pack;
          }
          sj += j2._.r, j2 = j2.next;
        } else {
          if (intersects(k3._, c6._)) {
            a4 = k3, a4.next = b10, b10.previous = a4, --i;
            continue pack;
          }
          sk += k3._.r, k3 = k3.previous;
        }
      } while (j2 !== k3.next);
      c6.previous = a4, c6.next = b10, a4.next = b10.previous = b10 = c6;
      aa2 = score(a4);
      while ((c6 = c6.next) !== b10) {
        if ((ca3 = score(c6)) < aa2) {
          a4 = c6, aa2 = ca3;
        }
      }
      b10 = a4.next;
    }
    a4 = [b10._], c6 = b10;
    while ((c6 = c6.next) !== b10) a4.push(c6._);
    c6 = packEncloseRandom(a4, random);
    for (i = 0; i < n; ++i) a4 = circles[i], a4.x -= c6.x, a4.y -= c6.y;
    return c6.r;
  }
  function siblings_default(circles) {
    packSiblingsRandom(circles, lcg_default2());
    return circles;
  }

  // node_modules/d3-hierarchy/src/pack/index.js
  function defaultRadius2(d) {
    return Math.sqrt(d.value);
  }
  function pack_default() {
    var radius = null, dx = 1, dy = 1, padding = constantZero;
    function pack(root21) {
      const random = lcg_default2();
      root21.x = dx / 2, root21.y = dy / 2;
      if (radius) {
        root21.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding, 0.5, random)).eachBefore(translateChild(1));
      } else {
        root21.eachBefore(radiusLeaf(defaultRadius2)).eachAfter(packChildrenRandom(constantZero, 1, random)).eachAfter(packChildrenRandom(padding, root21.r / Math.min(dx, dy), random)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root21.r)));
      }
      return root21;
    }
    pack.radius = function(x5) {
      return arguments.length ? (radius = optional(x5), pack) : radius;
    };
    pack.size = function(x5) {
      return arguments.length ? (dx = +x5[0], dy = +x5[1], pack) : [dx, dy];
    };
    pack.padding = function(x5) {
      return arguments.length ? (padding = typeof x5 === "function" ? x5 : constant_default9(+x5), pack) : padding;
    };
    return pack;
  }
  function radiusLeaf(radius) {
    return function(node) {
      if (!node.children) {
        node.r = Math.max(0, +radius(node) || 0);
      }
    };
  }
  function packChildrenRandom(padding, k3, random) {
    return function(node) {
      if (children2 = node.children) {
        var children2, i, n = children2.length, r = padding(node) * k3 || 0, e;
        if (r) for (i = 0; i < n; ++i) children2[i].r += r;
        e = packSiblingsRandom(children2, random);
        if (r) for (i = 0; i < n; ++i) children2[i].r -= r;
        node.r = e + r;
      }
    };
  }
  function translateChild(k3) {
    return function(node) {
      var parent = node.parent;
      node.r *= k3;
      if (parent) {
        node.x = parent.x + k3 * node.x;
        node.y = parent.y + k3 * node.y;
      }
    };
  }

  // node_modules/d3-hierarchy/src/treemap/round.js
  function round_default2(node) {
    node.x0 = Math.round(node.x0);
    node.y0 = Math.round(node.y0);
    node.x1 = Math.round(node.x1);
    node.y1 = Math.round(node.y1);
  }

  // node_modules/d3-hierarchy/src/treemap/dice.js
  function dice_default(parent, x06, y06, x12, y12) {
    var nodes = parent.children, node, i = -1, n = nodes.length, k3 = parent.value && (x12 - x06) / parent.value;
    while (++i < n) {
      node = nodes[i], node.y0 = y06, node.y1 = y12;
      node.x0 = x06, node.x1 = x06 += node.value * k3;
    }
  }

  // node_modules/d3-hierarchy/src/partition.js
  function partition_default() {
    var dx = 1, dy = 1, padding = 0, round = false;
    function partition(root21) {
      var n = root21.height + 1;
      root21.x0 = root21.y0 = padding;
      root21.x1 = dx;
      root21.y1 = dy / n;
      root21.eachBefore(positionNode(dy, n));
      if (round) root21.eachBefore(round_default2);
      return root21;
    }
    function positionNode(dy2, n) {
      return function(node) {
        if (node.children) {
          dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
        }
        var x06 = node.x0, y06 = node.y0, x12 = node.x1 - padding, y12 = node.y1 - padding;
        if (x12 < x06) x06 = x12 = (x06 + x12) / 2;
        if (y12 < y06) y06 = y12 = (y06 + y12) / 2;
        node.x0 = x06;
        node.y0 = y06;
        node.x1 = x12;
        node.y1 = y12;
      };
    }
    partition.round = function(x5) {
      return arguments.length ? (round = !!x5, partition) : round;
    };
    partition.size = function(x5) {
      return arguments.length ? (dx = +x5[0], dy = +x5[1], partition) : [dx, dy];
    };
    partition.padding = function(x5) {
      return arguments.length ? (padding = +x5, partition) : padding;
    };
    return partition;
  }

  // node_modules/d3-hierarchy/src/stratify.js
  var preroot = { depth: -1 };
  var ambiguous = {};
  var imputed = {};
  function defaultId(d) {
    return d.id;
  }
  function defaultParentId(d) {
    return d.parentId;
  }
  function stratify_default() {
    var id2 = defaultId, parentId = defaultParentId, path2;
    function stratify(data2) {
      var nodes = Array.from(data2), currentId = id2, currentParentId = parentId, n, d, i, root21, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
      if (path2 != null) {
        const I2 = nodes.map((d2, i2) => normalize(path2(d2, i2, data2)));
        const P2 = I2.map(parentof);
        const S2 = new Set(I2).add("");
        for (const i2 of P2) {
          if (!S2.has(i2)) {
            S2.add(i2);
            I2.push(i2);
            P2.push(parentof(i2));
            nodes.push(imputed);
          }
        }
        currentId = (_25, i2) => I2[i2];
        currentParentId = (_25, i2) => P2[i2];
      }
      for (i = 0, n = nodes.length; i < n; ++i) {
        d = nodes[i], node = nodes[i] = new Node2(d);
        if ((nodeId = currentId(d, i, data2)) != null && (nodeId += "")) {
          nodeKey = node.id = nodeId;
          nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
        }
        if ((nodeId = currentParentId(d, i, data2)) != null && (nodeId += "")) {
          node.parent = nodeId;
        }
      }
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (nodeId = node.parent) {
          parent = nodeByKey.get(nodeId);
          if (!parent) throw new Error("missing: " + nodeId);
          if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
          if (parent.children) parent.children.push(node);
          else parent.children = [node];
          node.parent = parent;
        } else {
          if (root21) throw new Error("multiple roots");
          root21 = node;
        }
      }
      if (!root21) throw new Error("no root");
      if (path2 != null) {
        while (root21.data === imputed && root21.children.length === 1) {
          root21 = root21.children[0], --n;
        }
        for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
          node = nodes[i2];
          if (node.data !== imputed) break;
          node.data = null;
        }
      }
      root21.parent = preroot;
      root21.eachBefore(function(node2) {
        node2.depth = node2.parent.depth + 1;
        --n;
      }).eachBefore(computeHeight);
      root21.parent = null;
      if (n > 0) throw new Error("cycle");
      return root21;
    }
    stratify.id = function(x5) {
      return arguments.length ? (id2 = optional(x5), stratify) : id2;
    };
    stratify.parentId = function(x5) {
      return arguments.length ? (parentId = optional(x5), stratify) : parentId;
    };
    stratify.path = function(x5) {
      return arguments.length ? (path2 = optional(x5), stratify) : path2;
    };
    return stratify;
  }
  function normalize(path2) {
    path2 = `${path2}`;
    let i = path2.length;
    if (slash(path2, i - 1) && !slash(path2, i - 2)) path2 = path2.slice(0, -1);
    return path2[0] === "/" ? path2 : `/${path2}`;
  }
  function parentof(path2) {
    let i = path2.length;
    if (i < 2) return "";
    while (--i > 1) if (slash(path2, i)) break;
    return path2.slice(0, i);
  }
  function slash(path2, i) {
    if (path2[i] === "/") {
      let k3 = 0;
      while (i > 0 && path2[--i] === "\\") ++k3;
      if ((k3 & 1) === 0) return true;
    }
    return false;
  }

  // node_modules/d3-hierarchy/src/tree.js
  function defaultSeparation2(a4, b10) {
    return a4.parent === b10.parent ? 1 : 2;
  }
  function nextLeft(v3) {
    var children2 = v3.children;
    return children2 ? children2[0] : v3.t;
  }
  function nextRight(v3) {
    var children2 = v3.children;
    return children2 ? children2[children2.length - 1] : v3.t;
  }
  function moveSubtree(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function executeShifts(v3) {
    var shift = 0, change = 0, children2 = v3.children, i = children2.length, w;
    while (--i >= 0) {
      w = children2[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function nextAncestor(vim, v3, ancestor) {
    return vim.a.parent === v3.parent ? vim.a : ancestor;
  }
  function TreeNode(node, i) {
    this._ = node;
    this.parent = null;
    this.children = null;
    this.A = null;
    this.a = this;
    this.z = 0;
    this.m = 0;
    this.c = 0;
    this.s = 0;
    this.t = null;
    this.i = i;
  }
  TreeNode.prototype = Object.create(Node2.prototype);
  function treeRoot(root21) {
    var tree = new TreeNode(root21, 0), node, nodes = [tree], child2, children2, i, n;
    while (node = nodes.pop()) {
      if (children2 = node._.children) {
        node.children = new Array(n = children2.length);
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child2 = node.children[i] = new TreeNode(children2[i], i));
          child2.parent = node;
        }
      }
    }
    (tree.parent = new TreeNode(null, 0)).children = [tree];
    return tree;
  }
  function tree_default() {
    var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
    function tree(root21) {
      var t = treeRoot(root21);
      t.eachAfter(firstWalk), t.parent.m = -t.z;
      t.eachBefore(secondWalk);
      if (nodeSize) root21.eachBefore(sizeNode);
      else {
        var left2 = root21, right2 = root21, bottom2 = root21;
        root21.eachBefore(function(node) {
          if (node.x < left2.x) left2 = node;
          if (node.x > right2.x) right2 = node;
          if (node.depth > bottom2.depth) bottom2 = node;
        });
        var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx2 = dx / (right2.x + s2 + tx), ky2 = dy / (bottom2.depth || 1);
        root21.eachBefore(function(node) {
          node.x = (node.x + tx) * kx2;
          node.y = node.depth * ky2;
        });
      }
      return root21;
    }
    function firstWalk(v3) {
      var children2 = v3.children, siblings = v3.parent.children, w = v3.i ? siblings[v3.i - 1] : null;
      if (children2) {
        executeShifts(v3);
        var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
        if (w) {
          v3.z = w.z + separation(v3._, w._);
          v3.m = v3.z - midpoint;
        } else {
          v3.z = midpoint;
        }
      } else if (w) {
        v3.z = w.z + separation(v3._, w._);
      }
      v3.parent.A = apportion(v3, w, v3.parent.A || siblings[0]);
    }
    function secondWalk(v3) {
      v3._.x = v3.z + v3.parent.m;
      v3.m += v3.parent.m;
    }
    function apportion(v3, w, ancestor) {
      if (w) {
        var vip = v3, vop = v3, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
          vom = nextLeft(vom);
          vop = nextRight(vop);
          vop.a = v3;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            moveSubtree(nextAncestor(vim, v3, ancestor), v3, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !nextRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !nextLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v3;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= dx;
      node.y = node.depth * dy;
    }
    tree.separation = function(x5) {
      return arguments.length ? (separation = x5, tree) : separation;
    };
    tree.size = function(x5) {
      return arguments.length ? (nodeSize = false, dx = +x5[0], dy = +x5[1], tree) : nodeSize ? null : [dx, dy];
    };
    tree.nodeSize = function(x5) {
      return arguments.length ? (nodeSize = true, dx = +x5[0], dy = +x5[1], tree) : nodeSize ? [dx, dy] : null;
    };
    return tree;
  }

  // node_modules/d3-hierarchy/src/treemap/slice.js
  function slice_default(parent, x06, y06, x12, y12) {
    var nodes = parent.children, node, i = -1, n = nodes.length, k3 = parent.value && (y12 - y06) / parent.value;
    while (++i < n) {
      node = nodes[i], node.x0 = x06, node.x1 = x12;
      node.y0 = y06, node.y1 = y06 += node.value * k3;
    }
  }

  // node_modules/d3-hierarchy/src/treemap/squarify.js
  var phi = (1 + Math.sqrt(5)) / 2;
  function squarifyRatio(ratio, parent, x06, y06, x12, y12) {
    var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
    while (i0 < n) {
      dx = x12 - x06, dy = y12 - y06;
      do
        sumValue = nodes[i1++].value;
      while (!sumValue && i1 < n);
      minValue = maxValue = sumValue;
      alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
      beta = sumValue * sumValue * alpha;
      minRatio = Math.max(maxValue / beta, beta / minValue);
      for (; i1 < n; ++i1) {
        sumValue += nodeValue = nodes[i1].value;
        if (nodeValue < minValue) minValue = nodeValue;
        if (nodeValue > maxValue) maxValue = nodeValue;
        beta = sumValue * sumValue * alpha;
        newRatio = Math.max(maxValue / beta, beta / minValue);
        if (newRatio > minRatio) {
          sumValue -= nodeValue;
          break;
        }
        minRatio = newRatio;
      }
      rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
      if (row.dice) dice_default(row, x06, y06, x12, value ? y06 += dy * sumValue / value : y12);
      else slice_default(row, x06, y06, value ? x06 += dx * sumValue / value : x12, y12);
      value -= sumValue, i0 = i1;
    }
    return rows;
  }
  var squarify_default = function custom10(ratio) {
    function squarify(parent, x06, y06, x12, y12) {
      squarifyRatio(ratio, parent, x06, y06, x12, y12);
    }
    squarify.ratio = function(x5) {
      return custom10((x5 = +x5) > 1 ? x5 : 1);
    };
    return squarify;
  }(phi);

  // node_modules/d3-hierarchy/src/treemap/index.js
  function treemap_default() {
    var tile = squarify_default, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
    function treemap(root21) {
      root21.x0 = root21.y0 = 0;
      root21.x1 = dx;
      root21.y1 = dy;
      root21.eachBefore(positionNode);
      paddingStack = [0];
      if (round) root21.eachBefore(round_default2);
      return root21;
    }
    function positionNode(node) {
      var p = paddingStack[node.depth], x06 = node.x0 + p, y06 = node.y0 + p, x12 = node.x1 - p, y12 = node.y1 - p;
      if (x12 < x06) x06 = x12 = (x06 + x12) / 2;
      if (y12 < y06) y06 = y12 = (y06 + y12) / 2;
      node.x0 = x06;
      node.y0 = y06;
      node.x1 = x12;
      node.y1 = y12;
      if (node.children) {
        p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
        x06 += paddingLeft(node) - p;
        y06 += paddingTop(node) - p;
        x12 -= paddingRight(node) - p;
        y12 -= paddingBottom(node) - p;
        if (x12 < x06) x06 = x12 = (x06 + x12) / 2;
        if (y12 < y06) y06 = y12 = (y06 + y12) / 2;
        tile(node, x06, y06, x12, y12);
      }
    }
    treemap.round = function(x5) {
      return arguments.length ? (round = !!x5, treemap) : round;
    };
    treemap.size = function(x5) {
      return arguments.length ? (dx = +x5[0], dy = +x5[1], treemap) : [dx, dy];
    };
    treemap.tile = function(x5) {
      return arguments.length ? (tile = required(x5), treemap) : tile;
    };
    treemap.padding = function(x5) {
      return arguments.length ? treemap.paddingInner(x5).paddingOuter(x5) : treemap.paddingInner();
    };
    treemap.paddingInner = function(x5) {
      return arguments.length ? (paddingInner = typeof x5 === "function" ? x5 : constant_default9(+x5), treemap) : paddingInner;
    };
    treemap.paddingOuter = function(x5) {
      return arguments.length ? treemap.paddingTop(x5).paddingRight(x5).paddingBottom(x5).paddingLeft(x5) : treemap.paddingTop();
    };
    treemap.paddingTop = function(x5) {
      return arguments.length ? (paddingTop = typeof x5 === "function" ? x5 : constant_default9(+x5), treemap) : paddingTop;
    };
    treemap.paddingRight = function(x5) {
      return arguments.length ? (paddingRight = typeof x5 === "function" ? x5 : constant_default9(+x5), treemap) : paddingRight;
    };
    treemap.paddingBottom = function(x5) {
      return arguments.length ? (paddingBottom = typeof x5 === "function" ? x5 : constant_default9(+x5), treemap) : paddingBottom;
    };
    treemap.paddingLeft = function(x5) {
      return arguments.length ? (paddingLeft = typeof x5 === "function" ? x5 : constant_default9(+x5), treemap) : paddingLeft;
    };
    return treemap;
  }

  // node_modules/d3-hierarchy/src/treemap/binary.js
  function binary_default(parent, x06, y06, x12, y12) {
    var nodes = parent.children, i, n = nodes.length, sum4, sums = new Array(n + 1);
    for (sums[0] = sum4 = i = 0; i < n; ++i) {
      sums[i + 1] = sum4 += nodes[i].value;
    }
    partition(0, n, parent.value, x06, y06, x12, y12);
    function partition(i2, j2, value, x07, y07, x13, y13) {
      if (i2 >= j2 - 1) {
        var node = nodes[i2];
        node.x0 = x07, node.y0 = y07;
        node.x1 = x13, node.y1 = y13;
        return;
      }
      var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k3 = i2 + 1, hi = j2 - 1;
      while (k3 < hi) {
        var mid = k3 + hi >>> 1;
        if (sums[mid] < valueTarget) k3 = mid + 1;
        else hi = mid;
      }
      if (valueTarget - sums[k3 - 1] < sums[k3] - valueTarget && i2 + 1 < k3) --k3;
      var valueLeft = sums[k3] - valueOffset, valueRight = value - valueLeft;
      if (x13 - x07 > y13 - y07) {
        var xk = value ? (x07 * valueRight + x13 * valueLeft) / value : x13;
        partition(i2, k3, valueLeft, x07, y07, xk, y13);
        partition(k3, j2, valueRight, xk, y07, x13, y13);
      } else {
        var yk = value ? (y07 * valueRight + y13 * valueLeft) / value : y13;
        partition(i2, k3, valueLeft, x07, y07, x13, yk);
        partition(k3, j2, valueRight, x07, yk, x13, y13);
      }
    }
  }

  // node_modules/d3-hierarchy/src/treemap/sliceDice.js
  function sliceDice_default(parent, x06, y06, x12, y12) {
    (parent.depth & 1 ? slice_default : dice_default)(parent, x06, y06, x12, y12);
  }

  // node_modules/d3-hierarchy/src/treemap/resquarify.js
  var resquarify_default = function custom11(ratio) {
    function resquarify(parent, x06, y06, x12, y12) {
      if ((rows = parent._squarify) && rows.ratio === ratio) {
        var rows, row, nodes, i, j2 = -1, n, m4 = rows.length, value = parent.value;
        while (++j2 < m4) {
          row = rows[j2], nodes = row.children;
          for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
          if (row.dice) dice_default(row, x06, y06, x12, value ? y06 += (y12 - y06) * row.value / value : y12);
          else slice_default(row, x06, y06, value ? x06 += (x12 - x06) * row.value / value : x12, y12);
          value -= row.value;
        }
      } else {
        parent._squarify = rows = squarifyRatio(ratio, parent, x06, y06, x12, y12);
        rows.ratio = ratio;
      }
    }
    resquarify.ratio = function(x5) {
      return custom11((x5 = +x5) > 1 ? x5 : 1);
    };
    return resquarify;
  }(phi);

  // node_modules/d3-polygon/src/area.js
  function area_default4(polygon) {
    var i = -1, n = polygon.length, a4, b10 = polygon[n - 1], area = 0;
    while (++i < n) {
      a4 = b10;
      b10 = polygon[i];
      area += a4[1] * b10[0] - a4[0] * b10[1];
    }
    return area / 2;
  }

  // node_modules/d3-polygon/src/centroid.js
  function centroid_default3(polygon) {
    var i = -1, n = polygon.length, x5 = 0, y5 = 0, a4, b10 = polygon[n - 1], c6, k3 = 0;
    while (++i < n) {
      a4 = b10;
      b10 = polygon[i];
      k3 += c6 = a4[0] * b10[1] - b10[0] * a4[1];
      x5 += (a4[0] + b10[0]) * c6;
      y5 += (a4[1] + b10[1]) * c6;
    }
    return k3 *= 3, [x5 / k3, y5 / k3];
  }

  // node_modules/d3-polygon/src/cross.js
  function cross_default(a4, b10, c6) {
    return (b10[0] - a4[0]) * (c6[1] - a4[1]) - (b10[1] - a4[1]) * (c6[0] - a4[0]);
  }

  // node_modules/d3-polygon/src/hull.js
  function lexicographicOrder(a4, b10) {
    return a4[0] - b10[0] || a4[1] - b10[1];
  }
  function computeUpperHullIndexes(points) {
    const n = points.length, indexes2 = [0, 1];
    let size2 = 2, i;
    for (i = 2; i < n; ++i) {
      while (size2 > 1 && cross_default(points[indexes2[size2 - 2]], points[indexes2[size2 - 1]], points[i]) <= 0) --size2;
      indexes2[size2++] = i;
    }
    return indexes2.slice(0, size2);
  }
  function hull_default(points) {
    if ((n = points.length) < 3) return null;
    var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);
    for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
    sortedPoints.sort(lexicographicOrder);
    for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
    var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);
    var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull = [];
    for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
    for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);
    return hull;
  }

  // node_modules/d3-polygon/src/contains.js
  function contains_default3(polygon, point6) {
    var n = polygon.length, p = polygon[n - 1], x5 = point6[0], y5 = point6[1], x06 = p[0], y06 = p[1], x12, y12, inside = false;
    for (var i = 0; i < n; ++i) {
      p = polygon[i], x12 = p[0], y12 = p[1];
      if (y12 > y5 !== y06 > y5 && x5 < (x06 - x12) * (y5 - y12) / (y06 - y12) + x12) inside = !inside;
      x06 = x12, y06 = y12;
    }
    return inside;
  }

  // node_modules/d3-polygon/src/length.js
  function length_default2(polygon) {
    var i = -1, n = polygon.length, b10 = polygon[n - 1], xa, ya, xb = b10[0], yb = b10[1], perimeter = 0;
    while (++i < n) {
      xa = xb;
      ya = yb;
      b10 = polygon[i];
      xb = b10[0];
      yb = b10[1];
      xa -= xb;
      ya -= yb;
      perimeter += Math.hypot(xa, ya);
    }
    return perimeter;
  }

  // node_modules/d3-random/src/defaultSource.js
  var defaultSource_default = Math.random;

  // node_modules/d3-random/src/uniform.js
  var uniform_default = function sourceRandomUniform(source2) {
    function randomUniform(min4, max5) {
      min4 = min4 == null ? 0 : +min4;
      max5 = max5 == null ? 1 : +max5;
      if (arguments.length === 1) max5 = min4, min4 = 0;
      else max5 -= min4;
      return function() {
        return source2() * max5 + min4;
      };
    }
    randomUniform.source = sourceRandomUniform;
    return randomUniform;
  }(defaultSource_default);

  // node_modules/d3-random/src/int.js
  var int_default = function sourceRandomInt(source2) {
    function randomInt(min4, max5) {
      if (arguments.length < 2) max5 = min4, min4 = 0;
      min4 = Math.floor(min4);
      max5 = Math.floor(max5) - min4;
      return function() {
        return Math.floor(source2() * max5 + min4);
      };
    }
    randomInt.source = sourceRandomInt;
    return randomInt;
  }(defaultSource_default);

  // node_modules/d3-random/src/normal.js
  var normal_default = function sourceRandomNormal(source2) {
    function randomNormal(mu, sigma) {
      var x5, r;
      mu = mu == null ? 0 : +mu;
      sigma = sigma == null ? 1 : +sigma;
      return function() {
        var y5;
        if (x5 != null) y5 = x5, x5 = null;
        else do {
          x5 = source2() * 2 - 1;
          y5 = source2() * 2 - 1;
          r = x5 * x5 + y5 * y5;
        } while (!r || r > 1);
        return mu + sigma * y5 * Math.sqrt(-2 * Math.log(r) / r);
      };
    }
    randomNormal.source = sourceRandomNormal;
    return randomNormal;
  }(defaultSource_default);

  // node_modules/d3-random/src/logNormal.js
  var logNormal_default = function sourceRandomLogNormal(source2) {
    var N2 = normal_default.source(source2);
    function randomLogNormal() {
      var randomNormal = N2.apply(this, arguments);
      return function() {
        return Math.exp(randomNormal());
      };
    }
    randomLogNormal.source = sourceRandomLogNormal;
    return randomLogNormal;
  }(defaultSource_default);

  // node_modules/d3-random/src/irwinHall.js
  var irwinHall_default = function sourceRandomIrwinHall(source2) {
    function randomIrwinHall(n) {
      if ((n = +n) <= 0) return () => 0;
      return function() {
        for (var sum4 = 0, i = n; i > 1; --i) sum4 += source2();
        return sum4 + i * source2();
      };
    }
    randomIrwinHall.source = sourceRandomIrwinHall;
    return randomIrwinHall;
  }(defaultSource_default);

  // node_modules/d3-random/src/bates.js
  var bates_default = function sourceRandomBates(source2) {
    var I2 = irwinHall_default.source(source2);
    function randomBates(n) {
      if ((n = +n) === 0) return source2;
      var randomIrwinHall = I2(n);
      return function() {
        return randomIrwinHall() / n;
      };
    }
    randomBates.source = sourceRandomBates;
    return randomBates;
  }(defaultSource_default);

  // node_modules/d3-random/src/exponential.js
  var exponential_default = function sourceRandomExponential(source2) {
    function randomExponential(lambda) {
      return function() {
        return -Math.log1p(-source2()) / lambda;
      };
    }
    randomExponential.source = sourceRandomExponential;
    return randomExponential;
  }(defaultSource_default);

  // node_modules/d3-random/src/pareto.js
  var pareto_default = function sourceRandomPareto(source2) {
    function randomPareto(alpha) {
      if ((alpha = +alpha) < 0) throw new RangeError("invalid alpha");
      alpha = 1 / -alpha;
      return function() {
        return Math.pow(1 - source2(), alpha);
      };
    }
    randomPareto.source = sourceRandomPareto;
    return randomPareto;
  }(defaultSource_default);

  // node_modules/d3-random/src/bernoulli.js
  var bernoulli_default = function sourceRandomBernoulli(source2) {
    function randomBernoulli(p) {
      if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
      return function() {
        return Math.floor(source2() + p);
      };
    }
    randomBernoulli.source = sourceRandomBernoulli;
    return randomBernoulli;
  }(defaultSource_default);

  // node_modules/d3-random/src/geometric.js
  var geometric_default = function sourceRandomGeometric(source2) {
    function randomGeometric(p) {
      if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
      if (p === 0) return () => Infinity;
      if (p === 1) return () => 1;
      p = Math.log1p(-p);
      return function() {
        return 1 + Math.floor(Math.log1p(-source2()) / p);
      };
    }
    randomGeometric.source = sourceRandomGeometric;
    return randomGeometric;
  }(defaultSource_default);

  // node_modules/d3-random/src/gamma.js
  var gamma_default = function sourceRandomGamma(source2) {
    var randomNormal = normal_default.source(source2)();
    function randomGamma(k3, theta) {
      if ((k3 = +k3) < 0) throw new RangeError("invalid k");
      if (k3 === 0) return () => 0;
      theta = theta == null ? 1 : +theta;
      if (k3 === 1) return () => -Math.log1p(-source2()) * theta;
      var d = (k3 < 1 ? k3 + 1 : k3) - 1 / 3, c6 = 1 / (3 * Math.sqrt(d)), multiplier = k3 < 1 ? () => Math.pow(source2(), 1 / k3) : () => 1;
      return function() {
        do {
          do {
            var x5 = randomNormal(), v3 = 1 + c6 * x5;
          } while (v3 <= 0);
          v3 *= v3 * v3;
          var u5 = 1 - source2();
        } while (u5 >= 1 - 0.0331 * x5 * x5 * x5 * x5 && Math.log(u5) >= 0.5 * x5 * x5 + d * (1 - v3 + Math.log(v3)));
        return d * v3 * multiplier() * theta;
      };
    }
    randomGamma.source = sourceRandomGamma;
    return randomGamma;
  }(defaultSource_default);

  // node_modules/d3-random/src/beta.js
  var beta_default = function sourceRandomBeta(source2) {
    var G2 = gamma_default.source(source2);
    function randomBeta(alpha, beta) {
      var X4 = G2(alpha), Y4 = G2(beta);
      return function() {
        var x5 = X4();
        return x5 === 0 ? 0 : x5 / (x5 + Y4());
      };
    }
    randomBeta.source = sourceRandomBeta;
    return randomBeta;
  }(defaultSource_default);

  // node_modules/d3-random/src/binomial.js
  var binomial_default = function sourceRandomBinomial(source2) {
    var G2 = geometric_default.source(source2), B4 = beta_default.source(source2);
    function randomBinomial(n, p) {
      n = +n;
      if ((p = +p) >= 1) return () => n;
      if (p <= 0) return () => 0;
      return function() {
        var acc = 0, nn = n, pp = p;
        while (nn * pp > 16 && nn * (1 - pp) > 16) {
          var i = Math.floor((nn + 1) * pp), y5 = B4(i, nn - i + 1)();
          if (y5 <= pp) {
            acc += i;
            nn -= i;
            pp = (pp - y5) / (1 - y5);
          } else {
            nn = i - 1;
            pp /= y5;
          }
        }
        var sign3 = pp < 0.5, pFinal = sign3 ? pp : 1 - pp, g = G2(pFinal);
        for (var s2 = g(), k3 = 0; s2 <= nn; ++k3) s2 += g();
        return acc + (sign3 ? k3 : nn - k3);
      };
    }
    randomBinomial.source = sourceRandomBinomial;
    return randomBinomial;
  }(defaultSource_default);

  // node_modules/d3-random/src/weibull.js
  var weibull_default = function sourceRandomWeibull(source2) {
    function randomWeibull(k3, a4, b10) {
      var outerFunc;
      if ((k3 = +k3) === 0) {
        outerFunc = (x5) => -Math.log(x5);
      } else {
        k3 = 1 / k3;
        outerFunc = (x5) => Math.pow(x5, k3);
      }
      a4 = a4 == null ? 0 : +a4;
      b10 = b10 == null ? 1 : +b10;
      return function() {
        return a4 + b10 * outerFunc(-Math.log1p(-source2()));
      };
    }
    randomWeibull.source = sourceRandomWeibull;
    return randomWeibull;
  }(defaultSource_default);

  // node_modules/d3-random/src/cauchy.js
  var cauchy_default = function sourceRandomCauchy(source2) {
    function randomCauchy(a4, b10) {
      a4 = a4 == null ? 0 : +a4;
      b10 = b10 == null ? 1 : +b10;
      return function() {
        return a4 + b10 * Math.tan(Math.PI * source2());
      };
    }
    randomCauchy.source = sourceRandomCauchy;
    return randomCauchy;
  }(defaultSource_default);

  // node_modules/d3-random/src/logistic.js
  var logistic_default = function sourceRandomLogistic(source2) {
    function randomLogistic(a4, b10) {
      a4 = a4 == null ? 0 : +a4;
      b10 = b10 == null ? 1 : +b10;
      return function() {
        var u5 = source2();
        return a4 + b10 * Math.log(u5 / (1 - u5));
      };
    }
    randomLogistic.source = sourceRandomLogistic;
    return randomLogistic;
  }(defaultSource_default);

  // node_modules/d3-random/src/poisson.js
  var poisson_default = function sourceRandomPoisson(source2) {
    var G2 = gamma_default.source(source2), B4 = binomial_default.source(source2);
    function randomPoisson(lambda) {
      return function() {
        var acc = 0, l2 = lambda;
        while (l2 > 16) {
          var n = Math.floor(0.875 * l2), t = G2(n)();
          if (t > l2) return acc + B4(n - 1, l2 / t)();
          acc += n;
          l2 -= t;
        }
        for (var s2 = -Math.log1p(-source2()), k3 = 0; s2 <= l2; ++k3) s2 -= Math.log1p(-source2());
        return acc + k3;
      };
    }
    randomPoisson.source = sourceRandomPoisson;
    return randomPoisson;
  }(defaultSource_default);

  // node_modules/d3-random/src/lcg.js
  var mul = 1664525;
  var inc = 1013904223;
  var eps = 1 / 4294967296;
  function lcg(seed = Math.random()) {
    let state2 = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
    return () => (state2 = mul * state2 + inc | 0, eps * (state2 >>> 0));
  }

  // node_modules/d3-scale/src/init.js
  function initRange(domain, range6) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range6).domain(domain);
        break;
    }
    return this;
  }
  function initInterpolator(domain, interpolator) {
    switch (arguments.length) {
      case 0:
        break;
      case 1: {
        if (typeof domain === "function") this.interpolator(domain);
        else this.range(domain);
        break;
      }
      default: {
        this.domain(domain);
        if (typeof interpolator === "function") this.interpolator(interpolator);
        else this.range(interpolator);
        break;
      }
    }
    return this;
  }

  // node_modules/d3-scale/src/ordinal.js
  var implicit = Symbol("implicit");
  function ordinal() {
    var index4 = new InternMap(), domain = [], range6 = [], unknown = implicit;
    function scale2(d) {
      let i = index4.get(d);
      if (i === void 0) {
        if (unknown !== implicit) return unknown;
        index4.set(d, i = domain.push(d) - 1);
      }
      return range6[i % range6.length];
    }
    scale2.domain = function(_25) {
      if (!arguments.length) return domain.slice();
      domain = [], index4 = new InternMap();
      for (const value of _25) {
        if (index4.has(value)) continue;
        index4.set(value, domain.push(value) - 1);
      }
      return scale2;
    };
    scale2.range = function(_25) {
      return arguments.length ? (range6 = Array.from(_25), scale2) : range6.slice();
    };
    scale2.unknown = function(_25) {
      return arguments.length ? (unknown = _25, scale2) : unknown;
    };
    scale2.copy = function() {
      return ordinal(domain, range6).unknown(unknown);
    };
    initRange.apply(scale2, arguments);
    return scale2;
  }

  // node_modules/d3-scale/src/band.js
  function band() {
    var scale2 = ordinal().unknown(void 0), domain = scale2.domain, ordinalRange = scale2.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale2.unknown;
    function rescale() {
      var n = domain().length, reverse2 = r1 < r0, start2 = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
      step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round) step = Math.floor(step);
      start2 += (stop - start2 - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round) start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
      var values2 = range(n).map(function(i) {
        return start2 + step * i;
      });
      return ordinalRange(reverse2 ? values2.reverse() : values2);
    }
    scale2.domain = function(_25) {
      return arguments.length ? (domain(_25), rescale()) : domain();
    };
    scale2.range = function(_25) {
      return arguments.length ? ([r0, r1] = _25, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
    };
    scale2.rangeRound = function(_25) {
      return [r0, r1] = _25, r0 = +r0, r1 = +r1, round = true, rescale();
    };
    scale2.bandwidth = function() {
      return bandwidth;
    };
    scale2.step = function() {
      return step;
    };
    scale2.round = function(_25) {
      return arguments.length ? (round = !!_25, rescale()) : round;
    };
    scale2.padding = function(_25) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_25), rescale()) : paddingInner;
    };
    scale2.paddingInner = function(_25) {
      return arguments.length ? (paddingInner = Math.min(1, _25), rescale()) : paddingInner;
    };
    scale2.paddingOuter = function(_25) {
      return arguments.length ? (paddingOuter = +_25, rescale()) : paddingOuter;
    };
    scale2.align = function(_25) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _25)), rescale()) : align;
    };
    scale2.copy = function() {
      return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return initRange.apply(rescale(), arguments);
  }
  function pointish(scale2) {
    var copy3 = scale2.copy;
    scale2.padding = scale2.paddingOuter;
    delete scale2.paddingInner;
    delete scale2.paddingOuter;
    scale2.copy = function() {
      return pointish(copy3());
    };
    return scale2;
  }
  function point() {
    return pointish(band.apply(null, arguments).paddingInner(1));
  }

  // node_modules/d3-scale/src/constant.js
  function constants(x5) {
    return function() {
      return x5;
    };
  }

  // node_modules/d3-scale/src/number.js
  function number3(x5) {
    return +x5;
  }

  // node_modules/d3-scale/src/continuous.js
  var unit = [0, 1];
  function identity3(x5) {
    return x5;
  }
  function normalize2(a4, b10) {
    return (b10 -= a4 = +a4) ? function(x5) {
      return (x5 - a4) / b10;
    } : constants(isNaN(b10) ? NaN : 0.5);
  }
  function clamper(a4, b10) {
    var t;
    if (a4 > b10) t = a4, a4 = b10, b10 = t;
    return function(x5) {
      return Math.max(a4, Math.min(b10, x5));
    };
  }
  function bimap(domain, range6, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range6[0], r1 = range6[1];
    if (d1 < d0) d0 = normalize2(d1, d0), r0 = interpolate(r1, r0);
    else d0 = normalize2(d0, d1), r0 = interpolate(r0, r1);
    return function(x5) {
      return r0(d0(x5));
    };
  }
  function polymap(domain, range6, interpolate) {
    var j2 = Math.min(domain.length, range6.length) - 1, d = new Array(j2), r = new Array(j2), i = -1;
    if (domain[j2] < domain[0]) {
      domain = domain.slice().reverse();
      range6 = range6.slice().reverse();
    }
    while (++i < j2) {
      d[i] = normalize2(domain[i], domain[i + 1]);
      r[i] = interpolate(range6[i], range6[i + 1]);
    }
    return function(x5) {
      var i2 = bisect_default(domain, x5, 1, j2) - 1;
      return r[i2](d[i2](x5));
    };
  }
  function copy(source2, target) {
    return target.domain(source2.domain()).range(source2.range()).interpolate(source2.interpolate()).clamp(source2.clamp()).unknown(source2.unknown());
  }
  function transformer2() {
    var domain = unit, range6 = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity3, piecewise2, output, input;
    function rescale() {
      var n = Math.min(domain.length, range6.length);
      if (clamp !== identity3) clamp = clamper(domain[0], domain[n - 1]);
      piecewise2 = n > 2 ? polymap : bimap;
      output = input = null;
      return scale2;
    }
    function scale2(x5) {
      return x5 == null || isNaN(x5 = +x5) ? unknown : (output || (output = piecewise2(domain.map(transform2), range6, interpolate)))(transform2(clamp(x5)));
    }
    scale2.invert = function(y5) {
      return clamp(untransform((input || (input = piecewise2(range6, domain.map(transform2), number_default)))(y5)));
    };
    scale2.domain = function(_25) {
      return arguments.length ? (domain = Array.from(_25, number3), rescale()) : domain.slice();
    };
    scale2.range = function(_25) {
      return arguments.length ? (range6 = Array.from(_25), rescale()) : range6.slice();
    };
    scale2.rangeRound = function(_25) {
      return range6 = Array.from(_25), interpolate = round_default, rescale();
    };
    scale2.clamp = function(_25) {
      return arguments.length ? (clamp = _25 ? true : identity3, rescale()) : clamp !== identity3;
    };
    scale2.interpolate = function(_25) {
      return arguments.length ? (interpolate = _25, rescale()) : interpolate;
    };
    scale2.unknown = function(_25) {
      return arguments.length ? (unknown = _25, scale2) : unknown;
    };
    return function(t, u5) {
      transform2 = t, untransform = u5;
      return rescale();
    };
  }
  function continuous() {
    return transformer2()(identity3, identity3);
  }

  // node_modules/d3-scale/src/tickFormat.js
  function tickFormat(start2, stop, count3, specifier) {
    var step = tickStep(start2, stop, count3), precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start2), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  // node_modules/d3-scale/src/linear.js
  function linearish(scale2) {
    var domain = scale2.domain;
    scale2.ticks = function(count3) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count3 == null ? 10 : count3);
    };
    scale2.tickFormat = function(count3, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count3 == null ? 10 : count3, specifier);
    };
    scale2.nice = function(count3) {
      if (count3 == null) count3 = 10;
      var d = domain();
      var i0 = 0;
      var i1 = d.length - 1;
      var start2 = d[i0];
      var stop = d[i1];
      var prestep;
      var step;
      var maxIter = 10;
      if (stop < start2) {
        step = start2, start2 = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }
      while (maxIter-- > 0) {
        step = tickIncrement(start2, stop, count3);
        if (step === prestep) {
          d[i0] = start2;
          d[i1] = stop;
          return domain(d);
        } else if (step > 0) {
          start2 = Math.floor(start2 / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start2 = Math.ceil(start2 * step) / step;
          stop = Math.floor(stop * step) / step;
        } else {
          break;
        }
        prestep = step;
      }
      return scale2;
    };
    return scale2;
  }
  function linear3() {
    var scale2 = continuous();
    scale2.copy = function() {
      return copy(scale2, linear3());
    };
    initRange.apply(scale2, arguments);
    return linearish(scale2);
  }

  // node_modules/d3-scale/src/identity.js
  function identity4(domain) {
    var unknown;
    function scale2(x5) {
      return x5 == null || isNaN(x5 = +x5) ? unknown : x5;
    }
    scale2.invert = scale2;
    scale2.domain = scale2.range = function(_25) {
      return arguments.length ? (domain = Array.from(_25, number3), scale2) : domain.slice();
    };
    scale2.unknown = function(_25) {
      return arguments.length ? (unknown = _25, scale2) : unknown;
    };
    scale2.copy = function() {
      return identity4(domain).unknown(unknown);
    };
    domain = arguments.length ? Array.from(domain, number3) : [0, 1];
    return linearish(scale2);
  }

  // node_modules/d3-scale/src/nice.js
  function nice2(domain, interval2) {
    domain = domain.slice();
    var i0 = 0, i1 = domain.length - 1, x06 = domain[i0], x12 = domain[i1], t;
    if (x12 < x06) {
      t = i0, i0 = i1, i1 = t;
      t = x06, x06 = x12, x12 = t;
    }
    domain[i0] = interval2.floor(x06);
    domain[i1] = interval2.ceil(x12);
    return domain;
  }

  // node_modules/d3-scale/src/log.js
  function transformLog(x5) {
    return Math.log(x5);
  }
  function transformExp(x5) {
    return Math.exp(x5);
  }
  function transformLogn(x5) {
    return -Math.log(-x5);
  }
  function transformExpn(x5) {
    return -Math.exp(-x5);
  }
  function pow10(x5) {
    return isFinite(x5) ? +("1e" + x5) : x5 < 0 ? 0 : x5;
  }
  function powp(base) {
    return base === 10 ? pow10 : base === Math.E ? Math.exp : (x5) => Math.pow(base, x5);
  }
  function logp(base) {
    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x5) => Math.log(x5) / base);
  }
  function reflect(f) {
    return (x5, k3) => -f(-x5, k3);
  }
  function loggish(transform2) {
    const scale2 = transform2(transformLog, transformExp);
    const domain = scale2.domain;
    let base = 10;
    let logs;
    let pows;
    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) {
        logs = reflect(logs), pows = reflect(pows);
        transform2(transformLogn, transformExpn);
      } else {
        transform2(transformLog, transformExp);
      }
      return scale2;
    }
    scale2.base = function(_25) {
      return arguments.length ? (base = +_25, rescale()) : base;
    };
    scale2.domain = function(_25) {
      return arguments.length ? (domain(_25), rescale()) : domain();
    };
    scale2.ticks = (count3) => {
      const d = domain();
      let u5 = d[0];
      let v3 = d[d.length - 1];
      const r = v3 < u5;
      if (r) [u5, v3] = [v3, u5];
      let i = logs(u5);
      let j2 = logs(v3);
      let k3;
      let t;
      const n = count3 == null ? 10 : +count3;
      let z2 = [];
      if (!(base % 1) && j2 - i < n) {
        i = Math.floor(i), j2 = Math.ceil(j2);
        if (u5 > 0) for (; i <= j2; ++i) {
          for (k3 = 1; k3 < base; ++k3) {
            t = i < 0 ? k3 / pows(-i) : k3 * pows(i);
            if (t < u5) continue;
            if (t > v3) break;
            z2.push(t);
          }
        }
        else for (; i <= j2; ++i) {
          for (k3 = base - 1; k3 >= 1; --k3) {
            t = i > 0 ? k3 / pows(-i) : k3 * pows(i);
            if (t < u5) continue;
            if (t > v3) break;
            z2.push(t);
          }
        }
        if (z2.length * 2 < n) z2 = ticks(u5, v3, n);
      } else {
        z2 = ticks(i, j2, Math.min(j2 - i, n)).map(pows);
      }
      return r ? z2.reverse() : z2;
    };
    scale2.tickFormat = (count3, specifier) => {
      if (count3 == null) count3 = 10;
      if (specifier == null) specifier = base === 10 ? "s" : ",";
      if (typeof specifier !== "function") {
        if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
        specifier = format(specifier);
      }
      if (count3 === Infinity) return specifier;
      const k3 = Math.max(1, base * count3 / scale2.ticks().length);
      return (d) => {
        let i = d / pows(Math.round(logs(d)));
        if (i * base < base - 0.5) i *= base;
        return i <= k3 ? specifier(d) : "";
      };
    };
    scale2.nice = () => {
      return domain(nice2(domain(), {
        floor: (x5) => pows(Math.floor(logs(x5))),
        ceil: (x5) => pows(Math.ceil(logs(x5)))
      }));
    };
    return scale2;
  }
  function log2() {
    const scale2 = loggish(transformer2()).domain([1, 10]);
    scale2.copy = () => copy(scale2, log2()).base(scale2.base());
    initRange.apply(scale2, arguments);
    return scale2;
  }

  // node_modules/d3-scale/src/symlog.js
  function transformSymlog(c6) {
    return function(x5) {
      return Math.sign(x5) * Math.log1p(Math.abs(x5 / c6));
    };
  }
  function transformSymexp(c6) {
    return function(x5) {
      return Math.sign(x5) * Math.expm1(Math.abs(x5)) * c6;
    };
  }
  function symlogish(transform2) {
    var c6 = 1, scale2 = transform2(transformSymlog(c6), transformSymexp(c6));
    scale2.constant = function(_25) {
      return arguments.length ? transform2(transformSymlog(c6 = +_25), transformSymexp(c6)) : c6;
    };
    return linearish(scale2);
  }
  function symlog() {
    var scale2 = symlogish(transformer2());
    scale2.copy = function() {
      return copy(scale2, symlog()).constant(scale2.constant());
    };
    return initRange.apply(scale2, arguments);
  }

  // node_modules/d3-scale/src/pow.js
  function transformPow(exponent2) {
    return function(x5) {
      return x5 < 0 ? -Math.pow(-x5, exponent2) : Math.pow(x5, exponent2);
    };
  }
  function transformSqrt(x5) {
    return x5 < 0 ? -Math.sqrt(-x5) : Math.sqrt(x5);
  }
  function transformSquare(x5) {
    return x5 < 0 ? -x5 * x5 : x5 * x5;
  }
  function powish(transform2) {
    var scale2 = transform2(identity3, identity3), exponent2 = 1;
    function rescale() {
      return exponent2 === 1 ? transform2(identity3, identity3) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));
    }
    scale2.exponent = function(_25) {
      return arguments.length ? (exponent2 = +_25, rescale()) : exponent2;
    };
    return linearish(scale2);
  }
  function pow3() {
    var scale2 = powish(transformer2());
    scale2.copy = function() {
      return copy(scale2, pow3()).exponent(scale2.exponent());
    };
    initRange.apply(scale2, arguments);
    return scale2;
  }
  function sqrt2() {
    return pow3.apply(null, arguments).exponent(0.5);
  }

  // node_modules/d3-scale/src/radial.js
  function square(x5) {
    return Math.sign(x5) * x5 * x5;
  }
  function unsquare(x5) {
    return Math.sign(x5) * Math.sqrt(Math.abs(x5));
  }
  function radial() {
    var squared = continuous(), range6 = [0, 1], round = false, unknown;
    function scale2(x5) {
      var y5 = unsquare(squared(x5));
      return isNaN(y5) ? unknown : round ? Math.round(y5) : y5;
    }
    scale2.invert = function(y5) {
      return squared.invert(square(y5));
    };
    scale2.domain = function(_25) {
      return arguments.length ? (squared.domain(_25), scale2) : squared.domain();
    };
    scale2.range = function(_25) {
      return arguments.length ? (squared.range((range6 = Array.from(_25, number3)).map(square)), scale2) : range6.slice();
    };
    scale2.rangeRound = function(_25) {
      return scale2.range(_25).round(true);
    };
    scale2.round = function(_25) {
      return arguments.length ? (round = !!_25, scale2) : round;
    };
    scale2.clamp = function(_25) {
      return arguments.length ? (squared.clamp(_25), scale2) : squared.clamp();
    };
    scale2.unknown = function(_25) {
      return arguments.length ? (unknown = _25, scale2) : unknown;
    };
    scale2.copy = function() {
      return radial(squared.domain(), range6).round(round).clamp(squared.clamp()).unknown(unknown);
    };
    initRange.apply(scale2, arguments);
    return linearish(scale2);
  }

  // node_modules/d3-scale/src/quantile.js
  function quantile2() {
    var domain = [], range6 = [], thresholds = [], unknown;
    function rescale() {
      var i = 0, n = Math.max(1, range6.length);
      thresholds = new Array(n - 1);
      while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
      return scale2;
    }
    function scale2(x5) {
      return x5 == null || isNaN(x5 = +x5) ? unknown : range6[bisect_default(thresholds, x5)];
    }
    scale2.invertExtent = function(y5) {
      var i = range6.indexOf(y5);
      return i < 0 ? [NaN, NaN] : [
        i > 0 ? thresholds[i - 1] : domain[0],
        i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
      ];
    };
    scale2.domain = function(_25) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (let d of _25) if (d != null && !isNaN(d = +d)) domain.push(d);
      domain.sort(ascending);
      return rescale();
    };
    scale2.range = function(_25) {
      return arguments.length ? (range6 = Array.from(_25), rescale()) : range6.slice();
    };
    scale2.unknown = function(_25) {
      return arguments.length ? (unknown = _25, scale2) : unknown;
    };
    scale2.quantiles = function() {
      return thresholds.slice();
    };
    scale2.copy = function() {
      return quantile2().domain(domain).range(range6).unknown(unknown);
    };
    return initRange.apply(scale2, arguments);
  }

  // node_modules/d3-scale/src/quantize.js
  function quantize() {
    var x06 = 0, x12 = 1, n = 1, domain = [0.5], range6 = [0, 1], unknown;
    function scale2(x5) {
      return x5 != null && x5 <= x5 ? range6[bisect_default(domain, x5, 0, n)] : unknown;
    }
    function rescale() {
      var i = -1;
      domain = new Array(n);
      while (++i < n) domain[i] = ((i + 1) * x12 - (i - n) * x06) / (n + 1);
      return scale2;
    }
    scale2.domain = function(_25) {
      return arguments.length ? ([x06, x12] = _25, x06 = +x06, x12 = +x12, rescale()) : [x06, x12];
    };
    scale2.range = function(_25) {
      return arguments.length ? (n = (range6 = Array.from(_25)).length - 1, rescale()) : range6.slice();
    };
    scale2.invertExtent = function(y5) {
      var i = range6.indexOf(y5);
      return i < 0 ? [NaN, NaN] : i < 1 ? [x06, domain[0]] : i >= n ? [domain[n - 1], x12] : [domain[i - 1], domain[i]];
    };
    scale2.unknown = function(_25) {
      return arguments.length ? (unknown = _25, scale2) : scale2;
    };
    scale2.thresholds = function() {
      return domain.slice();
    };
    scale2.copy = function() {
      return quantize().domain([x06, x12]).range(range6).unknown(unknown);
    };
    return initRange.apply(linearish(scale2), arguments);
  }

  // node_modules/d3-scale/src/threshold.js
  function threshold() {
    var domain = [0.5], range6 = [0, 1], unknown, n = 1;
    function scale2(x5) {
      return x5 != null && x5 <= x5 ? range6[bisect_default(domain, x5, 0, n)] : unknown;
    }
    scale2.domain = function(_25) {
      return arguments.length ? (domain = Array.from(_25), n = Math.min(domain.length, range6.length - 1), scale2) : domain.slice();
    };
    scale2.range = function(_25) {
      return arguments.length ? (range6 = Array.from(_25), n = Math.min(domain.length, range6.length - 1), scale2) : range6.slice();
    };
    scale2.invertExtent = function(y5) {
      var i = range6.indexOf(y5);
      return [domain[i - 1], domain[i]];
    };
    scale2.unknown = function(_25) {
      return arguments.length ? (unknown = _25, scale2) : unknown;
    };
    scale2.copy = function() {
      return threshold().domain(domain).range(range6).unknown(unknown);
    };
    return initRange.apply(scale2, arguments);
  }

  // node_modules/d3-time/src/interval.js
  var t02 = /* @__PURE__ */ new Date();
  var t12 = /* @__PURE__ */ new Date();
  function timeInterval(floori, offseti, count3, field) {
    function interval2(date2) {
      return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
    }
    interval2.floor = (date2) => {
      return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
    };
    interval2.ceil = (date2) => {
      return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
    };
    interval2.round = (date2) => {
      const d0 = interval2(date2), d1 = interval2.ceil(date2);
      return date2 - d0 < d1 - date2 ? d0 : d1;
    };
    interval2.offset = (date2, step) => {
      return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
    };
    interval2.range = (start2, stop, step) => {
      const range6 = [];
      start2 = interval2.ceil(start2);
      step = step == null ? 1 : Math.floor(step);
      if (!(start2 < stop) || !(step > 0)) return range6;
      let previous;
      do
        range6.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
      while (previous < start2 && start2 < stop);
      return range6;
    };
    interval2.filter = (test) => {
      return timeInterval((date2) => {
        if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
      }, (date2, step) => {
        if (date2 >= date2) {
          if (step < 0) while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
          else while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
        }
      });
    };
    if (count3) {
      interval2.count = (start2, end) => {
        t02.setTime(+start2), t12.setTime(+end);
        floori(t02), floori(t12);
        return Math.floor(count3(t02, t12));
      };
      interval2.every = (step) => {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? (d) => field(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);
      };
    }
    return interval2;
  }

  // node_modules/d3-time/src/millisecond.js
  var millisecond = timeInterval(() => {
  }, (date2, step) => {
    date2.setTime(+date2 + step);
  }, (start2, end) => {
    return end - start2;
  });
  millisecond.every = (k3) => {
    k3 = Math.floor(k3);
    if (!isFinite(k3) || !(k3 > 0)) return null;
    if (!(k3 > 1)) return millisecond;
    return timeInterval((date2) => {
      date2.setTime(Math.floor(date2 / k3) * k3);
    }, (date2, step) => {
      date2.setTime(+date2 + step * k3);
    }, (start2, end) => {
      return (end - start2) / k3;
    });
  };
  var milliseconds = millisecond.range;

  // node_modules/d3-time/src/duration.js
  var durationSecond = 1e3;
  var durationMinute = durationSecond * 60;
  var durationHour = durationMinute * 60;
  var durationDay = durationHour * 24;
  var durationWeek = durationDay * 7;
  var durationMonth = durationDay * 30;
  var durationYear = durationDay * 365;

  // node_modules/d3-time/src/second.js
  var second = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds());
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationSecond);
  }, (start2, end) => {
    return (end - start2) / durationSecond;
  }, (date2) => {
    return date2.getUTCSeconds();
  });
  var seconds = second.range;

  // node_modules/d3-time/src/minute.js
  var timeMinute = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationMinute);
  }, (start2, end) => {
    return (end - start2) / durationMinute;
  }, (date2) => {
    return date2.getMinutes();
  });
  var timeMinutes = timeMinute.range;
  var utcMinute = timeInterval((date2) => {
    date2.setUTCSeconds(0, 0);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationMinute);
  }, (start2, end) => {
    return (end - start2) / durationMinute;
  }, (date2) => {
    return date2.getUTCMinutes();
  });
  var utcMinutes = utcMinute.range;

  // node_modules/d3-time/src/hour.js
  var timeHour = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationHour);
  }, (start2, end) => {
    return (end - start2) / durationHour;
  }, (date2) => {
    return date2.getHours();
  });
  var timeHours = timeHour.range;
  var utcHour = timeInterval((date2) => {
    date2.setUTCMinutes(0, 0, 0);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationHour);
  }, (start2, end) => {
    return (end - start2) / durationHour;
  }, (date2) => {
    return date2.getUTCHours();
  });
  var utcHours = utcHour.range;

  // node_modules/d3-time/src/day.js
  var timeDay = timeInterval(
    (date2) => date2.setHours(0, 0, 0, 0),
    (date2, step) => date2.setDate(date2.getDate() + step),
    (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
    (date2) => date2.getDate() - 1
  );
  var timeDays = timeDay.range;
  var utcDay = timeInterval((date2) => {
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step);
  }, (start2, end) => {
    return (end - start2) / durationDay;
  }, (date2) => {
    return date2.getUTCDate() - 1;
  });
  var utcDays = utcDay.range;
  var unixDay = timeInterval((date2) => {
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step);
  }, (start2, end) => {
    return (end - start2) / durationDay;
  }, (date2) => {
    return Math.floor(date2 / durationDay);
  });
  var unixDays = unixDay.range;

  // node_modules/d3-time/src/week.js
  function timeWeekday(i) {
    return timeInterval((date2) => {
      date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setDate(date2.getDate() + step * 7);
    }, (start2, end) => {
      return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
    });
  }
  var timeSunday = timeWeekday(0);
  var timeMonday = timeWeekday(1);
  var timeTuesday = timeWeekday(2);
  var timeWednesday = timeWeekday(3);
  var timeThursday = timeWeekday(4);
  var timeFriday = timeWeekday(5);
  var timeSaturday = timeWeekday(6);
  var timeSundays = timeSunday.range;
  var timeMondays = timeMonday.range;
  var timeTuesdays = timeTuesday.range;
  var timeWednesdays = timeWednesday.range;
  var timeThursdays = timeThursday.range;
  var timeFridays = timeFriday.range;
  var timeSaturdays = timeSaturday.range;
  function utcWeekday(i) {
    return timeInterval((date2) => {
      date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step * 7);
    }, (start2, end) => {
      return (end - start2) / durationWeek;
    });
  }
  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);
  var utcTuesday = utcWeekday(2);
  var utcWednesday = utcWeekday(3);
  var utcThursday = utcWeekday(4);
  var utcFriday = utcWeekday(5);
  var utcSaturday = utcWeekday(6);
  var utcSundays = utcSunday.range;
  var utcMondays = utcMonday.range;
  var utcTuesdays = utcTuesday.range;
  var utcWednesdays = utcWednesday.range;
  var utcThursdays = utcThursday.range;
  var utcFridays = utcFriday.range;
  var utcSaturdays = utcSaturday.range;

  // node_modules/d3-time/src/month.js
  var timeMonth = timeInterval((date2) => {
    date2.setDate(1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setMonth(date2.getMonth() + step);
  }, (start2, end) => {
    return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
  }, (date2) => {
    return date2.getMonth();
  });
  var timeMonths = timeMonth.range;
  var utcMonth = timeInterval((date2) => {
    date2.setUTCDate(1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCMonth(date2.getUTCMonth() + step);
  }, (start2, end) => {
    return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
  }, (date2) => {
    return date2.getUTCMonth();
  });
  var utcMonths = utcMonth.range;

  // node_modules/d3-time/src/year.js
  var timeYear = timeInterval((date2) => {
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step);
  }, (start2, end) => {
    return end.getFullYear() - start2.getFullYear();
  }, (date2) => {
    return date2.getFullYear();
  });
  timeYear.every = (k3) => {
    return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date2) => {
      date2.setFullYear(Math.floor(date2.getFullYear() / k3) * k3);
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setFullYear(date2.getFullYear() + step * k3);
    });
  };
  var timeYears = timeYear.range;
  var utcYear = timeInterval((date2) => {
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step);
  }, (start2, end) => {
    return end.getUTCFullYear() - start2.getUTCFullYear();
  }, (date2) => {
    return date2.getUTCFullYear();
  });
  utcYear.every = (k3) => {
    return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date2) => {
      date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k3) * k3);
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCFullYear(date2.getUTCFullYear() + step * k3);
    });
  };
  var utcYears = utcYear.range;

  // node_modules/d3-time/src/ticks.js
  function ticker(year, month, week, day, hour, minute) {
    const tickIntervals = [
      [second, 1, durationSecond],
      [second, 5, 5 * durationSecond],
      [second, 15, 15 * durationSecond],
      [second, 30, 30 * durationSecond],
      [minute, 1, durationMinute],
      [minute, 5, 5 * durationMinute],
      [minute, 15, 15 * durationMinute],
      [minute, 30, 30 * durationMinute],
      [hour, 1, durationHour],
      [hour, 3, 3 * durationHour],
      [hour, 6, 6 * durationHour],
      [hour, 12, 12 * durationHour],
      [day, 1, durationDay],
      [day, 2, 2 * durationDay],
      [week, 1, durationWeek],
      [month, 1, durationMonth],
      [month, 3, 3 * durationMonth],
      [year, 1, durationYear]
    ];
    function ticks2(start2, stop, count3) {
      const reverse2 = stop < start2;
      if (reverse2) [start2, stop] = [stop, start2];
      const interval2 = count3 && typeof count3.range === "function" ? count3 : tickInterval(start2, stop, count3);
      const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
      return reverse2 ? ticks3.reverse() : ticks3;
    }
    function tickInterval(start2, stop, count3) {
      const target = Math.abs(stop - start2) / count3;
      const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
      if (i === tickIntervals.length) return year.every(tickStep(start2 / durationYear, stop / durationYear, count3));
      if (i === 0) return millisecond.every(Math.max(tickStep(start2, stop, count3), 1));
      const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
      return t.every(step);
    }
    return [ticks2, tickInterval];
  }
  var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
  var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

  // node_modules/d3-time-format/src/locale.js
  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date2.setFullYear(d.y);
      return date2;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }
  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date2.setUTCFullYear(d.y);
      return date2;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }
  function newDate(y5, m4, d) {
    return { y: y5, m: m4, d, H: 0, M: 0, S: 0, L: 0 };
  }
  function formatLocale(locale4) {
    var locale_dateTime = locale4.dateTime, locale_date = locale4.date, locale_time = locale4.time, locale_periods = locale4.periods, locale_weekdays = locale4.days, locale_shortWeekdays = locale4.shortDays, locale_months = locale4.months, locale_shortMonths = locale4.shortMonths;
    var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "f": formatMicroseconds,
      "g": formatYearISO,
      "G": formatFullYearISO,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "q": formatQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatSeconds,
      "u": formatWeekdayNumberMonday,
      "U": formatWeekNumberSunday,
      "V": formatWeekNumberISO,
      "w": formatWeekdayNumberSunday,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear2,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };
    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "f": formatUTCMicroseconds,
      "g": formatUTCYearISO,
      "G": formatUTCFullYearISO,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "q": formatUTCQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatUTCSeconds,
      "u": formatUTCWeekdayNumberMonday,
      "U": formatUTCWeekNumberSunday,
      "V": formatUTCWeekNumberISO,
      "w": formatUTCWeekdayNumberSunday,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };
    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "f": parseMicroseconds,
      "g": parseYear,
      "G": parseFullYear,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "q": parseQuarter,
      "Q": parseUnixTimestamp,
      "s": parseUnixTimestampSeconds,
      "S": parseSeconds,
      "u": parseWeekdayNumberMonday,
      "U": parseWeekNumberSunday,
      "V": parseWeekNumberISO,
      "w": parseWeekdayNumberSunday,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);
    function newFormat(specifier, formats2) {
      return function(date2) {
        var string = [], i = -1, j2 = 0, n = specifier.length, c6, pad3, format2;
        if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j2, i));
            if ((pad3 = pads[c6 = specifier.charAt(++i)]) != null) c6 = specifier.charAt(++i);
            else pad3 = c6 === "e" ? " " : "0";
            if (format2 = formats2[c6]) c6 = format2(date2, pad3);
            string.push(c6);
            j2 = i + 1;
          }
        }
        string.push(specifier.slice(j2, i));
        return string.join("");
      };
    }
    function newParse(specifier, Z3) {
      return function(string) {
        var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
        if (i != string.length) return null;
        if ("Q" in d) return new Date(d.Q);
        if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
        if (Z3 && !("Z" in d)) d.Z = 0;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        if (d.m === void 0) d.m = "q" in d ? d.q : 0;
        if ("V" in d) {
          if (d.V < 1 || d.V > 53) return null;
          if (!("w" in d)) d.w = 1;
          if ("Z" in d) {
            week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
            week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
            week = utcDay.offset(week, (d.V - 1) * 7);
            d.y = week.getUTCFullYear();
            d.m = week.getUTCMonth();
            d.d = week.getUTCDate() + (d.w + 6) % 7;
          } else {
            week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
            week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
            week = timeDay.offset(week, (d.V - 1) * 7);
            d.y = week.getFullYear();
            d.m = week.getMonth();
            d.d = week.getDate() + (d.w + 6) % 7;
          }
        } else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
          day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
          d.m = 0;
          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
        }
        if ("Z" in d) {
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }
        return localDate(d);
      };
    }
    function parseSpecifier(d, specifier, string, j2) {
      var i = 0, n = specifier.length, m4 = string.length, c6, parse;
      while (i < n) {
        if (j2 >= m4) return -1;
        c6 = specifier.charCodeAt(i++);
        if (c6 === 37) {
          c6 = specifier.charAt(i++);
          parse = parses[c6 in pads ? specifier.charAt(i++) : c6];
          if (!parse || (j2 = parse(d, string, j2)) < 0) return -1;
        } else if (c6 != string.charCodeAt(j2++)) {
          return -1;
        }
      }
      return j2;
    }
    function parsePeriod(d, string, i) {
      var n = periodRe.exec(string.slice(i));
      return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseShortWeekday(d, string, i) {
      var n = shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseWeekday(d, string, i) {
      var n = weekdayRe.exec(string.slice(i));
      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseShortMonth(d, string, i) {
      var n = shortMonthRe.exec(string.slice(i));
      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseMonth(d, string, i) {
      var n = monthRe.exec(string.slice(i));
      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }
    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }
    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }
    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }
    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }
    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }
    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }
    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }
    function formatQuarter(d) {
      return 1 + ~~(d.getMonth() / 3);
    }
    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }
    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }
    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }
    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }
    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }
    function formatUTCQuarter(d) {
      return 1 + ~~(d.getUTCMonth() / 3);
    }
    return {
      format: function(specifier) {
        var f = newFormat(specifier += "", formats);
        f.toString = function() {
          return specifier;
        };
        return f;
      },
      parse: function(specifier) {
        var p = newParse(specifier += "", false);
        p.toString = function() {
          return specifier;
        };
        return p;
      },
      utcFormat: function(specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.toString = function() {
          return specifier;
        };
        return f;
      },
      utcParse: function(specifier) {
        var p = newParse(specifier += "", true);
        p.toString = function() {
          return specifier;
        };
        return p;
      }
    };
  }
  var pads = { "-": "", "_": " ", "0": "0" };
  var numberRe = /^\s*\d+/;
  var percentRe = /^%/;
  var requoteRe = /[\\^$*+?|[\]().{}]/g;
  function pad2(value, fill, width2) {
    var sign3 = value < 0 ? "-" : "", string = (sign3 ? -value : value) + "", length3 = string.length;
    return sign3 + (length3 < width2 ? new Array(width2 - length3 + 1).join(fill) + string : string);
  }
  function requote(s2) {
    return s2.replace(requoteRe, "\\$&");
  }
  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }
  function formatLookup(names) {
    return new Map(names.map((name, i) => [name.toLowerCase(), i]));
  }
  function parseWeekdayNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }
  function parseWeekdayNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.u = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberISO(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.V = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }
  function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }
  function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
  }
  function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
  }
  function parseQuarter(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
  }
  function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }
  function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }
  function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }
  function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }
  function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }
  function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }
  function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }
  function parseMicroseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 6));
    return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
  }
  function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function parseUnixTimestamp(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.Q = +n[0], i + n[0].length) : -1;
  }
  function parseUnixTimestampSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.s = +n[0], i + n[0].length) : -1;
  }
  function formatDayOfMonth(d, p) {
    return pad2(d.getDate(), p, 2);
  }
  function formatHour24(d, p) {
    return pad2(d.getHours(), p, 2);
  }
  function formatHour12(d, p) {
    return pad2(d.getHours() % 12 || 12, p, 2);
  }
  function formatDayOfYear(d, p) {
    return pad2(1 + timeDay.count(timeYear(d), d), p, 3);
  }
  function formatMilliseconds(d, p) {
    return pad2(d.getMilliseconds(), p, 3);
  }
  function formatMicroseconds(d, p) {
    return formatMilliseconds(d, p) + "000";
  }
  function formatMonthNumber(d, p) {
    return pad2(d.getMonth() + 1, p, 2);
  }
  function formatMinutes(d, p) {
    return pad2(d.getMinutes(), p, 2);
  }
  function formatSeconds(d, p) {
    return pad2(d.getSeconds(), p, 2);
  }
  function formatWeekdayNumberMonday(d) {
    var day = d.getDay();
    return day === 0 ? 7 : day;
  }
  function formatWeekNumberSunday(d, p) {
    return pad2(timeSunday.count(timeYear(d) - 1, d), p, 2);
  }
  function dISO(d) {
    var day = d.getDay();
    return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  }
  function formatWeekNumberISO(d, p) {
    d = dISO(d);
    return pad2(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
  }
  function formatWeekdayNumberSunday(d) {
    return d.getDay();
  }
  function formatWeekNumberMonday(d, p) {
    return pad2(timeMonday.count(timeYear(d) - 1, d), p, 2);
  }
  function formatYear2(d, p) {
    return pad2(d.getFullYear() % 100, p, 2);
  }
  function formatYearISO(d, p) {
    d = dISO(d);
    return pad2(d.getFullYear() % 100, p, 2);
  }
  function formatFullYear(d, p) {
    return pad2(d.getFullYear() % 1e4, p, 4);
  }
  function formatFullYearISO(d, p) {
    var day = d.getDay();
    d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
    return pad2(d.getFullYear() % 1e4, p, 4);
  }
  function formatZone(d) {
    var z2 = d.getTimezoneOffset();
    return (z2 > 0 ? "-" : (z2 *= -1, "+")) + pad2(z2 / 60 | 0, "0", 2) + pad2(z2 % 60, "0", 2);
  }
  function formatUTCDayOfMonth(d, p) {
    return pad2(d.getUTCDate(), p, 2);
  }
  function formatUTCHour24(d, p) {
    return pad2(d.getUTCHours(), p, 2);
  }
  function formatUTCHour12(d, p) {
    return pad2(d.getUTCHours() % 12 || 12, p, 2);
  }
  function formatUTCDayOfYear(d, p) {
    return pad2(1 + utcDay.count(utcYear(d), d), p, 3);
  }
  function formatUTCMilliseconds(d, p) {
    return pad2(d.getUTCMilliseconds(), p, 3);
  }
  function formatUTCMicroseconds(d, p) {
    return formatUTCMilliseconds(d, p) + "000";
  }
  function formatUTCMonthNumber(d, p) {
    return pad2(d.getUTCMonth() + 1, p, 2);
  }
  function formatUTCMinutes(d, p) {
    return pad2(d.getUTCMinutes(), p, 2);
  }
  function formatUTCSeconds(d, p) {
    return pad2(d.getUTCSeconds(), p, 2);
  }
  function formatUTCWeekdayNumberMonday(d) {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
  }
  function formatUTCWeekNumberSunday(d, p) {
    return pad2(utcSunday.count(utcYear(d) - 1, d), p, 2);
  }
  function UTCdISO(d) {
    var day = d.getUTCDay();
    return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  }
  function formatUTCWeekNumberISO(d, p) {
    d = UTCdISO(d);
    return pad2(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
  }
  function formatUTCWeekdayNumberSunday(d) {
    return d.getUTCDay();
  }
  function formatUTCWeekNumberMonday(d, p) {
    return pad2(utcMonday.count(utcYear(d) - 1, d), p, 2);
  }
  function formatUTCYear(d, p) {
    return pad2(d.getUTCFullYear() % 100, p, 2);
  }
  function formatUTCYearISO(d, p) {
    d = UTCdISO(d);
    return pad2(d.getUTCFullYear() % 100, p, 2);
  }
  function formatUTCFullYear(d, p) {
    return pad2(d.getUTCFullYear() % 1e4, p, 4);
  }
  function formatUTCFullYearISO(d, p) {
    var day = d.getUTCDay();
    d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
    return pad2(d.getUTCFullYear() % 1e4, p, 4);
  }
  function formatUTCZone() {
    return "+0000";
  }
  function formatLiteralPercent() {
    return "%";
  }
  function formatUnixTimestamp(d) {
    return +d;
  }
  function formatUnixTimestampSeconds(d) {
    return Math.floor(+d / 1e3);
  }

  // node_modules/d3-time-format/src/defaultLocale.js
  var locale2;
  var timeFormat;
  var timeParse;
  var utcFormat;
  var utcParse;
  defaultLocale2({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });
  function defaultLocale2(definition) {
    locale2 = formatLocale(definition);
    timeFormat = locale2.format;
    timeParse = locale2.parse;
    utcFormat = locale2.utcFormat;
    utcParse = locale2.utcParse;
    return locale2;
  }

  // node_modules/d3-time-format/src/isoFormat.js
  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
  function formatIsoNative(date2) {
    return date2.toISOString();
  }
  var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);
  var isoFormat_default = formatIso;

  // node_modules/d3-time-format/src/isoParse.js
  function parseIsoNative(string) {
    var date2 = new Date(string);
    return isNaN(date2) ? null : date2;
  }
  var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);
  var isoParse_default = parseIso;

  // node_modules/d3-scale/src/time.js
  function date(t) {
    return new Date(t);
  }
  function number4(t) {
    return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
  }
  function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
    var scale2 = continuous(), invert = scale2.invert, domain = scale2.domain;
    var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear3 = format2("%Y");
    function tickFormat2(date2) {
      return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear3)(date2);
    }
    scale2.invert = function(y5) {
      return new Date(invert(y5));
    };
    scale2.domain = function(_25) {
      return arguments.length ? domain(Array.from(_25, number4)) : domain().map(date);
    };
    scale2.ticks = function(interval2) {
      var d = domain();
      return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    };
    scale2.tickFormat = function(count3, specifier) {
      return specifier == null ? tickFormat2 : format2(specifier);
    };
    scale2.nice = function(interval2) {
      var d = domain();
      if (!interval2 || typeof interval2.range !== "function") interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
      return interval2 ? domain(nice2(d, interval2)) : scale2;
    };
    scale2.copy = function() {
      return copy(scale2, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
    };
    return scale2;
  }
  function time() {
    return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
  }

  // node_modules/d3-scale/src/utcTime.js
  function utcTime() {
    return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
  }

  // node_modules/d3-scale/src/sequential.js
  function transformer3() {
    var x06 = 0, x12 = 1, t03, t13, k10, transform2, interpolator = identity3, clamp = false, unknown;
    function scale2(x5) {
      return x5 == null || isNaN(x5 = +x5) ? unknown : interpolator(k10 === 0 ? 0.5 : (x5 = (transform2(x5) - t03) * k10, clamp ? Math.max(0, Math.min(1, x5)) : x5));
    }
    scale2.domain = function(_25) {
      return arguments.length ? ([x06, x12] = _25, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03), scale2) : [x06, x12];
    };
    scale2.clamp = function(_25) {
      return arguments.length ? (clamp = !!_25, scale2) : clamp;
    };
    scale2.interpolator = function(_25) {
      return arguments.length ? (interpolator = _25, scale2) : interpolator;
    };
    function range6(interpolate) {
      return function(_25) {
        var r0, r1;
        return arguments.length ? ([r0, r1] = _25, interpolator = interpolate(r0, r1), scale2) : [interpolator(0), interpolator(1)];
      };
    }
    scale2.range = range6(value_default);
    scale2.rangeRound = range6(round_default);
    scale2.unknown = function(_25) {
      return arguments.length ? (unknown = _25, scale2) : unknown;
    };
    return function(t) {
      transform2 = t, t03 = t(x06), t13 = t(x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03);
      return scale2;
    };
  }
  function copy2(source2, target) {
    return target.domain(source2.domain()).interpolator(source2.interpolator()).clamp(source2.clamp()).unknown(source2.unknown());
  }
  function sequential() {
    var scale2 = linearish(transformer3()(identity3));
    scale2.copy = function() {
      return copy2(scale2, sequential());
    };
    return initInterpolator.apply(scale2, arguments);
  }
  function sequentialLog() {
    var scale2 = loggish(transformer3()).domain([1, 10]);
    scale2.copy = function() {
      return copy2(scale2, sequentialLog()).base(scale2.base());
    };
    return initInterpolator.apply(scale2, arguments);
  }
  function sequentialSymlog() {
    var scale2 = symlogish(transformer3());
    scale2.copy = function() {
      return copy2(scale2, sequentialSymlog()).constant(scale2.constant());
    };
    return initInterpolator.apply(scale2, arguments);
  }
  function sequentialPow() {
    var scale2 = powish(transformer3());
    scale2.copy = function() {
      return copy2(scale2, sequentialPow()).exponent(scale2.exponent());
    };
    return initInterpolator.apply(scale2, arguments);
  }
  function sequentialSqrt() {
    return sequentialPow.apply(null, arguments).exponent(0.5);
  }

  // node_modules/d3-scale/src/sequentialQuantile.js
  function sequentialQuantile() {
    var domain = [], interpolator = identity3;
    function scale2(x5) {
      if (x5 != null && !isNaN(x5 = +x5)) return interpolator((bisect_default(domain, x5, 1) - 1) / (domain.length - 1));
    }
    scale2.domain = function(_25) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (let d of _25) if (d != null && !isNaN(d = +d)) domain.push(d);
      domain.sort(ascending);
      return scale2;
    };
    scale2.interpolator = function(_25) {
      return arguments.length ? (interpolator = _25, scale2) : interpolator;
    };
    scale2.range = function() {
      return domain.map((d, i) => interpolator(i / (domain.length - 1)));
    };
    scale2.quantiles = function(n) {
      return Array.from({ length: n + 1 }, (_25, i) => quantile(domain, i / n));
    };
    scale2.copy = function() {
      return sequentialQuantile(interpolator).domain(domain);
    };
    return initInterpolator.apply(scale2, arguments);
  }

  // node_modules/d3-scale/src/diverging.js
  function transformer4() {
    var x06 = 0, x12 = 0.5, x22 = 1, s2 = 1, t03, t13, t22, k10, k21, interpolator = identity3, transform2, clamp = false, unknown;
    function scale2(x5) {
      return isNaN(x5 = +x5) ? unknown : (x5 = 0.5 + ((x5 = +transform2(x5)) - t13) * (s2 * x5 < s2 * t13 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x5)) : x5));
    }
    scale2.domain = function(_25) {
      return arguments.length ? ([x06, x12, x22] = _25, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), t22 = transform2(x22 = +x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1, scale2) : [x06, x12, x22];
    };
    scale2.clamp = function(_25) {
      return arguments.length ? (clamp = !!_25, scale2) : clamp;
    };
    scale2.interpolator = function(_25) {
      return arguments.length ? (interpolator = _25, scale2) : interpolator;
    };
    function range6(interpolate) {
      return function(_25) {
        var r0, r1, r2;
        return arguments.length ? ([r0, r1, r2] = _25, interpolator = piecewise(interpolate, [r0, r1, r2]), scale2) : [interpolator(0), interpolator(0.5), interpolator(1)];
      };
    }
    scale2.range = range6(value_default);
    scale2.rangeRound = range6(round_default);
    scale2.unknown = function(_25) {
      return arguments.length ? (unknown = _25, scale2) : unknown;
    };
    return function(t) {
      transform2 = t, t03 = t(x06), t13 = t(x12), t22 = t(x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1;
      return scale2;
    };
  }
  function diverging() {
    var scale2 = linearish(transformer4()(identity3));
    scale2.copy = function() {
      return copy2(scale2, diverging());
    };
    return initInterpolator.apply(scale2, arguments);
  }
  function divergingLog() {
    var scale2 = loggish(transformer4()).domain([0.1, 1, 10]);
    scale2.copy = function() {
      return copy2(scale2, divergingLog()).base(scale2.base());
    };
    return initInterpolator.apply(scale2, arguments);
  }
  function divergingSymlog() {
    var scale2 = symlogish(transformer4());
    scale2.copy = function() {
      return copy2(scale2, divergingSymlog()).constant(scale2.constant());
    };
    return initInterpolator.apply(scale2, arguments);
  }
  function divergingPow() {
    var scale2 = powish(transformer4());
    scale2.copy = function() {
      return copy2(scale2, divergingPow()).exponent(scale2.exponent());
    };
    return initInterpolator.apply(scale2, arguments);
  }
  function divergingSqrt() {
    return divergingPow.apply(null, arguments).exponent(0.5);
  }

  // node_modules/d3-scale-chromatic/src/colors.js
  function colors_default(specifier) {
    var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
    while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
    return colors;
  }

  // node_modules/d3-scale-chromatic/src/categorical/category10.js
  var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

  // node_modules/d3-scale-chromatic/src/categorical/Accent.js
  var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

  // node_modules/d3-scale-chromatic/src/categorical/Dark2.js
  var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

  // node_modules/d3-scale-chromatic/src/categorical/observable10.js
  var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

  // node_modules/d3-scale-chromatic/src/categorical/Paired.js
  var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

  // node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
  var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

  // node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
  var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

  // node_modules/d3-scale-chromatic/src/categorical/Set1.js
  var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

  // node_modules/d3-scale-chromatic/src/categorical/Set2.js
  var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

  // node_modules/d3-scale-chromatic/src/categorical/Set3.js
  var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

  // node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
  var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

  // node_modules/d3-scale-chromatic/src/ramp.js
  var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

  // node_modules/d3-scale-chromatic/src/diverging/BrBG.js
  var scheme = new Array(3).concat(
    "d8b365f5f5f55ab4ac",
    "a6611adfc27d80cdc1018571",
    "a6611adfc27df5f5f580cdc1018571",
    "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
    "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
    "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
    "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
    "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
    "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
  ).map(colors_default);
  var BrBG_default = ramp_default(scheme);

  // node_modules/d3-scale-chromatic/src/diverging/PRGn.js
  var scheme2 = new Array(3).concat(
    "af8dc3f7f7f77fbf7b",
    "7b3294c2a5cfa6dba0008837",
    "7b3294c2a5cff7f7f7a6dba0008837",
    "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
    "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
    "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
    "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
    "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
    "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
  ).map(colors_default);
  var PRGn_default = ramp_default(scheme2);

  // node_modules/d3-scale-chromatic/src/diverging/PiYG.js
  var scheme3 = new Array(3).concat(
    "e9a3c9f7f7f7a1d76a",
    "d01c8bf1b6dab8e1864dac26",
    "d01c8bf1b6daf7f7f7b8e1864dac26",
    "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
    "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
    "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
    "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
    "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
    "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
  ).map(colors_default);
  var PiYG_default = ramp_default(scheme3);

  // node_modules/d3-scale-chromatic/src/diverging/PuOr.js
  var scheme4 = new Array(3).concat(
    "998ec3f7f7f7f1a340",
    "5e3c99b2abd2fdb863e66101",
    "5e3c99b2abd2f7f7f7fdb863e66101",
    "542788998ec3d8daebfee0b6f1a340b35806",
    "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
    "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
    "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
    "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
    "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
  ).map(colors_default);
  var PuOr_default = ramp_default(scheme4);

  // node_modules/d3-scale-chromatic/src/diverging/RdBu.js
  var scheme5 = new Array(3).concat(
    "ef8a62f7f7f767a9cf",
    "ca0020f4a58292c5de0571b0",
    "ca0020f4a582f7f7f792c5de0571b0",
    "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
    "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
    "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
    "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
    "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
    "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
  ).map(colors_default);
  var RdBu_default = ramp_default(scheme5);

  // node_modules/d3-scale-chromatic/src/diverging/RdGy.js
  var scheme6 = new Array(3).concat(
    "ef8a62ffffff999999",
    "ca0020f4a582bababa404040",
    "ca0020f4a582ffffffbababa404040",
    "b2182bef8a62fddbc7e0e0e09999994d4d4d",
    "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
    "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
    "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
    "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
    "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
  ).map(colors_default);
  var RdGy_default = ramp_default(scheme6);

  // node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
  var scheme7 = new Array(3).concat(
    "fc8d59ffffbf91bfdb",
    "d7191cfdae61abd9e92c7bb6",
    "d7191cfdae61ffffbfabd9e92c7bb6",
    "d73027fc8d59fee090e0f3f891bfdb4575b4",
    "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
    "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
    "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
    "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
    "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
  ).map(colors_default);
  var RdYlBu_default = ramp_default(scheme7);

  // node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
  var scheme8 = new Array(3).concat(
    "fc8d59ffffbf91cf60",
    "d7191cfdae61a6d96a1a9641",
    "d7191cfdae61ffffbfa6d96a1a9641",
    "d73027fc8d59fee08bd9ef8b91cf601a9850",
    "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
    "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
    "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
    "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
    "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
  ).map(colors_default);
  var RdYlGn_default = ramp_default(scheme8);

  // node_modules/d3-scale-chromatic/src/diverging/Spectral.js
  var scheme9 = new Array(3).concat(
    "fc8d59ffffbf99d594",
    "d7191cfdae61abdda42b83ba",
    "d7191cfdae61ffffbfabdda42b83ba",
    "d53e4ffc8d59fee08be6f59899d5943288bd",
    "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
    "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
    "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
    "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
    "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
  ).map(colors_default);
  var Spectral_default = ramp_default(scheme9);

  // node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
  var scheme10 = new Array(3).concat(
    "e5f5f999d8c92ca25f",
    "edf8fbb2e2e266c2a4238b45",
    "edf8fbb2e2e266c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
  ).map(colors_default);
  var BuGn_default = ramp_default(scheme10);

  // node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
  var scheme11 = new Array(3).concat(
    "e0ecf49ebcda8856a7",
    "edf8fbb3cde38c96c688419d",
    "edf8fbb3cde38c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
  ).map(colors_default);
  var BuPu_default = ramp_default(scheme11);

  // node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
  var scheme12 = new Array(3).concat(
    "e0f3dba8ddb543a2ca",
    "f0f9e8bae4bc7bccc42b8cbe",
    "f0f9e8bae4bc7bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
  ).map(colors_default);
  var GnBu_default = ramp_default(scheme12);

  // node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
  var scheme13 = new Array(3).concat(
    "fee8c8fdbb84e34a33",
    "fef0d9fdcc8afc8d59d7301f",
    "fef0d9fdcc8afc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
  ).map(colors_default);
  var OrRd_default = ramp_default(scheme13);

  // node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
  var scheme14 = new Array(3).concat(
    "ece2f0a6bddb1c9099",
    "f6eff7bdc9e167a9cf02818a",
    "f6eff7bdc9e167a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
  ).map(colors_default);
  var PuBuGn_default = ramp_default(scheme14);

  // node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
  var scheme15 = new Array(3).concat(
    "ece7f2a6bddb2b8cbe",
    "f1eef6bdc9e174a9cf0570b0",
    "f1eef6bdc9e174a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
  ).map(colors_default);
  var PuBu_default = ramp_default(scheme15);

  // node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
  var scheme16 = new Array(3).concat(
    "e7e1efc994c7dd1c77",
    "f1eef6d7b5d8df65b0ce1256",
    "f1eef6d7b5d8df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
  ).map(colors_default);
  var PuRd_default = ramp_default(scheme16);

  // node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
  var scheme17 = new Array(3).concat(
    "fde0ddfa9fb5c51b8a",
    "feebe2fbb4b9f768a1ae017e",
    "feebe2fbb4b9f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
  ).map(colors_default);
  var RdPu_default = ramp_default(scheme17);

  // node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
  var scheme18 = new Array(3).concat(
    "edf8b17fcdbb2c7fb8",
    "ffffcca1dab441b6c4225ea8",
    "ffffcca1dab441b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
  ).map(colors_default);
  var YlGnBu_default = ramp_default(scheme18);

  // node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
  var scheme19 = new Array(3).concat(
    "f7fcb9addd8e31a354",
    "ffffccc2e69978c679238443",
    "ffffccc2e69978c67931a354006837",
    "ffffccd9f0a3addd8e78c67931a354006837",
    "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
  ).map(colors_default);
  var YlGn_default = ramp_default(scheme19);

  // node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
  var scheme20 = new Array(3).concat(
    "fff7bcfec44fd95f0e",
    "ffffd4fed98efe9929cc4c02",
    "ffffd4fed98efe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
  ).map(colors_default);
  var YlOrBr_default = ramp_default(scheme20);

  // node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
  var scheme21 = new Array(3).concat(
    "ffeda0feb24cf03b20",
    "ffffb2fecc5cfd8d3ce31a1c",
    "ffffb2fecc5cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
  ).map(colors_default);
  var YlOrRd_default = ramp_default(scheme21);

  // node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
  var scheme22 = new Array(3).concat(
    "deebf79ecae13182bd",
    "eff3ffbdd7e76baed62171b5",
    "eff3ffbdd7e76baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
  ).map(colors_default);
  var Blues_default = ramp_default(scheme22);

  // node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
  var scheme23 = new Array(3).concat(
    "e5f5e0a1d99b31a354",
    "edf8e9bae4b374c476238b45",
    "edf8e9bae4b374c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
  ).map(colors_default);
  var Greens_default = ramp_default(scheme23);

  // node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
  var scheme24 = new Array(3).concat(
    "f0f0f0bdbdbd636363",
    "f7f7f7cccccc969696525252",
    "f7f7f7cccccc969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
  ).map(colors_default);
  var Greys_default = ramp_default(scheme24);

  // node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
  var scheme25 = new Array(3).concat(
    "efedf5bcbddc756bb1",
    "f2f0f7cbc9e29e9ac86a51a3",
    "f2f0f7cbc9e29e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
  ).map(colors_default);
  var Purples_default = ramp_default(scheme25);

  // node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
  var scheme26 = new Array(3).concat(
    "fee0d2fc9272de2d26",
    "fee5d9fcae91fb6a4acb181d",
    "fee5d9fcae91fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
  ).map(colors_default);
  var Reds_default = ramp_default(scheme26);

  // node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
  var scheme27 = new Array(3).concat(
    "fee6cefdae6be6550d",
    "feeddefdbe85fd8d3cd94701",
    "feeddefdbe85fd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
  ).map(colors_default);
  var Oranges_default = ramp_default(scheme27);

  // node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
  function cividis_default(t) {
    t = Math.max(0, Math.min(1, t));
    return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
  }

  // node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
  var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

  // node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
  var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
  var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
  var c3 = cubehelix();
  function rainbow_default(t) {
    if (t < 0 || t > 1) t -= Math.floor(t);
    var ts = Math.abs(t - 0.5);
    c3.h = 360 * t - 100;
    c3.s = 1.5 - 1.5 * ts;
    c3.l = 0.8 - 0.9 * ts;
    return c3 + "";
  }

  // node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
  var c4 = rgb();
  var pi_1_3 = Math.PI / 3;
  var pi_2_3 = Math.PI * 2 / 3;
  function sinebow_default(t) {
    var x5;
    t = (0.5 - t) * Math.PI;
    c4.r = 255 * (x5 = Math.sin(t)) * x5;
    c4.g = 255 * (x5 = Math.sin(t + pi_1_3)) * x5;
    c4.b = 255 * (x5 = Math.sin(t + pi_2_3)) * x5;
    return c4 + "";
  }

  // node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
  function turbo_default(t) {
    t = Math.max(0, Math.min(1, t));
    return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
  }

  // node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
  function ramp(range6) {
    var n = range6.length;
    return function(t) {
      return range6[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }
  var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
  var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
  var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
  var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

  // node_modules/d3-shape/src/constant.js
  function constant_default10(x5) {
    return function constant2() {
      return x5;
    };
  }

  // node_modules/d3-shape/src/math.js
  var abs4 = Math.abs;
  var atan22 = Math.atan2;
  var cos3 = Math.cos;
  var max4 = Math.max;
  var min3 = Math.min;
  var sin3 = Math.sin;
  var sqrt3 = Math.sqrt;
  var epsilon8 = 1e-12;
  var pi5 = Math.PI;
  var halfPi4 = pi5 / 2;
  var tau6 = 2 * pi5;
  function acos2(x5) {
    return x5 > 1 ? 0 : x5 < -1 ? pi5 : Math.acos(x5);
  }
  function asin2(x5) {
    return x5 >= 1 ? halfPi4 : x5 <= -1 ? -halfPi4 : Math.asin(x5);
  }

  // node_modules/d3-shape/src/path.js
  function withPath(shape) {
    let digits = 3;
    shape.digits = function(_25) {
      if (!arguments.length) return digits;
      if (_25 == null) {
        digits = null;
      } else {
        const d = Math.floor(_25);
        if (!(d >= 0)) throw new RangeError(`invalid digits: ${_25}`);
        digits = d;
      }
      return shape;
    };
    return () => new Path(digits);
  }

  // node_modules/d3-shape/src/arc.js
  function arcInnerRadius(d) {
    return d.innerRadius;
  }
  function arcOuterRadius(d) {
    return d.outerRadius;
  }
  function arcStartAngle(d) {
    return d.startAngle;
  }
  function arcEndAngle(d) {
    return d.endAngle;
  }
  function arcPadAngle(d) {
    return d && d.padAngle;
  }
  function intersect(x06, y06, x12, y12, x22, y22, x32, y32) {
    var x10 = x12 - x06, y10 = y12 - y06, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;
    if (t * t < epsilon8) return;
    t = (x322 * (y06 - y22) - y322 * (x06 - x22)) / t;
    return [x06 + t * x10, y06 + t * y10];
  }
  function cornerTangents(x06, y06, x12, y12, r1, rc, cw) {
    var x01 = x06 - x12, y01 = y06 - y12, lo = (cw ? rc : -rc) / sqrt3(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x06 + ox, y11 = y06 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D4 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt3(max4(0, r * r * d2 - D4 * D4)), cx0 = (D4 * dy - dx * d) / d2, cy0 = (-D4 * dx - dy * d) / d2, cx1 = (D4 * dy + dx * d) / d2, cy1 = (-D4 * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return {
      cx: cx0,
      cy: cy0,
      x01: -ox,
      y01: -oy,
      x11: cx0 * (r1 / r - 1),
      y11: cy0 * (r1 / r - 1)
    };
  }
  function arc_default() {
    var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default10(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
    function arc() {
      var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi4, a1 = endAngle.apply(this, arguments) - halfPi4, da2 = abs4(a1 - a0), cw = a1 > a0;
      if (!context) context = buffer = path2();
      if (r1 < r0) r = r1, r1 = r0, r0 = r;
      if (!(r1 > epsilon8)) context.moveTo(0, 0);
      else if (da2 > tau6 - epsilon8) {
        context.moveTo(r1 * cos3(a0), r1 * sin3(a0));
        context.arc(0, 0, r1, a0, a1, !cw);
        if (r0 > epsilon8) {
          context.moveTo(r0 * cos3(a1), r0 * sin3(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      } else {
        var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da2, da1 = da2, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon8 && (padRadius ? +padRadius.apply(this, arguments) : sqrt3(r0 * r0 + r1 * r1)), rc = min3(abs4(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t03, t13;
        if (rp > epsilon8) {
          var p02 = asin2(rp / r0 * sin3(ap)), p1 = asin2(rp / r1 * sin3(ap));
          if ((da0 -= p02 * 2) > epsilon8) p02 *= cw ? 1 : -1, a00 += p02, a10 -= p02;
          else da0 = 0, a00 = a10 = (a0 + a1) / 2;
          if ((da1 -= p1 * 2) > epsilon8) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
          else da1 = 0, a01 = a11 = (a0 + a1) / 2;
        }
        var x01 = r1 * cos3(a01), y01 = r1 * sin3(a01), x10 = r0 * cos3(a10), y10 = r0 * sin3(a10);
        if (rc > epsilon8) {
          var x11 = r1 * cos3(a11), y11 = r1 * sin3(a11), x004 = r0 * cos3(a00), y004 = r0 * sin3(a00), oc;
          if (da2 < pi5) {
            if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
              var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin3(acos2((ax * bx + ay * by) / (sqrt3(ax * ax + ay * ay) * sqrt3(bx * bx + by * by))) / 2), lc = sqrt3(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min3(rc, (r0 - lc) / (kc - 1));
              rc1 = min3(rc, (r1 - lc) / (kc + 1));
            } else {
              rc0 = rc1 = 0;
            }
          }
        }
        if (!(da1 > epsilon8)) context.moveTo(x01, y01);
        else if (rc1 > epsilon8) {
          t03 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw);
          t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
          context.moveTo(t03.cx + t03.x01, t03.cy + t03.y01);
          if (rc1 < rc) context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);
          else {
            context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);
            context.arc(0, 0, r1, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), !cw);
            context.arc(t13.cx, t13.cy, rc1, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);
          }
        } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
        if (!(r0 > epsilon8) || !(da0 > epsilon8)) context.lineTo(x10, y10);
        else if (rc0 > epsilon8) {
          t03 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
          t13 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw);
          context.lineTo(t03.cx + t03.x01, t03.cy + t03.y01);
          if (rc0 < rc) context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);
          else {
            context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);
            context.arc(0, 0, r0, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), cw);
            context.arc(t13.cx, t13.cy, rc0, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);
          }
        } else context.arc(0, 0, r0, a10, a00, cw);
      }
      context.closePath();
      if (buffer) return context = null, buffer + "" || null;
    }
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a4 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi5 / 2;
      return [cos3(a4) * r, sin3(a4) * r];
    };
    arc.innerRadius = function(_25) {
      return arguments.length ? (innerRadius = typeof _25 === "function" ? _25 : constant_default10(+_25), arc) : innerRadius;
    };
    arc.outerRadius = function(_25) {
      return arguments.length ? (outerRadius = typeof _25 === "function" ? _25 : constant_default10(+_25), arc) : outerRadius;
    };
    arc.cornerRadius = function(_25) {
      return arguments.length ? (cornerRadius = typeof _25 === "function" ? _25 : constant_default10(+_25), arc) : cornerRadius;
    };
    arc.padRadius = function(_25) {
      return arguments.length ? (padRadius = _25 == null ? null : typeof _25 === "function" ? _25 : constant_default10(+_25), arc) : padRadius;
    };
    arc.startAngle = function(_25) {
      return arguments.length ? (startAngle = typeof _25 === "function" ? _25 : constant_default10(+_25), arc) : startAngle;
    };
    arc.endAngle = function(_25) {
      return arguments.length ? (endAngle = typeof _25 === "function" ? _25 : constant_default10(+_25), arc) : endAngle;
    };
    arc.padAngle = function(_25) {
      return arguments.length ? (padAngle = typeof _25 === "function" ? _25 : constant_default10(+_25), arc) : padAngle;
    };
    arc.context = function(_25) {
      return arguments.length ? (context = _25 == null ? null : _25, arc) : context;
    };
    return arc;
  }

  // node_modules/d3-shape/src/array.js
  var slice4 = Array.prototype.slice;
  function array_default3(x5) {
    return typeof x5 === "object" && "length" in x5 ? x5 : Array.from(x5);
  }

  // node_modules/d3-shape/src/curve/linear.js
  function Linear(context) {
    this._context = context;
  }
  Linear.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x5, y5) {
      x5 = +x5, y5 = +y5;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
          break;
        case 1:
          this._point = 2;
        // falls through
        default:
          this._context.lineTo(x5, y5);
          break;
      }
    }
  };
  function linear_default(context) {
    return new Linear(context);
  }

  // node_modules/d3-shape/src/point.js
  function x3(p) {
    return p[0];
  }
  function y3(p) {
    return p[1];
  }

  // node_modules/d3-shape/src/line.js
  function line_default2(x5, y5) {
    var defined = constant_default10(true), context = null, curve = linear_default, output = null, path2 = withPath(line);
    x5 = typeof x5 === "function" ? x5 : x5 === void 0 ? x3 : constant_default10(x5);
    y5 = typeof y5 === "function" ? y5 : y5 === void 0 ? y3 : constant_default10(y5);
    function line(data2) {
      var i, n = (data2 = array_default3(data2)).length, d, defined0 = false, buffer;
      if (context == null) output = curve(buffer = path2());
      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data2[i], i, data2)) === defined0) {
          if (defined0 = !defined0) output.lineStart();
          else output.lineEnd();
        }
        if (defined0) output.point(+x5(d, i, data2), +y5(d, i, data2));
      }
      if (buffer) return output = null, buffer + "" || null;
    }
    line.x = function(_25) {
      return arguments.length ? (x5 = typeof _25 === "function" ? _25 : constant_default10(+_25), line) : x5;
    };
    line.y = function(_25) {
      return arguments.length ? (y5 = typeof _25 === "function" ? _25 : constant_default10(+_25), line) : y5;
    };
    line.defined = function(_25) {
      return arguments.length ? (defined = typeof _25 === "function" ? _25 : constant_default10(!!_25), line) : defined;
    };
    line.curve = function(_25) {
      return arguments.length ? (curve = _25, context != null && (output = curve(context)), line) : curve;
    };
    line.context = function(_25) {
      return arguments.length ? (_25 == null ? context = output = null : output = curve(context = _25), line) : context;
    };
    return line;
  }

  // node_modules/d3-shape/src/area.js
  function area_default5(x06, y06, y12) {
    var x12 = null, defined = constant_default10(true), context = null, curve = linear_default, output = null, path2 = withPath(area);
    x06 = typeof x06 === "function" ? x06 : x06 === void 0 ? x3 : constant_default10(+x06);
    y06 = typeof y06 === "function" ? y06 : y06 === void 0 ? constant_default10(0) : constant_default10(+y06);
    y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y3 : constant_default10(+y12);
    function area(data2) {
      var i, j2, k3, n = (data2 = array_default3(data2)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
      if (context == null) output = curve(buffer = path2());
      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data2[i], i, data2)) === defined0) {
          if (defined0 = !defined0) {
            j2 = i;
            output.areaStart();
            output.lineStart();
          } else {
            output.lineEnd();
            output.lineStart();
            for (k3 = i - 1; k3 >= j2; --k3) {
              output.point(x0z[k3], y0z[k3]);
            }
            output.lineEnd();
            output.areaEnd();
          }
        }
        if (defined0) {
          x0z[i] = +x06(d, i, data2), y0z[i] = +y06(d, i, data2);
          output.point(x12 ? +x12(d, i, data2) : x0z[i], y12 ? +y12(d, i, data2) : y0z[i]);
        }
      }
      if (buffer) return output = null, buffer + "" || null;
    }
    function arealine() {
      return line_default2().defined(defined).curve(curve).context(context);
    }
    area.x = function(_25) {
      return arguments.length ? (x06 = typeof _25 === "function" ? _25 : constant_default10(+_25), x12 = null, area) : x06;
    };
    area.x0 = function(_25) {
      return arguments.length ? (x06 = typeof _25 === "function" ? _25 : constant_default10(+_25), area) : x06;
    };
    area.x1 = function(_25) {
      return arguments.length ? (x12 = _25 == null ? null : typeof _25 === "function" ? _25 : constant_default10(+_25), area) : x12;
    };
    area.y = function(_25) {
      return arguments.length ? (y06 = typeof _25 === "function" ? _25 : constant_default10(+_25), y12 = null, area) : y06;
    };
    area.y0 = function(_25) {
      return arguments.length ? (y06 = typeof _25 === "function" ? _25 : constant_default10(+_25), area) : y06;
    };
    area.y1 = function(_25) {
      return arguments.length ? (y12 = _25 == null ? null : typeof _25 === "function" ? _25 : constant_default10(+_25), area) : y12;
    };
    area.lineX0 = area.lineY0 = function() {
      return arealine().x(x06).y(y06);
    };
    area.lineY1 = function() {
      return arealine().x(x06).y(y12);
    };
    area.lineX1 = function() {
      return arealine().x(x12).y(y06);
    };
    area.defined = function(_25) {
      return arguments.length ? (defined = typeof _25 === "function" ? _25 : constant_default10(!!_25), area) : defined;
    };
    area.curve = function(_25) {
      return arguments.length ? (curve = _25, context != null && (output = curve(context)), area) : curve;
    };
    area.context = function(_25) {
      return arguments.length ? (_25 == null ? context = output = null : output = curve(context = _25), area) : context;
    };
    return area;
  }

  // node_modules/d3-shape/src/descending.js
  function descending_default(a4, b10) {
    return b10 < a4 ? -1 : b10 > a4 ? 1 : b10 >= a4 ? 0 : NaN;
  }

  // node_modules/d3-shape/src/identity.js
  function identity_default5(d) {
    return d;
  }

  // node_modules/d3-shape/src/pie.js
  function pie_default() {
    var value = identity_default5, sortValues = descending_default, sort2 = null, startAngle = constant_default10(0), endAngle = constant_default10(tau6), padAngle = constant_default10(0);
    function pie(data2) {
      var i, n = (data2 = array_default3(data2)).length, j2, k3, sum4 = 0, index4 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da2 = Math.min(tau6, Math.max(-tau6, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da2) / n, padAngle.apply(this, arguments)), pa = p * (da2 < 0 ? -1 : 1), v3;
      for (i = 0; i < n; ++i) {
        if ((v3 = arcs[index4[i] = i] = +value(data2[i], i, data2)) > 0) {
          sum4 += v3;
        }
      }
      if (sortValues != null) index4.sort(function(i2, j3) {
        return sortValues(arcs[i2], arcs[j3]);
      });
      else if (sort2 != null) index4.sort(function(i2, j3) {
        return sort2(data2[i2], data2[j3]);
      });
      for (i = 0, k3 = sum4 ? (da2 - n * pa) / sum4 : 0; i < n; ++i, a0 = a1) {
        j2 = index4[i], v3 = arcs[j2], a1 = a0 + (v3 > 0 ? v3 * k3 : 0) + pa, arcs[j2] = {
          data: data2[j2],
          index: i,
          value: v3,
          startAngle: a0,
          endAngle: a1,
          padAngle: p
        };
      }
      return arcs;
    }
    pie.value = function(_25) {
      return arguments.length ? (value = typeof _25 === "function" ? _25 : constant_default10(+_25), pie) : value;
    };
    pie.sortValues = function(_25) {
      return arguments.length ? (sortValues = _25, sort2 = null, pie) : sortValues;
    };
    pie.sort = function(_25) {
      return arguments.length ? (sort2 = _25, sortValues = null, pie) : sort2;
    };
    pie.startAngle = function(_25) {
      return arguments.length ? (startAngle = typeof _25 === "function" ? _25 : constant_default10(+_25), pie) : startAngle;
    };
    pie.endAngle = function(_25) {
      return arguments.length ? (endAngle = typeof _25 === "function" ? _25 : constant_default10(+_25), pie) : endAngle;
    };
    pie.padAngle = function(_25) {
      return arguments.length ? (padAngle = typeof _25 === "function" ? _25 : constant_default10(+_25), pie) : padAngle;
    };
    return pie;
  }

  // node_modules/d3-shape/src/curve/radial.js
  var curveRadialLinear = curveRadial(linear_default);
  function Radial(curve) {
    this._curve = curve;
  }
  Radial.prototype = {
    areaStart: function() {
      this._curve.areaStart();
    },
    areaEnd: function() {
      this._curve.areaEnd();
    },
    lineStart: function() {
      this._curve.lineStart();
    },
    lineEnd: function() {
      this._curve.lineEnd();
    },
    point: function(a4, r) {
      this._curve.point(r * Math.sin(a4), r * -Math.cos(a4));
    }
  };
  function curveRadial(curve) {
    function radial2(context) {
      return new Radial(curve(context));
    }
    radial2._curve = curve;
    return radial2;
  }

  // node_modules/d3-shape/src/lineRadial.js
  function lineRadial(l2) {
    var c6 = l2.curve;
    l2.angle = l2.x, delete l2.x;
    l2.radius = l2.y, delete l2.y;
    l2.curve = function(_25) {
      return arguments.length ? c6(curveRadial(_25)) : c6()._curve;
    };
    return l2;
  }
  function lineRadial_default() {
    return lineRadial(line_default2().curve(curveRadialLinear));
  }

  // node_modules/d3-shape/src/areaRadial.js
  function areaRadial_default() {
    var a4 = area_default5().curve(curveRadialLinear), c6 = a4.curve, x06 = a4.lineX0, x12 = a4.lineX1, y06 = a4.lineY0, y12 = a4.lineY1;
    a4.angle = a4.x, delete a4.x;
    a4.startAngle = a4.x0, delete a4.x0;
    a4.endAngle = a4.x1, delete a4.x1;
    a4.radius = a4.y, delete a4.y;
    a4.innerRadius = a4.y0, delete a4.y0;
    a4.outerRadius = a4.y1, delete a4.y1;
    a4.lineStartAngle = function() {
      return lineRadial(x06());
    }, delete a4.lineX0;
    a4.lineEndAngle = function() {
      return lineRadial(x12());
    }, delete a4.lineX1;
    a4.lineInnerRadius = function() {
      return lineRadial(y06());
    }, delete a4.lineY0;
    a4.lineOuterRadius = function() {
      return lineRadial(y12());
    }, delete a4.lineY1;
    a4.curve = function(_25) {
      return arguments.length ? c6(curveRadial(_25)) : c6()._curve;
    };
    return a4;
  }

  // node_modules/d3-shape/src/pointRadial.js
  function pointRadial_default(x5, y5) {
    return [(y5 = +y5) * Math.cos(x5 -= Math.PI / 2), y5 * Math.sin(x5)];
  }

  // node_modules/d3-shape/src/curve/bump.js
  var Bump = class {
    constructor(context, x5) {
      this._context = context;
      this._x = x5;
    }
    areaStart() {
      this._line = 0;
    }
    areaEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    }
    point(x5, y5) {
      x5 = +x5, y5 = +y5;
      switch (this._point) {
        case 0: {
          this._point = 1;
          if (this._line) this._context.lineTo(x5, y5);
          else this._context.moveTo(x5, y5);
          break;
        }
        case 1:
          this._point = 2;
        // falls through
        default: {
          if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x5) / 2, this._y0, this._x0, y5, x5, y5);
          else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y5) / 2, x5, this._y0, x5, y5);
          break;
        }
      }
      this._x0 = x5, this._y0 = y5;
    }
  };
  var BumpRadial = class {
    constructor(context) {
      this._context = context;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
    }
    point(x5, y5) {
      x5 = +x5, y5 = +y5;
      if (this._point === 0) {
        this._point = 1;
      } else {
        const p02 = pointRadial_default(this._x0, this._y0);
        const p1 = pointRadial_default(this._x0, this._y0 = (this._y0 + y5) / 2);
        const p2 = pointRadial_default(x5, this._y0);
        const p3 = pointRadial_default(x5, y5);
        this._context.moveTo(...p02);
        this._context.bezierCurveTo(...p1, ...p2, ...p3);
      }
      this._x0 = x5, this._y0 = y5;
    }
  };
  function bumpX(context) {
    return new Bump(context, true);
  }
  function bumpY(context) {
    return new Bump(context, false);
  }
  function bumpRadial(context) {
    return new BumpRadial(context);
  }

  // node_modules/d3-shape/src/link.js
  function linkSource(d) {
    return d.source;
  }
  function linkTarget(d) {
    return d.target;
  }
  function link3(curve) {
    let source2 = linkSource, target = linkTarget, x5 = x3, y5 = y3, context = null, output = null, path2 = withPath(link4);
    function link4() {
      let buffer;
      const argv = slice4.call(arguments);
      const s2 = source2.apply(this, argv);
      const t = target.apply(this, argv);
      if (context == null) output = curve(buffer = path2());
      output.lineStart();
      argv[0] = s2, output.point(+x5.apply(this, argv), +y5.apply(this, argv));
      argv[0] = t, output.point(+x5.apply(this, argv), +y5.apply(this, argv));
      output.lineEnd();
      if (buffer) return output = null, buffer + "" || null;
    }
    link4.source = function(_25) {
      return arguments.length ? (source2 = _25, link4) : source2;
    };
    link4.target = function(_25) {
      return arguments.length ? (target = _25, link4) : target;
    };
    link4.x = function(_25) {
      return arguments.length ? (x5 = typeof _25 === "function" ? _25 : constant_default10(+_25), link4) : x5;
    };
    link4.y = function(_25) {
      return arguments.length ? (y5 = typeof _25 === "function" ? _25 : constant_default10(+_25), link4) : y5;
    };
    link4.context = function(_25) {
      return arguments.length ? (_25 == null ? context = output = null : output = curve(context = _25), link4) : context;
    };
    return link4;
  }
  function linkHorizontal() {
    return link3(bumpX);
  }
  function linkVertical() {
    return link3(bumpY);
  }
  function linkRadial() {
    const l2 = link3(bumpRadial);
    l2.angle = l2.x, delete l2.x;
    l2.radius = l2.y, delete l2.y;
    return l2;
  }

  // node_modules/d3-shape/src/symbol/asterisk.js
  var sqrt32 = sqrt3(3);
  var asterisk_default = {
    draw(context, size2) {
      const r = sqrt3(size2 + min3(size2 / 28, 0.75)) * 0.59436;
      const t = r / 2;
      const u5 = t * sqrt32;
      context.moveTo(0, r);
      context.lineTo(0, -r);
      context.moveTo(-u5, -t);
      context.lineTo(u5, t);
      context.moveTo(-u5, t);
      context.lineTo(u5, -t);
    }
  };

  // node_modules/d3-shape/src/symbol/circle.js
  var circle_default3 = {
    draw(context, size2) {
      const r = sqrt3(size2 / pi5);
      context.moveTo(r, 0);
      context.arc(0, 0, r, 0, tau6);
    }
  };

  // node_modules/d3-shape/src/symbol/cross.js
  var cross_default2 = {
    draw(context, size2) {
      const r = sqrt3(size2 / 5) / 2;
      context.moveTo(-3 * r, -r);
      context.lineTo(-r, -r);
      context.lineTo(-r, -3 * r);
      context.lineTo(r, -3 * r);
      context.lineTo(r, -r);
      context.lineTo(3 * r, -r);
      context.lineTo(3 * r, r);
      context.lineTo(r, r);
      context.lineTo(r, 3 * r);
      context.lineTo(-r, 3 * r);
      context.lineTo(-r, r);
      context.lineTo(-3 * r, r);
      context.closePath();
    }
  };

  // node_modules/d3-shape/src/symbol/diamond.js
  var tan30 = sqrt3(1 / 3);
  var tan30_2 = tan30 * 2;
  var diamond_default = {
    draw(context, size2) {
      const y5 = sqrt3(size2 / tan30_2);
      const x5 = y5 * tan30;
      context.moveTo(0, -y5);
      context.lineTo(x5, 0);
      context.lineTo(0, y5);
      context.lineTo(-x5, 0);
      context.closePath();
    }
  };

  // node_modules/d3-shape/src/symbol/diamond2.js
  var diamond2_default = {
    draw(context, size2) {
      const r = sqrt3(size2) * 0.62625;
      context.moveTo(0, -r);
      context.lineTo(r, 0);
      context.lineTo(0, r);
      context.lineTo(-r, 0);
      context.closePath();
    }
  };

  // node_modules/d3-shape/src/symbol/plus.js
  var plus_default = {
    draw(context, size2) {
      const r = sqrt3(size2 - min3(size2 / 7, 2)) * 0.87559;
      context.moveTo(-r, 0);
      context.lineTo(r, 0);
      context.moveTo(0, r);
      context.lineTo(0, -r);
    }
  };

  // node_modules/d3-shape/src/symbol/square.js
  var square_default = {
    draw(context, size2) {
      const w = sqrt3(size2);
      const x5 = -w / 2;
      context.rect(x5, x5, w, w);
    }
  };

  // node_modules/d3-shape/src/symbol/square2.js
  var square2_default = {
    draw(context, size2) {
      const r = sqrt3(size2) * 0.4431;
      context.moveTo(r, r);
      context.lineTo(r, -r);
      context.lineTo(-r, -r);
      context.lineTo(-r, r);
      context.closePath();
    }
  };

  // node_modules/d3-shape/src/symbol/star.js
  var ka = 0.8908130915292852;
  var kr = sin3(pi5 / 10) / sin3(7 * pi5 / 10);
  var kx = sin3(tau6 / 10) * kr;
  var ky = -cos3(tau6 / 10) * kr;
  var star_default = {
    draw(context, size2) {
      const r = sqrt3(size2 * ka);
      const x5 = kx * r;
      const y5 = ky * r;
      context.moveTo(0, -r);
      context.lineTo(x5, y5);
      for (let i = 1; i < 5; ++i) {
        const a4 = tau6 * i / 5;
        const c6 = cos3(a4);
        const s2 = sin3(a4);
        context.lineTo(s2 * r, -c6 * r);
        context.lineTo(c6 * x5 - s2 * y5, s2 * x5 + c6 * y5);
      }
      context.closePath();
    }
  };

  // node_modules/d3-shape/src/symbol/triangle.js
  var sqrt33 = sqrt3(3);
  var triangle_default = {
    draw(context, size2) {
      const y5 = -sqrt3(size2 / (sqrt33 * 3));
      context.moveTo(0, y5 * 2);
      context.lineTo(-sqrt33 * y5, -y5);
      context.lineTo(sqrt33 * y5, -y5);
      context.closePath();
    }
  };

  // node_modules/d3-shape/src/symbol/triangle2.js
  var sqrt34 = sqrt3(3);
  var triangle2_default = {
    draw(context, size2) {
      const s2 = sqrt3(size2) * 0.6824;
      const t = s2 / 2;
      const u5 = s2 * sqrt34 / 2;
      context.moveTo(0, -s2);
      context.lineTo(u5, t);
      context.lineTo(-u5, t);
      context.closePath();
    }
  };

  // node_modules/d3-shape/src/symbol/wye.js
  var c5 = -0.5;
  var s = sqrt3(3) / 2;
  var k = 1 / sqrt3(12);
  var a3 = (k / 2 + 1) * 3;
  var wye_default = {
    draw(context, size2) {
      const r = sqrt3(size2 / a3);
      const x06 = r / 2, y06 = r * k;
      const x12 = x06, y12 = r * k + r;
      const x22 = -x12, y22 = y12;
      context.moveTo(x06, y06);
      context.lineTo(x12, y12);
      context.lineTo(x22, y22);
      context.lineTo(c5 * x06 - s * y06, s * x06 + c5 * y06);
      context.lineTo(c5 * x12 - s * y12, s * x12 + c5 * y12);
      context.lineTo(c5 * x22 - s * y22, s * x22 + c5 * y22);
      context.lineTo(c5 * x06 + s * y06, c5 * y06 - s * x06);
      context.lineTo(c5 * x12 + s * y12, c5 * y12 - s * x12);
      context.lineTo(c5 * x22 + s * y22, c5 * y22 - s * x22);
      context.closePath();
    }
  };

  // node_modules/d3-shape/src/symbol/times.js
  var times_default = {
    draw(context, size2) {
      const r = sqrt3(size2 - min3(size2 / 6, 1.7)) * 0.6189;
      context.moveTo(-r, -r);
      context.lineTo(r, r);
      context.moveTo(-r, r);
      context.lineTo(r, -r);
    }
  };

  // node_modules/d3-shape/src/symbol.js
  var symbolsFill = [
    circle_default3,
    cross_default2,
    diamond_default,
    square_default,
    star_default,
    triangle_default,
    wye_default
  ];
  var symbolsStroke = [
    circle_default3,
    plus_default,
    times_default,
    triangle2_default,
    asterisk_default,
    square2_default,
    diamond2_default
  ];
  function Symbol2(type2, size2) {
    let context = null, path2 = withPath(symbol);
    type2 = typeof type2 === "function" ? type2 : constant_default10(type2 || circle_default3);
    size2 = typeof size2 === "function" ? size2 : constant_default10(size2 === void 0 ? 64 : +size2);
    function symbol() {
      let buffer;
      if (!context) context = buffer = path2();
      type2.apply(this, arguments).draw(context, +size2.apply(this, arguments));
      if (buffer) return context = null, buffer + "" || null;
    }
    symbol.type = function(_25) {
      return arguments.length ? (type2 = typeof _25 === "function" ? _25 : constant_default10(_25), symbol) : type2;
    };
    symbol.size = function(_25) {
      return arguments.length ? (size2 = typeof _25 === "function" ? _25 : constant_default10(+_25), symbol) : size2;
    };
    symbol.context = function(_25) {
      return arguments.length ? (context = _25 == null ? null : _25, symbol) : context;
    };
    return symbol;
  }

  // node_modules/d3-shape/src/noop.js
  function noop_default2() {
  }

  // node_modules/d3-shape/src/curve/basis.js
  function point2(that, x5, y5) {
    that._context.bezierCurveTo(
      (2 * that._x0 + that._x1) / 3,
      (2 * that._y0 + that._y1) / 3,
      (that._x0 + 2 * that._x1) / 3,
      (that._y0 + 2 * that._y1) / 3,
      (that._x0 + 4 * that._x1 + x5) / 6,
      (that._y0 + 4 * that._y1 + y5) / 6
    );
  }
  function Basis(context) {
    this._context = context;
  }
  Basis.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 3:
          point2(this, this._x1, this._y1);
        // falls through
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x5, y5) {
      x5 = +x5, y5 = +y5;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
        // falls through
        default:
          point2(this, x5, y5);
          break;
      }
      this._x0 = this._x1, this._x1 = x5;
      this._y0 = this._y1, this._y1 = y5;
    }
  };
  function basis_default2(context) {
    return new Basis(context);
  }

  // node_modules/d3-shape/src/curve/basisClosed.js
  function BasisClosed(context) {
    this._context = context;
  }
  BasisClosed.prototype = {
    areaStart: noop_default2,
    areaEnd: noop_default2,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x2, this._y2);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
      }
    },
    point: function(x5, y5) {
      x5 = +x5, y5 = +y5;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x2 = x5, this._y2 = y5;
          break;
        case 1:
          this._point = 2;
          this._x3 = x5, this._y3 = y5;
          break;
        case 2:
          this._point = 3;
          this._x4 = x5, this._y4 = y5;
          this._context.moveTo((this._x0 + 4 * this._x1 + x5) / 6, (this._y0 + 4 * this._y1 + y5) / 6);
          break;
        default:
          point2(this, x5, y5);
          break;
      }
      this._x0 = this._x1, this._x1 = x5;
      this._y0 = this._y1, this._y1 = y5;
    }
  };
  function basisClosed_default2(context) {
    return new BasisClosed(context);
  }

  // node_modules/d3-shape/src/curve/basisOpen.js
  function BasisOpen(context) {
    this._context = context;
  }
  BasisOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x5, y5) {
      x5 = +x5, y5 = +y5;
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          var x06 = (this._x0 + 4 * this._x1 + x5) / 6, y06 = (this._y0 + 4 * this._y1 + y5) / 6;
          this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
          break;
        case 3:
          this._point = 4;
        // falls through
        default:
          point2(this, x5, y5);
          break;
      }
      this._x0 = this._x1, this._x1 = x5;
      this._y0 = this._y1, this._y1 = y5;
    }
  };
  function basisOpen_default(context) {
    return new BasisOpen(context);
  }

  // node_modules/d3-shape/src/curve/bundle.js
  function Bundle(context, beta) {
    this._basis = new Basis(context);
    this._beta = beta;
  }
  Bundle.prototype = {
    lineStart: function() {
      this._x = [];
      this._y = [];
      this._basis.lineStart();
    },
    lineEnd: function() {
      var x5 = this._x, y5 = this._y, j2 = x5.length - 1;
      if (j2 > 0) {
        var x06 = x5[0], y06 = y5[0], dx = x5[j2] - x06, dy = y5[j2] - y06, i = -1, t;
        while (++i <= j2) {
          t = i / j2;
          this._basis.point(
            this._beta * x5[i] + (1 - this._beta) * (x06 + t * dx),
            this._beta * y5[i] + (1 - this._beta) * (y06 + t * dy)
          );
        }
      }
      this._x = this._y = null;
      this._basis.lineEnd();
    },
    point: function(x5, y5) {
      this._x.push(+x5);
      this._y.push(+y5);
    }
  };
  var bundle_default = function custom12(beta) {
    function bundle(context) {
      return beta === 1 ? new Basis(context) : new Bundle(context, beta);
    }
    bundle.beta = function(beta2) {
      return custom12(+beta2);
    };
    return bundle;
  }(0.85);

  // node_modules/d3-shape/src/curve/cardinal.js
  function point3(that, x5, y5) {
    that._context.bezierCurveTo(
      that._x1 + that._k * (that._x2 - that._x0),
      that._y1 + that._k * (that._y2 - that._y0),
      that._x2 + that._k * (that._x1 - x5),
      that._y2 + that._k * (that._y1 - y5),
      that._x2,
      that._y2
    );
  }
  function Cardinal(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  Cardinal.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          point3(this, this._x1, this._y1);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x5, y5) {
      x5 = +x5, y5 = +y5;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
          break;
        case 1:
          this._point = 2;
          this._x1 = x5, this._y1 = y5;
          break;
        case 2:
          this._point = 3;
        // falls through
        default:
          point3(this, x5, y5);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
    }
  };
  var cardinal_default = function custom13(tension) {
    function cardinal(context) {
      return new Cardinal(context, tension);
    }
    cardinal.tension = function(tension2) {
      return custom13(+tension2);
    };
    return cardinal;
  }(0);

  // node_modules/d3-shape/src/curve/cardinalClosed.js
  function CardinalClosed(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  CardinalClosed.prototype = {
    areaStart: noop_default2,
    areaEnd: noop_default2,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x5, y5) {
      x5 = +x5, y5 = +y5;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x5, this._y3 = y5;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x5, this._y4 = y5);
          break;
        case 2:
          this._point = 3;
          this._x5 = x5, this._y5 = y5;
          break;
        default:
          point3(this, x5, y5);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
    }
  };
  var cardinalClosed_default = function custom14(tension) {
    function cardinal(context) {
      return new CardinalClosed(context, tension);
    }
    cardinal.tension = function(tension2) {
      return custom14(+tension2);
    };
    return cardinal;
  }(0);

  // node_modules/d3-shape/src/curve/cardinalOpen.js
  function CardinalOpen(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  CardinalOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x5, y5) {
      x5 = +x5, y5 = +y5;
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        // falls through
        default:
          point3(this, x5, y5);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
    }
  };
  var cardinalOpen_default = function custom15(tension) {
    function cardinal(context) {
      return new CardinalOpen(context, tension);
    }
    cardinal.tension = function(tension2) {
      return custom15(+tension2);
    };
    return cardinal;
  }(0);

  // node_modules/d3-shape/src/curve/catmullRom.js
  function point4(that, x5, y5) {
    var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
    if (that._l01_a > epsilon8) {
      var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
      x12 = (x12 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
      y12 = (y12 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
    }
    if (that._l23_a > epsilon8) {
      var b10 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m4 = 3 * that._l23_a * (that._l23_a + that._l12_a);
      x22 = (x22 * b10 + that._x1 * that._l23_2a - x5 * that._l12_2a) / m4;
      y22 = (y22 * b10 + that._y1 * that._l23_2a - y5 * that._l12_2a) / m4;
    }
    that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
  }
  function CatmullRom(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRom.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          this.point(this._x2, this._y2);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x5, y5) {
      x5 = +x5, y5 = +y5;
      if (this._point) {
        var x23 = this._x2 - x5, y23 = this._y2 - y5;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
        // falls through
        default:
          point4(this, x5, y5);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
    }
  };
  var catmullRom_default = function custom16(alpha) {
    function catmullRom(context) {
      return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
    }
    catmullRom.alpha = function(alpha2) {
      return custom16(+alpha2);
    };
    return catmullRom;
  }(0.5);

  // node_modules/d3-shape/src/curve/catmullRomClosed.js
  function CatmullRomClosed(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRomClosed.prototype = {
    areaStart: noop_default2,
    areaEnd: noop_default2,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x5, y5) {
      x5 = +x5, y5 = +y5;
      if (this._point) {
        var x23 = this._x2 - x5, y23 = this._y2 - y5;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x5, this._y3 = y5;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x5, this._y4 = y5);
          break;
        case 2:
          this._point = 3;
          this._x5 = x5, this._y5 = y5;
          break;
        default:
          point4(this, x5, y5);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
    }
  };
  var catmullRomClosed_default = function custom17(alpha) {
    function catmullRom(context) {
      return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
    }
    catmullRom.alpha = function(alpha2) {
      return custom17(+alpha2);
    };
    return catmullRom;
  }(0.5);

  // node_modules/d3-shape/src/curve/catmullRomOpen.js
  function CatmullRomOpen(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRomOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x5, y5) {
      x5 = +x5, y5 = +y5;
      if (this._point) {
        var x23 = this._x2 - x5, y23 = this._y2 - y5;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        // falls through
        default:
          point4(this, x5, y5);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
    }
  };
  var catmullRomOpen_default = function custom18(alpha) {
    function catmullRom(context) {
      return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
    }
    catmullRom.alpha = function(alpha2) {
      return custom18(+alpha2);
    };
    return catmullRom;
  }(0.5);

  // node_modules/d3-shape/src/curve/linearClosed.js
  function LinearClosed(context) {
    this._context = context;
  }
  LinearClosed.prototype = {
    areaStart: noop_default2,
    areaEnd: noop_default2,
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._point) this._context.closePath();
    },
    point: function(x5, y5) {
      x5 = +x5, y5 = +y5;
      if (this._point) this._context.lineTo(x5, y5);
      else this._point = 1, this._context.moveTo(x5, y5);
    }
  };
  function linearClosed_default(context) {
    return new LinearClosed(context);
  }

  // node_modules/d3-shape/src/curve/monotone.js
  function sign2(x5) {
    return x5 < 0 ? -1 : 1;
  }
  function slope3(that, x22, y22) {
    var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
  }
  function slope2(that, t) {
    var h2 = that._x1 - that._x0;
    return h2 ? (3 * (that._y1 - that._y0) / h2 - t) / 2 : t;
  }
  function point5(that, t03, t13) {
    var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;
    that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);
  }
  function MonotoneX(context) {
    this._context = context;
  }
  MonotoneX.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          point5(this, this._t0, slope2(this, this._t0));
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x5, y5) {
      var t13 = NaN;
      x5 = +x5, y5 = +y5;
      if (x5 === this._x1 && y5 === this._y1) return;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          point5(this, slope2(this, t13 = slope3(this, x5, y5)), t13);
          break;
        default:
          point5(this, this._t0, t13 = slope3(this, x5, y5));
          break;
      }
      this._x0 = this._x1, this._x1 = x5;
      this._y0 = this._y1, this._y1 = y5;
      this._t0 = t13;
    }
  };
  function MonotoneY(context) {
    this._context = new ReflectContext(context);
  }
  (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x5, y5) {
    MonotoneX.prototype.point.call(this, y5, x5);
  };
  function ReflectContext(context) {
    this._context = context;
  }
  ReflectContext.prototype = {
    moveTo: function(x5, y5) {
      this._context.moveTo(y5, x5);
    },
    closePath: function() {
      this._context.closePath();
    },
    lineTo: function(x5, y5) {
      this._context.lineTo(y5, x5);
    },
    bezierCurveTo: function(x12, y12, x22, y22, x5, y5) {
      this._context.bezierCurveTo(y12, x12, y22, x22, y5, x5);
    }
  };
  function monotoneX(context) {
    return new MonotoneX(context);
  }
  function monotoneY(context) {
    return new MonotoneY(context);
  }

  // node_modules/d3-shape/src/curve/natural.js
  function Natural(context) {
    this._context = context;
  }
  Natural.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = [];
      this._y = [];
    },
    lineEnd: function() {
      var x5 = this._x, y5 = this._y, n = x5.length;
      if (n) {
        this._line ? this._context.lineTo(x5[0], y5[0]) : this._context.moveTo(x5[0], y5[0]);
        if (n === 2) {
          this._context.lineTo(x5[1], y5[1]);
        } else {
          var px = controlPoints(x5), py = controlPoints(y5);
          for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
            this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x5[i1], y5[i1]);
          }
        }
      }
      if (this._line || this._line !== 0 && n === 1) this._context.closePath();
      this._line = 1 - this._line;
      this._x = this._y = null;
    },
    point: function(x5, y5) {
      this._x.push(+x5);
      this._y.push(+y5);
    }
  };
  function controlPoints(x5) {
    var i, n = x5.length - 1, m4, a4 = new Array(n), b10 = new Array(n), r = new Array(n);
    a4[0] = 0, b10[0] = 2, r[0] = x5[0] + 2 * x5[1];
    for (i = 1; i < n - 1; ++i) a4[i] = 1, b10[i] = 4, r[i] = 4 * x5[i] + 2 * x5[i + 1];
    a4[n - 1] = 2, b10[n - 1] = 7, r[n - 1] = 8 * x5[n - 1] + x5[n];
    for (i = 1; i < n; ++i) m4 = a4[i] / b10[i - 1], b10[i] -= m4, r[i] -= m4 * r[i - 1];
    a4[n - 1] = r[n - 1] / b10[n - 1];
    for (i = n - 2; i >= 0; --i) a4[i] = (r[i] - a4[i + 1]) / b10[i];
    b10[n - 1] = (x5[n] + a4[n - 1]) / 2;
    for (i = 0; i < n - 1; ++i) b10[i] = 2 * x5[i + 1] - a4[i + 1];
    return [a4, b10];
  }
  function natural_default(context) {
    return new Natural(context);
  }

  // node_modules/d3-shape/src/curve/step.js
  function Step(context, t) {
    this._context = context;
    this._t = t;
  }
  Step.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = this._y = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point: function(x5, y5) {
      x5 = +x5, y5 = +y5;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
          break;
        case 1:
          this._point = 2;
        // falls through
        default: {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y5);
            this._context.lineTo(x5, y5);
          } else {
            var x12 = this._x * (1 - this._t) + x5 * this._t;
            this._context.lineTo(x12, this._y);
            this._context.lineTo(x12, y5);
          }
          break;
        }
      }
      this._x = x5, this._y = y5;
    }
  };
  function step_default(context) {
    return new Step(context, 0.5);
  }
  function stepBefore(context) {
    return new Step(context, 0);
  }
  function stepAfter(context) {
    return new Step(context, 1);
  }

  // node_modules/d3-shape/src/offset/none.js
  function none_default(series, order) {
    if (!((n = series.length) > 1)) return;
    for (var i = 1, j2, s0, s1 = series[order[0]], n, m4 = s1.length; i < n; ++i) {
      s0 = s1, s1 = series[order[i]];
      for (j2 = 0; j2 < m4; ++j2) {
        s1[j2][1] += s1[j2][0] = isNaN(s0[j2][1]) ? s0[j2][0] : s0[j2][1];
      }
    }
  }

  // node_modules/d3-shape/src/order/none.js
  function none_default2(series) {
    var n = series.length, o = new Array(n);
    while (--n >= 0) o[n] = n;
    return o;
  }

  // node_modules/d3-shape/src/stack.js
  function stackValue(d, key) {
    return d[key];
  }
  function stackSeries(key) {
    const series = [];
    series.key = key;
    return series;
  }
  function stack_default() {
    var keys = constant_default10([]), order = none_default2, offset = none_default, value = stackValue;
    function stack2(data2) {
      var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j2 = -1, oz;
      for (const d of data2) {
        for (i = 0, ++j2; i < n; ++i) {
          (sz[i][j2] = [0, +value(d, sz[i].key, j2, data2)]).data = d;
        }
      }
      for (i = 0, oz = array_default3(order(sz)); i < n; ++i) {
        sz[oz[i]].index = i;
      }
      offset(sz, oz);
      return sz;
    }
    stack2.keys = function(_25) {
      return arguments.length ? (keys = typeof _25 === "function" ? _25 : constant_default10(Array.from(_25)), stack2) : keys;
    };
    stack2.value = function(_25) {
      return arguments.length ? (value = typeof _25 === "function" ? _25 : constant_default10(+_25), stack2) : value;
    };
    stack2.order = function(_25) {
      return arguments.length ? (order = _25 == null ? none_default2 : typeof _25 === "function" ? _25 : constant_default10(Array.from(_25)), stack2) : order;
    };
    stack2.offset = function(_25) {
      return arguments.length ? (offset = _25 == null ? none_default : _25, stack2) : offset;
    };
    return stack2;
  }

  // node_modules/d3-shape/src/offset/expand.js
  function expand_default(series, order) {
    if (!((n = series.length) > 0)) return;
    for (var i, n, j2 = 0, m4 = series[0].length, y5; j2 < m4; ++j2) {
      for (y5 = i = 0; i < n; ++i) y5 += series[i][j2][1] || 0;
      if (y5) for (i = 0; i < n; ++i) series[i][j2][1] /= y5;
    }
    none_default(series, order);
  }

  // node_modules/d3-shape/src/offset/diverging.js
  function diverging_default(series, order) {
    if (!((n = series.length) > 0)) return;
    for (var i, j2 = 0, d, dy, yp, yn, n, m4 = series[order[0]].length; j2 < m4; ++j2) {
      for (yp = yn = 0, i = 0; i < n; ++i) {
        if ((dy = (d = series[order[i]][j2])[1] - d[0]) > 0) {
          d[0] = yp, d[1] = yp += dy;
        } else if (dy < 0) {
          d[1] = yn, d[0] = yn += dy;
        } else {
          d[0] = 0, d[1] = dy;
        }
      }
    }
  }

  // node_modules/d3-shape/src/offset/silhouette.js
  function silhouette_default(series, order) {
    if (!((n = series.length) > 0)) return;
    for (var j2 = 0, s0 = series[order[0]], n, m4 = s0.length; j2 < m4; ++j2) {
      for (var i = 0, y5 = 0; i < n; ++i) y5 += series[i][j2][1] || 0;
      s0[j2][1] += s0[j2][0] = -y5 / 2;
    }
    none_default(series, order);
  }

  // node_modules/d3-shape/src/offset/wiggle.js
  function wiggle_default(series, order) {
    if (!((n = series.length) > 0) || !((m4 = (s0 = series[order[0]]).length) > 0)) return;
    for (var y5 = 0, j2 = 1, s0, m4, n; j2 < m4; ++j2) {
      for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
        var si = series[order[i]], sij0 = si[j2][1] || 0, sij1 = si[j2 - 1][1] || 0, s3 = (sij0 - sij1) / 2;
        for (var k3 = 0; k3 < i; ++k3) {
          var sk = series[order[k3]], skj0 = sk[j2][1] || 0, skj1 = sk[j2 - 1][1] || 0;
          s3 += skj0 - skj1;
        }
        s1 += sij0, s2 += s3 * sij0;
      }
      s0[j2 - 1][1] += s0[j2 - 1][0] = y5;
      if (s1) y5 -= s2 / s1;
    }
    s0[j2 - 1][1] += s0[j2 - 1][0] = y5;
    none_default(series, order);
  }

  // node_modules/d3-shape/src/order/appearance.js
  function appearance_default(series) {
    var peaks = series.map(peak);
    return none_default2(series).sort(function(a4, b10) {
      return peaks[a4] - peaks[b10];
    });
  }
  function peak(series) {
    var i = -1, j2 = 0, n = series.length, vi, vj = -Infinity;
    while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j2 = i;
    return j2;
  }

  // node_modules/d3-shape/src/order/ascending.js
  function ascending_default2(series) {
    var sums = series.map(sum3);
    return none_default2(series).sort(function(a4, b10) {
      return sums[a4] - sums[b10];
    });
  }
  function sum3(series) {
    var s2 = 0, i = -1, n = series.length, v3;
    while (++i < n) if (v3 = +series[i][1]) s2 += v3;
    return s2;
  }

  // node_modules/d3-shape/src/order/descending.js
  function descending_default2(series) {
    return ascending_default2(series).reverse();
  }

  // node_modules/d3-shape/src/order/insideOut.js
  function insideOut_default(series) {
    var n = series.length, i, j2, sums = series.map(sum3), order = appearance_default(series), top2 = 0, bottom2 = 0, tops = [], bottoms = [];
    for (i = 0; i < n; ++i) {
      j2 = order[i];
      if (top2 < bottom2) {
        top2 += sums[j2];
        tops.push(j2);
      } else {
        bottom2 += sums[j2];
        bottoms.push(j2);
      }
    }
    return bottoms.reverse().concat(tops);
  }

  // node_modules/d3-shape/src/order/reverse.js
  function reverse_default(series) {
    return none_default2(series).reverse();
  }

  // node_modules/d3-zoom/src/constant.js
  var constant_default11 = (x5) => () => x5;

  // node_modules/d3-zoom/src/event.js
  function ZoomEvent(type2, {
    sourceEvent,
    target,
    transform: transform2,
    dispatch: dispatch2
  }) {
    Object.defineProperties(this, {
      type: { value: type2, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      transform: { value: transform2, enumerable: true, configurable: true },
      _: { value: dispatch2 }
    });
  }

  // node_modules/d3-zoom/src/transform.js
  function Transform(k3, x5, y5) {
    this.k = k3;
    this.x = x5;
    this.y = y5;
  }
  Transform.prototype = {
    constructor: Transform,
    scale: function(k3) {
      return k3 === 1 ? this : new Transform(this.k * k3, this.x, this.y);
    },
    translate: function(x5, y5) {
      return x5 === 0 & y5 === 0 ? this : new Transform(this.k, this.x + this.k * x5, this.y + this.k * y5);
    },
    apply: function(point6) {
      return [point6[0] * this.k + this.x, point6[1] * this.k + this.y];
    },
    applyX: function(x5) {
      return x5 * this.k + this.x;
    },
    applyY: function(y5) {
      return y5 * this.k + this.y;
    },
    invert: function(location) {
      return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function(x5) {
      return (x5 - this.x) / this.k;
    },
    invertY: function(y5) {
      return (y5 - this.y) / this.k;
    },
    rescaleX: function(x5) {
      return x5.copy().domain(x5.range().map(this.invertX, this).map(x5.invert, x5));
    },
    rescaleY: function(y5) {
      return y5.copy().domain(y5.range().map(this.invertY, this).map(y5.invert, y5));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var identity5 = new Transform(1, 0, 0);
  transform.prototype = Transform.prototype;
  function transform(node) {
    while (!node.__zoom) if (!(node = node.parentNode)) return identity5;
    return node.__zoom;
  }

  // node_modules/d3-zoom/src/noevent.js
  function nopropagation3(event2) {
    event2.stopImmediatePropagation();
  }
  function noevent_default3(event2) {
    event2.preventDefault();
    event2.stopImmediatePropagation();
  }

  // node_modules/d3-zoom/src/zoom.js
  function defaultFilter3(event2) {
    return (!event2.ctrlKey || event2.type === "wheel") && !event2.button;
  }
  function defaultExtent2() {
    var e = this;
    if (e instanceof SVGElement) {
      e = e.ownerSVGElement || e;
      if (e.hasAttribute("viewBox")) {
        e = e.viewBox.baseVal;
        return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
      }
      return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
    }
    return [[0, 0], [e.clientWidth, e.clientHeight]];
  }
  function defaultTransform() {
    return this.__zoom || identity5;
  }
  function defaultWheelDelta(event2) {
    return -event2.deltaY * (event2.deltaMode === 1 ? 0.05 : event2.deltaMode ? 1 : 2e-3) * (event2.ctrlKey ? 10 : 1);
  }
  function defaultTouchable3() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function defaultConstrain(transform2, extent2, translateExtent) {
    var dx0 = transform2.invertX(extent2[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent2[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent2[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent2[1][1]) - translateExtent[1][1];
    return transform2.translate(
      dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
      dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
    );
  }
  function zoom_default2() {
    var filter3 = defaultFilter3, extent2 = defaultExtent2, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable3, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
    function zoom(selection2) {
      selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    zoom.transform = function(collection, transform2, point6, event2) {
      var selection2 = collection.selection ? collection.selection() : collection;
      selection2.property("__zoom", defaultTransform);
      if (collection !== selection2) {
        schedule(collection, transform2, point6, event2);
      } else {
        selection2.interrupt().each(function() {
          gesture(this, arguments).event(event2).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
        });
      }
    };
    zoom.scaleBy = function(selection2, k3, p, event2) {
      zoom.scaleTo(selection2, function() {
        var k0 = this.__zoom.k, k1 = typeof k3 === "function" ? k3.apply(this, arguments) : k3;
        return k0 * k1;
      }, p, event2);
    };
    zoom.scaleTo = function(selection2, k3, p, event2) {
      zoom.transform(selection2, function() {
        var e = extent2.apply(this, arguments), t03 = this.__zoom, p02 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t03.invert(p02), k1 = typeof k3 === "function" ? k3.apply(this, arguments) : k3;
        return constrain(translate(scale2(t03, k1), p02, p1), e, translateExtent);
      }, p, event2);
    };
    zoom.translateBy = function(selection2, x5, y5, event2) {
      zoom.transform(selection2, function() {
        return constrain(this.__zoom.translate(
          typeof x5 === "function" ? x5.apply(this, arguments) : x5,
          typeof y5 === "function" ? y5.apply(this, arguments) : y5
        ), extent2.apply(this, arguments), translateExtent);
      }, null, event2);
    };
    zoom.translateTo = function(selection2, x5, y5, p, event2) {
      zoom.transform(selection2, function() {
        var e = extent2.apply(this, arguments), t = this.__zoom, p02 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
        return constrain(identity5.translate(p02[0], p02[1]).scale(t.k).translate(
          typeof x5 === "function" ? -x5.apply(this, arguments) : -x5,
          typeof y5 === "function" ? -y5.apply(this, arguments) : -y5
        ), e, translateExtent);
      }, p, event2);
    };
    function scale2(transform2, k3) {
      k3 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k3));
      return k3 === transform2.k ? transform2 : new Transform(k3, transform2.x, transform2.y);
    }
    function translate(transform2, p02, p1) {
      var x5 = p02[0] - p1[0] * transform2.k, y5 = p02[1] - p1[1] * transform2.k;
      return x5 === transform2.x && y5 === transform2.y ? transform2 : new Transform(transform2.k, x5, y5);
    }
    function centroid(extent3) {
      return [(+extent3[0][0] + +extent3[1][0]) / 2, (+extent3[0][1] + +extent3[1][1]) / 2];
    }
    function schedule(transition3, transform2, point6, event2) {
      transition3.on("start.zoom", function() {
        gesture(this, arguments).event(event2).start();
      }).on("interrupt.zoom end.zoom", function() {
        gesture(this, arguments).event(event2).end();
      }).tween("zoom", function() {
        var that = this, args = arguments, g = gesture(that, args).event(event2), e = extent2.apply(that, args), p = point6 == null ? centroid(e) : typeof point6 === "function" ? point6.apply(that, args) : point6, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a4 = that.__zoom, b10 = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a4.invert(p).concat(w / a4.k), b10.invert(p).concat(w / b10.k));
        return function(t) {
          if (t === 1) t = b10;
          else {
            var l2 = i(t), k3 = w / l2[2];
            t = new Transform(k3, p[0] - l2[0] * k3, p[1] - l2[1] * k3);
          }
          g.zoom(null, t);
        };
      });
    }
    function gesture(that, args, clean) {
      return !clean && that.__zooming || new Gesture(that, args);
    }
    function Gesture(that, args) {
      this.that = that;
      this.args = args;
      this.active = 0;
      this.sourceEvent = null;
      this.extent = extent2.apply(that, args);
      this.taps = 0;
    }
    Gesture.prototype = {
      event: function(event2) {
        if (event2) this.sourceEvent = event2;
        return this;
      },
      start: function() {
        if (++this.active === 1) {
          this.that.__zooming = this;
          this.emit("start");
        }
        return this;
      },
      zoom: function(key, transform2) {
        if (this.mouse && key !== "mouse") this.mouse[1] = transform2.invert(this.mouse[0]);
        if (this.touch0 && key !== "touch") this.touch0[1] = transform2.invert(this.touch0[0]);
        if (this.touch1 && key !== "touch") this.touch1[1] = transform2.invert(this.touch1[0]);
        this.that.__zoom = transform2;
        this.emit("zoom");
        return this;
      },
      end: function() {
        if (--this.active === 0) {
          delete this.that.__zooming;
          this.emit("end");
        }
        return this;
      },
      emit: function(type2) {
        var d = select_default2(this.that).datum();
        listeners.call(
          type2,
          this.that,
          new ZoomEvent(type2, {
            sourceEvent: this.sourceEvent,
            target: zoom,
            type: type2,
            transform: this.that.__zoom,
            dispatch: listeners
          }),
          d
        );
      }
    };
    function wheeled(event2, ...args) {
      if (!filter3.apply(this, arguments)) return;
      var g = gesture(this, args).event(event2), t = this.__zoom, k3 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer_default(event2);
      if (g.wheel) {
        if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
          g.mouse[1] = t.invert(g.mouse[0] = p);
        }
        clearTimeout(g.wheel);
      } else if (t.k === k3) return;
      else {
        g.mouse = [p, t.invert(p)];
        interrupt_default(this);
        g.start();
      }
      noevent_default3(event2);
      g.wheel = setTimeout(wheelidled, wheelDelay);
      g.zoom("mouse", constrain(translate(scale2(t, k3), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
      function wheelidled() {
        g.wheel = null;
        g.end();
      }
    }
    function mousedowned(event2, ...args) {
      if (touchending || !filter3.apply(this, arguments)) return;
      var currentTarget = event2.currentTarget, g = gesture(this, args, true).event(event2), v3 = select_default2(event2.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event2, currentTarget), x06 = event2.clientX, y06 = event2.clientY;
      nodrag_default(event2.view);
      nopropagation3(event2);
      g.mouse = [p, this.__zoom.invert(p)];
      interrupt_default(this);
      g.start();
      function mousemoved(event3) {
        noevent_default3(event3);
        if (!g.moved) {
          var dx = event3.clientX - x06, dy = event3.clientY - y06;
          g.moved = dx * dx + dy * dy > clickDistance2;
        }
        g.event(event3).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event3, currentTarget), g.mouse[1]), g.extent, translateExtent));
      }
      function mouseupped(event3) {
        v3.on("mousemove.zoom mouseup.zoom", null);
        yesdrag(event3.view, g.moved);
        noevent_default3(event3);
        g.event(event3).end();
      }
    }
    function dblclicked(event2, ...args) {
      if (!filter3.apply(this, arguments)) return;
      var t03 = this.__zoom, p02 = pointer_default(event2.changedTouches ? event2.changedTouches[0] : event2, this), p1 = t03.invert(p02), k1 = t03.k * (event2.shiftKey ? 0.5 : 2), t13 = constrain(translate(scale2(t03, k1), p02, p1), extent2.apply(this, args), translateExtent);
      noevent_default3(event2);
      if (duration > 0) select_default2(this).transition().duration(duration).call(schedule, t13, p02, event2);
      else select_default2(this).call(zoom.transform, t13, p02, event2);
    }
    function touchstarted(event2, ...args) {
      if (!filter3.apply(this, arguments)) return;
      var touches = event2.touches, n = touches.length, g = gesture(this, args, event2.changedTouches.length === n).event(event2), started, i, t, p;
      nopropagation3(event2);
      for (i = 0; i < n; ++i) {
        t = touches[i], p = pointer_default(t, this);
        p = [p, this.__zoom.invert(p), t.identifier];
        if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
        else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
      }
      if (touchstarting) touchstarting = clearTimeout(touchstarting);
      if (started) {
        if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
        interrupt_default(this);
        g.start();
      }
    }
    function touchmoved(event2, ...args) {
      if (!this.__zooming) return;
      var g = gesture(this, args).event(event2), touches = event2.changedTouches, n = touches.length, i, t, p, l2;
      noevent_default3(event2);
      for (i = 0; i < n; ++i) {
        t = touches[i], p = pointer_default(t, this);
        if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
        else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
      }
      t = g.that.__zoom;
      if (g.touch1) {
        var p02 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p02[0]) * dp + (dp = p1[1] - p02[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t = scale2(t, Math.sqrt(dp / dl));
        p = [(p02[0] + p1[0]) / 2, (p02[1] + p1[1]) / 2];
        l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      } else if (g.touch0) p = g.touch0[0], l2 = g.touch0[1];
      else return;
      g.zoom("touch", constrain(translate(t, p, l2), g.extent, translateExtent));
    }
    function touchended(event2, ...args) {
      if (!this.__zooming) return;
      var g = gesture(this, args).event(event2), touches = event2.changedTouches, n = touches.length, i, t;
      nopropagation3(event2);
      if (touchending) clearTimeout(touchending);
      touchending = setTimeout(function() {
        touchending = null;
      }, touchDelay);
      for (i = 0; i < n; ++i) {
        t = touches[i];
        if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
        else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
      }
      if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
      if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
      else {
        g.end();
        if (g.taps === 2) {
          t = pointer_default(t, this);
          if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
            var p = select_default2(this).on("dblclick.zoom");
            if (p) p.apply(this, arguments);
          }
        }
      }
    }
    zoom.wheelDelta = function(_25) {
      return arguments.length ? (wheelDelta = typeof _25 === "function" ? _25 : constant_default11(+_25), zoom) : wheelDelta;
    };
    zoom.filter = function(_25) {
      return arguments.length ? (filter3 = typeof _25 === "function" ? _25 : constant_default11(!!_25), zoom) : filter3;
    };
    zoom.touchable = function(_25) {
      return arguments.length ? (touchable = typeof _25 === "function" ? _25 : constant_default11(!!_25), zoom) : touchable;
    };
    zoom.extent = function(_25) {
      return arguments.length ? (extent2 = typeof _25 === "function" ? _25 : constant_default11([[+_25[0][0], +_25[0][1]], [+_25[1][0], +_25[1][1]]]), zoom) : extent2;
    };
    zoom.scaleExtent = function(_25) {
      return arguments.length ? (scaleExtent[0] = +_25[0], scaleExtent[1] = +_25[1], zoom) : [scaleExtent[0], scaleExtent[1]];
    };
    zoom.translateExtent = function(_25) {
      return arguments.length ? (translateExtent[0][0] = +_25[0][0], translateExtent[1][0] = +_25[1][0], translateExtent[0][1] = +_25[0][1], translateExtent[1][1] = +_25[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
    };
    zoom.constrain = function(_25) {
      return arguments.length ? (constrain = _25, zoom) : constrain;
    };
    zoom.duration = function(_25) {
      return arguments.length ? (duration = +_25, zoom) : duration;
    };
    zoom.interpolate = function(_25) {
      return arguments.length ? (interpolate = _25, zoom) : interpolate;
    };
    zoom.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? zoom : value;
    };
    zoom.clickDistance = function(_25) {
      return arguments.length ? (clickDistance2 = (_25 = +_25) * _25, zoom) : Math.sqrt(clickDistance2);
    };
    zoom.tapDistance = function(_25) {
      return arguments.length ? (tapDistance = +_25, zoom) : tapDistance;
    };
    return zoom;
  }

  // src/ts/bar.ts
  var import_lodash2 = __toESM(require_lodash());

  // src/ts/barHelpers.ts
  var import_lodash = __toESM(require_lodash());

  // node_modules/@fluent/bundle/esm/types.js
  var FluentType = class {
    /**
     * Create a `FluentType` instance.
     *
     * @param value The JavaScript value to wrap.
     */
    constructor(value) {
      this.value = value;
    }
    /**
     * Unwrap the raw value stored by this `FluentType`.
     */
    valueOf() {
      return this.value;
    }
  };
  var FluentNone = class extends FluentType {
    /**
     * Create an instance of `FluentNone` with an optional fallback value.
     * @param value The fallback value of this `FluentNone`.
     */
    constructor(value = "???") {
      super(value);
    }
    /**
     * Format this `FluentNone` to the fallback string.
     */
    toString(scope) {
      return `{${this.value}}`;
    }
  };
  var FluentNumber = class extends FluentType {
    /**
     * Create an instance of `FluentNumber` with options to the
     * `Intl.NumberFormat` constructor.
     *
     * @param value The number value of this `FluentNumber`.
     * @param opts Options which will be passed to `Intl.NumberFormat`.
     */
    constructor(value, opts = {}) {
      super(value);
      this.opts = opts;
    }
    /**
     * Format this `FluentNumber` to a string.
     */
    toString(scope) {
      try {
        const nf = scope.memoizeIntlObject(Intl.NumberFormat, this.opts);
        return nf.format(this.value);
      } catch (err) {
        scope.reportError(err);
        return this.value.toString(10);
      }
    }
  };
  var FluentDateTime = class extends FluentType {
    /**
     * Create an instance of `FluentDateTime` with options to the
     * `Intl.DateTimeFormat` constructor.
     *
     * @param value The number value of this `FluentDateTime`, in milliseconds.
     * @param opts Options which will be passed to `Intl.DateTimeFormat`.
     */
    constructor(value, opts = {}) {
      super(value);
      this.opts = opts;
    }
    /**
     * Format this `FluentDateTime` to a string.
     */
    toString(scope) {
      try {
        const dtf = scope.memoizeIntlObject(Intl.DateTimeFormat, this.opts);
        return dtf.format(this.value);
      } catch (err) {
        scope.reportError(err);
        return new Date(this.value).toISOString();
      }
    }
  };

  // node_modules/@fluent/bundle/esm/resolver.js
  var MAX_PLACEABLES = 100;
  var FSI = "\u2068";
  var PDI = "\u2069";
  function match(scope, selector, key) {
    if (key === selector) {
      return true;
    }
    if (key instanceof FluentNumber && selector instanceof FluentNumber && key.value === selector.value) {
      return true;
    }
    if (selector instanceof FluentNumber && typeof key === "string") {
      let category = scope.memoizeIntlObject(Intl.PluralRules, selector.opts).select(selector.value);
      if (key === category) {
        return true;
      }
    }
    return false;
  }
  function getDefault(scope, variants, star) {
    if (variants[star]) {
      return resolvePattern(scope, variants[star].value);
    }
    scope.reportError(new RangeError("No default"));
    return new FluentNone();
  }
  function getArguments(scope, args) {
    const positional = [];
    const named2 = /* @__PURE__ */ Object.create(null);
    for (const arg of args) {
      if (arg.type === "narg") {
        named2[arg.name] = resolveExpression(scope, arg.value);
      } else {
        positional.push(resolveExpression(scope, arg));
      }
    }
    return { positional, named: named2 };
  }
  function resolveExpression(scope, expr) {
    switch (expr.type) {
      case "str":
        return expr.value;
      case "num":
        return new FluentNumber(expr.value, {
          minimumFractionDigits: expr.precision
        });
      case "var":
        return resolveVariableReference(scope, expr);
      case "mesg":
        return resolveMessageReference(scope, expr);
      case "term":
        return resolveTermReference(scope, expr);
      case "func":
        return resolveFunctionReference(scope, expr);
      case "select":
        return resolveSelectExpression(scope, expr);
      default:
        return new FluentNone();
    }
  }
  function resolveVariableReference(scope, { name }) {
    let arg;
    if (scope.params) {
      if (Object.prototype.hasOwnProperty.call(scope.params, name)) {
        arg = scope.params[name];
      } else {
        return new FluentNone(`$${name}`);
      }
    } else if (scope.args && Object.prototype.hasOwnProperty.call(scope.args, name)) {
      arg = scope.args[name];
    } else {
      scope.reportError(new ReferenceError(`Unknown variable: $${name}`));
      return new FluentNone(`$${name}`);
    }
    if (arg instanceof FluentType) {
      return arg;
    }
    switch (typeof arg) {
      case "string":
        return arg;
      case "number":
        return new FluentNumber(arg);
      case "object":
        if (arg instanceof Date) {
          return new FluentDateTime(arg.getTime());
        }
      // eslint-disable-next-line no-fallthrough
      default:
        scope.reportError(new TypeError(`Variable type not supported: $${name}, ${typeof arg}`));
        return new FluentNone(`$${name}`);
    }
  }
  function resolveMessageReference(scope, { name, attr: attr2 }) {
    const message = scope.bundle._messages.get(name);
    if (!message) {
      scope.reportError(new ReferenceError(`Unknown message: ${name}`));
      return new FluentNone(name);
    }
    if (attr2) {
      const attribute = message.attributes[attr2];
      if (attribute) {
        return resolvePattern(scope, attribute);
      }
      scope.reportError(new ReferenceError(`Unknown attribute: ${attr2}`));
      return new FluentNone(`${name}.${attr2}`);
    }
    if (message.value) {
      return resolvePattern(scope, message.value);
    }
    scope.reportError(new ReferenceError(`No value: ${name}`));
    return new FluentNone(name);
  }
  function resolveTermReference(scope, { name, attr: attr2, args }) {
    const id2 = `-${name}`;
    const term = scope.bundle._terms.get(id2);
    if (!term) {
      scope.reportError(new ReferenceError(`Unknown term: ${id2}`));
      return new FluentNone(id2);
    }
    if (attr2) {
      const attribute = term.attributes[attr2];
      if (attribute) {
        scope.params = getArguments(scope, args).named;
        const resolved2 = resolvePattern(scope, attribute);
        scope.params = null;
        return resolved2;
      }
      scope.reportError(new ReferenceError(`Unknown attribute: ${attr2}`));
      return new FluentNone(`${id2}.${attr2}`);
    }
    scope.params = getArguments(scope, args).named;
    const resolved = resolvePattern(scope, term.value);
    scope.params = null;
    return resolved;
  }
  function resolveFunctionReference(scope, { name, args }) {
    let func = scope.bundle._functions[name];
    if (!func) {
      scope.reportError(new ReferenceError(`Unknown function: ${name}()`));
      return new FluentNone(`${name}()`);
    }
    if (typeof func !== "function") {
      scope.reportError(new TypeError(`Function ${name}() is not callable`));
      return new FluentNone(`${name}()`);
    }
    try {
      let resolved = getArguments(scope, args);
      return func(resolved.positional, resolved.named);
    } catch (err) {
      scope.reportError(err);
      return new FluentNone(`${name}()`);
    }
  }
  function resolveSelectExpression(scope, { selector, variants, star }) {
    let sel = resolveExpression(scope, selector);
    if (sel instanceof FluentNone) {
      return getDefault(scope, variants, star);
    }
    for (const variant of variants) {
      const key = resolveExpression(scope, variant.key);
      if (match(scope, sel, key)) {
        return resolvePattern(scope, variant.value);
      }
    }
    return getDefault(scope, variants, star);
  }
  function resolveComplexPattern(scope, ptn) {
    if (scope.dirty.has(ptn)) {
      scope.reportError(new RangeError("Cyclic reference"));
      return new FluentNone();
    }
    scope.dirty.add(ptn);
    const result = [];
    const useIsolating = scope.bundle._useIsolating && ptn.length > 1;
    for (const elem of ptn) {
      if (typeof elem === "string") {
        result.push(scope.bundle._transform(elem));
        continue;
      }
      scope.placeables++;
      if (scope.placeables > MAX_PLACEABLES) {
        scope.dirty.delete(ptn);
        throw new RangeError(`Too many placeables expanded: ${scope.placeables}, max allowed is ${MAX_PLACEABLES}`);
      }
      if (useIsolating) {
        result.push(FSI);
      }
      result.push(resolveExpression(scope, elem).toString(scope));
      if (useIsolating) {
        result.push(PDI);
      }
    }
    scope.dirty.delete(ptn);
    return result.join("");
  }
  function resolvePattern(scope, value) {
    if (typeof value === "string") {
      return scope.bundle._transform(value);
    }
    return resolveComplexPattern(scope, value);
  }

  // node_modules/@fluent/bundle/esm/scope.js
  var Scope = class {
    constructor(bundle, errors, args) {
      this.dirty = /* @__PURE__ */ new WeakSet();
      this.params = null;
      this.placeables = 0;
      this.bundle = bundle;
      this.errors = errors;
      this.args = args;
    }
    reportError(error) {
      if (!this.errors || !(error instanceof Error)) {
        throw error;
      }
      this.errors.push(error);
    }
    memoizeIntlObject(ctor, opts) {
      let cache2 = this.bundle._intls.get(ctor);
      if (!cache2) {
        cache2 = {};
        this.bundle._intls.set(ctor, cache2);
      }
      let id2 = JSON.stringify(opts);
      if (!cache2[id2]) {
        cache2[id2] = new ctor(this.bundle.locales, opts);
      }
      return cache2[id2];
    }
  };

  // node_modules/@fluent/bundle/esm/builtins.js
  function values(opts, allowed) {
    const unwrapped = /* @__PURE__ */ Object.create(null);
    for (const [name, opt] of Object.entries(opts)) {
      if (allowed.includes(name)) {
        unwrapped[name] = opt.valueOf();
      }
    }
    return unwrapped;
  }
  var NUMBER_ALLOWED = [
    "unitDisplay",
    "currencyDisplay",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits"
  ];
  function NUMBER(args, opts) {
    let arg = args[0];
    if (arg instanceof FluentNone) {
      return new FluentNone(`NUMBER(${arg.valueOf()})`);
    }
    if (arg instanceof FluentNumber) {
      return new FluentNumber(arg.valueOf(), {
        ...arg.opts,
        ...values(opts, NUMBER_ALLOWED)
      });
    }
    if (arg instanceof FluentDateTime) {
      return new FluentNumber(arg.valueOf(), {
        ...values(opts, NUMBER_ALLOWED)
      });
    }
    throw new TypeError("Invalid argument to NUMBER");
  }
  var DATETIME_ALLOWED = [
    "dateStyle",
    "timeStyle",
    "fractionalSecondDigits",
    "dayPeriod",
    "hour12",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName"
  ];
  function DATETIME(args, opts) {
    let arg = args[0];
    if (arg instanceof FluentNone) {
      return new FluentNone(`DATETIME(${arg.valueOf()})`);
    }
    if (arg instanceof FluentDateTime) {
      return new FluentDateTime(arg.valueOf(), {
        ...arg.opts,
        ...values(opts, DATETIME_ALLOWED)
      });
    }
    if (arg instanceof FluentNumber) {
      return new FluentDateTime(arg.valueOf(), {
        ...values(opts, DATETIME_ALLOWED)
      });
    }
    throw new TypeError("Invalid argument to DATETIME");
  }

  // node_modules/@fluent/bundle/esm/memoizer.js
  var cache = /* @__PURE__ */ new Map();
  function getMemoizerForLocale(locales) {
    const stringLocale = Array.isArray(locales) ? locales.join(" ") : locales;
    let memoizer = cache.get(stringLocale);
    if (memoizer === void 0) {
      memoizer = /* @__PURE__ */ new Map();
      cache.set(stringLocale, memoizer);
    }
    return memoizer;
  }

  // node_modules/@fluent/bundle/esm/bundle.js
  var FluentBundle = class {
    /**
     * Create an instance of `FluentBundle`.
     *
     * @example
     * ```js
     * let bundle = new FluentBundle(["en-US", "en"]);
     *
     * let bundle = new FluentBundle(locales, {useIsolating: false});
     *
     * let bundle = new FluentBundle(locales, {
     *   useIsolating: true,
     *   functions: {
     *     NODE_ENV: () => process.env.NODE_ENV
     *   }
     * });
     * ```
     *
     * @param locales - Used to instantiate `Intl` formatters used by translations.
     * @param options - Optional configuration for the bundle.
     */
    constructor(locales, { functions, useIsolating = true, transform: transform2 = (v3) => v3 } = {}) {
      this._terms = /* @__PURE__ */ new Map();
      this._messages = /* @__PURE__ */ new Map();
      this.locales = Array.isArray(locales) ? locales : [locales];
      this._functions = {
        NUMBER,
        DATETIME,
        ...functions
      };
      this._useIsolating = useIsolating;
      this._transform = transform2;
      this._intls = getMemoizerForLocale(locales);
    }
    /**
     * Check if a message is present in the bundle.
     *
     * @param id - The identifier of the message to check.
     */
    hasMessage(id2) {
      return this._messages.has(id2);
    }
    /**
     * Return a raw unformatted message object from the bundle.
     *
     * Raw messages are `{value, attributes}` shapes containing translation units
     * called `Patterns`. `Patterns` are implementation-specific; they should be
     * treated as black boxes and formatted with `FluentBundle.formatPattern`.
     *
     * @param id - The identifier of the message to check.
     */
    getMessage(id2) {
      return this._messages.get(id2);
    }
    /**
     * Add a translation resource to the bundle.
     *
     * @example
     * ```js
     * let res = new FluentResource("foo = Foo");
     * bundle.addResource(res);
     * bundle.getMessage("foo");
     * // → {value: .., attributes: {..}}
     * ```
     *
     * @param res
     * @param options
     */
    addResource(res, { allowOverrides = false } = {}) {
      const errors = [];
      for (let i = 0; i < res.body.length; i++) {
        let entry = res.body[i];
        if (entry.id.startsWith("-")) {
          if (allowOverrides === false && this._terms.has(entry.id)) {
            errors.push(new Error(`Attempt to override an existing term: "${entry.id}"`));
            continue;
          }
          this._terms.set(entry.id, entry);
        } else {
          if (allowOverrides === false && this._messages.has(entry.id)) {
            errors.push(new Error(`Attempt to override an existing message: "${entry.id}"`));
            continue;
          }
          this._messages.set(entry.id, entry);
        }
      }
      return errors;
    }
    /**
     * Format a `Pattern` to a string.
     *
     * Format a raw `Pattern` into a string. `args` will be used to resolve
     * references to variables passed as arguments to the translation.
     *
     * In case of errors `formatPattern` will try to salvage as much of the
     * translation as possible and will still return a string. For performance
     * reasons, the encountered errors are not returned but instead are appended
     * to the `errors` array passed as the third argument.
     *
     * If `errors` is omitted, the first encountered error will be thrown.
     *
     * @example
     * ```js
     * let errors = [];
     * bundle.addResource(
     *     new FluentResource("hello = Hello, {$name}!"));
     *
     * let hello = bundle.getMessage("hello");
     * if (hello.value) {
     *     bundle.formatPattern(hello.value, {name: "Jane"}, errors);
     *     // Returns "Hello, Jane!" and `errors` is empty.
     *
     *     bundle.formatPattern(hello.value, undefined, errors);
     *     // Returns "Hello, {$name}!" and `errors` is now:
     *     // [<ReferenceError: Unknown variable: name>]
     * }
     * ```
     */
    formatPattern(pattern, args = null, errors = null) {
      if (typeof pattern === "string") {
        return this._transform(pattern);
      }
      let scope = new Scope(this, errors, args);
      try {
        let value = resolveComplexPattern(scope, pattern);
        return value.toString(scope);
      } catch (err) {
        if (scope.errors && err instanceof Error) {
          scope.errors.push(err);
          return new FluentNone().toString(scope);
        }
        throw err;
      }
    }
  };

  // node_modules/@fluent/bundle/esm/resource.js
  var RE_MESSAGE_START = /^(-?[a-zA-Z][\w-]*) *= */gm;
  var RE_ATTRIBUTE_START = /\.([a-zA-Z][\w-]*) *= */y;
  var RE_VARIANT_START = /\*?\[/y;
  var RE_NUMBER_LITERAL = /(-?[0-9]+(?:\.([0-9]+))?)/y;
  var RE_IDENTIFIER = /([a-zA-Z][\w-]*)/y;
  var RE_REFERENCE = /([$-])?([a-zA-Z][\w-]*)(?:\.([a-zA-Z][\w-]*))?/y;
  var RE_FUNCTION_NAME = /^[A-Z][A-Z0-9_-]*$/;
  var RE_TEXT_RUN = /([^{}\n\r]+)/y;
  var RE_STRING_RUN = /([^\\"\n\r]*)/y;
  var RE_STRING_ESCAPE = /\\([\\"])/y;
  var RE_UNICODE_ESCAPE = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{6})/y;
  var RE_LEADING_NEWLINES = /^\n+/;
  var RE_TRAILING_SPACES = / +$/;
  var RE_BLANK_LINES = / *\r?\n/g;
  var RE_INDENT = /( *)$/;
  var TOKEN_BRACE_OPEN = /{\s*/y;
  var TOKEN_BRACE_CLOSE = /\s*}/y;
  var TOKEN_BRACKET_OPEN = /\[\s*/y;
  var TOKEN_BRACKET_CLOSE = /\s*] */y;
  var TOKEN_PAREN_OPEN = /\s*\(\s*/y;
  var TOKEN_ARROW = /\s*->\s*/y;
  var TOKEN_COLON = /\s*:\s*/y;
  var TOKEN_COMMA = /\s*,?\s*/y;
  var TOKEN_BLANK = /\s+/y;
  var FluentResource = class {
    constructor(source2) {
      this.body = [];
      RE_MESSAGE_START.lastIndex = 0;
      let cursor = 0;
      while (true) {
        let next2 = RE_MESSAGE_START.exec(source2);
        if (next2 === null) {
          break;
        }
        cursor = RE_MESSAGE_START.lastIndex;
        try {
          this.body.push(parseMessage(next2[1]));
        } catch (err) {
          if (err instanceof SyntaxError) {
            continue;
          }
          throw err;
        }
      }
      function test(re2) {
        re2.lastIndex = cursor;
        return re2.test(source2);
      }
      function consumeChar(char, errorClass) {
        if (source2[cursor] === char) {
          cursor++;
          return true;
        }
        if (errorClass) {
          throw new errorClass(`Expected ${char}`);
        }
        return false;
      }
      function consumeToken(re2, errorClass) {
        if (test(re2)) {
          cursor = re2.lastIndex;
          return true;
        }
        if (errorClass) {
          throw new errorClass(`Expected ${re2.toString()}`);
        }
        return false;
      }
      function match2(re2) {
        re2.lastIndex = cursor;
        let result = re2.exec(source2);
        if (result === null) {
          throw new SyntaxError(`Expected ${re2.toString()}`);
        }
        cursor = re2.lastIndex;
        return result;
      }
      function match1(re2) {
        return match2(re2)[1];
      }
      function parseMessage(id2) {
        let value = parsePattern();
        let attributes = parseAttributes();
        if (value === null && Object.keys(attributes).length === 0) {
          throw new SyntaxError("Expected message value or attributes");
        }
        return { id: id2, value, attributes };
      }
      function parseAttributes() {
        let attrs = /* @__PURE__ */ Object.create(null);
        while (test(RE_ATTRIBUTE_START)) {
          let name = match1(RE_ATTRIBUTE_START);
          let value = parsePattern();
          if (value === null) {
            throw new SyntaxError("Expected attribute value");
          }
          attrs[name] = value;
        }
        return attrs;
      }
      function parsePattern() {
        let first;
        if (test(RE_TEXT_RUN)) {
          first = match1(RE_TEXT_RUN);
        }
        if (source2[cursor] === "{" || source2[cursor] === "}") {
          return parsePatternElements(first ? [first] : [], Infinity);
        }
        let indent = parseIndent();
        if (indent) {
          if (first) {
            return parsePatternElements([first, indent], indent.length);
          }
          indent.value = trim(indent.value, RE_LEADING_NEWLINES);
          return parsePatternElements([indent], indent.length);
        }
        if (first) {
          return trim(first, RE_TRAILING_SPACES);
        }
        return null;
      }
      function parsePatternElements(elements = [], commonIndent) {
        while (true) {
          if (test(RE_TEXT_RUN)) {
            elements.push(match1(RE_TEXT_RUN));
            continue;
          }
          if (source2[cursor] === "{") {
            elements.push(parsePlaceable());
            continue;
          }
          if (source2[cursor] === "}") {
            throw new SyntaxError("Unbalanced closing brace");
          }
          let indent = parseIndent();
          if (indent) {
            elements.push(indent);
            commonIndent = Math.min(commonIndent, indent.length);
            continue;
          }
          break;
        }
        let lastIndex = elements.length - 1;
        let lastElement = elements[lastIndex];
        if (typeof lastElement === "string") {
          elements[lastIndex] = trim(lastElement, RE_TRAILING_SPACES);
        }
        let baked = [];
        for (let element2 of elements) {
          if (element2 instanceof Indent) {
            element2 = element2.value.slice(0, element2.value.length - commonIndent);
          }
          if (element2) {
            baked.push(element2);
          }
        }
        return baked;
      }
      function parsePlaceable() {
        consumeToken(TOKEN_BRACE_OPEN, SyntaxError);
        let selector = parseInlineExpression();
        if (consumeToken(TOKEN_BRACE_CLOSE)) {
          return selector;
        }
        if (consumeToken(TOKEN_ARROW)) {
          let variants = parseVariants();
          consumeToken(TOKEN_BRACE_CLOSE, SyntaxError);
          return {
            type: "select",
            selector,
            ...variants
          };
        }
        throw new SyntaxError("Unclosed placeable");
      }
      function parseInlineExpression() {
        if (source2[cursor] === "{") {
          return parsePlaceable();
        }
        if (test(RE_REFERENCE)) {
          let [, sigil, name, attr2 = null] = match2(RE_REFERENCE);
          if (sigil === "$") {
            return { type: "var", name };
          }
          if (consumeToken(TOKEN_PAREN_OPEN)) {
            let args = parseArguments();
            if (sigil === "-") {
              return { type: "term", name, attr: attr2, args };
            }
            if (RE_FUNCTION_NAME.test(name)) {
              return { type: "func", name, args };
            }
            throw new SyntaxError("Function names must be all upper-case");
          }
          if (sigil === "-") {
            return {
              type: "term",
              name,
              attr: attr2,
              args: []
            };
          }
          return { type: "mesg", name, attr: attr2 };
        }
        return parseLiteral();
      }
      function parseArguments() {
        let args = [];
        while (true) {
          switch (source2[cursor]) {
            case ")":
              cursor++;
              return args;
            case void 0:
              throw new SyntaxError("Unclosed argument list");
          }
          args.push(parseArgument());
          consumeToken(TOKEN_COMMA);
        }
      }
      function parseArgument() {
        let expr = parseInlineExpression();
        if (expr.type !== "mesg") {
          return expr;
        }
        if (consumeToken(TOKEN_COLON)) {
          return {
            type: "narg",
            name: expr.name,
            value: parseLiteral()
          };
        }
        return expr;
      }
      function parseVariants() {
        let variants = [];
        let count3 = 0;
        let star;
        while (test(RE_VARIANT_START)) {
          if (consumeChar("*")) {
            star = count3;
          }
          let key = parseVariantKey();
          let value = parsePattern();
          if (value === null) {
            throw new SyntaxError("Expected variant value");
          }
          variants[count3++] = { key, value };
        }
        if (count3 === 0) {
          return null;
        }
        if (star === void 0) {
          throw new SyntaxError("Expected default variant");
        }
        return { variants, star };
      }
      function parseVariantKey() {
        consumeToken(TOKEN_BRACKET_OPEN, SyntaxError);
        let key;
        if (test(RE_NUMBER_LITERAL)) {
          key = parseNumberLiteral();
        } else {
          key = {
            type: "str",
            value: match1(RE_IDENTIFIER)
          };
        }
        consumeToken(TOKEN_BRACKET_CLOSE, SyntaxError);
        return key;
      }
      function parseLiteral() {
        if (test(RE_NUMBER_LITERAL)) {
          return parseNumberLiteral();
        }
        if (source2[cursor] === '"') {
          return parseStringLiteral();
        }
        throw new SyntaxError("Invalid expression");
      }
      function parseNumberLiteral() {
        let [, value, fraction = ""] = match2(RE_NUMBER_LITERAL);
        let precision = fraction.length;
        return {
          type: "num",
          value: parseFloat(value),
          precision
        };
      }
      function parseStringLiteral() {
        consumeChar('"', SyntaxError);
        let value = "";
        while (true) {
          value += match1(RE_STRING_RUN);
          if (source2[cursor] === "\\") {
            value += parseEscapeSequence();
            continue;
          }
          if (consumeChar('"')) {
            return { type: "str", value };
          }
          throw new SyntaxError("Unclosed string literal");
        }
      }
      function parseEscapeSequence() {
        if (test(RE_STRING_ESCAPE)) {
          return match1(RE_STRING_ESCAPE);
        }
        if (test(RE_UNICODE_ESCAPE)) {
          let [, codepoint4, codepoint6] = match2(RE_UNICODE_ESCAPE);
          let codepoint = parseInt(codepoint4 || codepoint6, 16);
          return codepoint <= 55295 || 57344 <= codepoint ? (
            // It's a Unicode scalar value.
            String.fromCodePoint(codepoint)
          ) : (
            // Lonely surrogates can cause trouble when the parsing result is
            // saved using UTF-8. Use U+FFFD REPLACEMENT CHARACTER instead.
            "\uFFFD"
          );
        }
        throw new SyntaxError("Unknown escape sequence");
      }
      function parseIndent() {
        let start2 = cursor;
        consumeToken(TOKEN_BLANK);
        switch (source2[cursor]) {
          case ".":
          case "[":
          case "*":
          case "}":
          case void 0:
            return false;
          case "{":
            return makeIndent(source2.slice(start2, cursor));
        }
        if (source2[cursor - 1] === " ") {
          return makeIndent(source2.slice(start2, cursor));
        }
        return false;
      }
      function trim(text2, re2) {
        return text2.replace(re2, "");
      }
      function makeIndent(blank) {
        let value = blank.replace(RE_BLANK_LINES, "\n");
        let length3 = RE_INDENT.exec(blank)[1].length;
        return new Indent(value, length3);
      }
    }
  };
  var Indent = class {
    constructor(value, length3) {
      this.value = value;
      this.length = length3;
    }
  };

  // src/ts/i18n.ts
  var locale3 = new FluentResource(SSEother.lang_ftl);
  var fallback2 = new FluentResource(SSEother.fallback_ftl);
  var i18n_bundle = new FluentBundle(SSEother.lang.replace("_", "-"));
  i18n_bundle.addResource(locale3);
  i18n_bundle.addResource(fallback2, { allowOverrides: false });
  function i18n(message, args) {
    return i18n_bundle.formatPattern(i18n_bundle.getMessage(message)?.value || message, args);
  }
  function i18n_pattern(pattern) {
    return i18n_bundle.getMessage(pattern)?.value || pattern;
  }

  // src/ts/barHelpers.ts
  function totalCalc(data2) {
    return data2.values.length > 1 ? [`${i18n("total")}: ${parseFloat(import_lodash.default.sum(data2.values).toFixed(2))}`] : [];
  }

  // src/ts/graph.ts
  function defaultGraphBounds() {
    return {
      width: SSEconfig.barWidth ?? 600,
      height: SSEconfig.barHeight ?? 250,
      marginLeft: 70,
      marginRight: 70,
      marginTop: 20,
      marginBottom: 25
    };
  }
  var MATURE_COLOUR = "#31a354";
  var YOUNG_COLOUR = "#74c476";
  var LEARN_COLOUR = "#fd8d3c";
  var RELEARN_COLOUR = "#fb6a4a";

  // node_modules/ts-fsrs/dist/index.mjs
  var u4 = ((a4) => (a4[a4.New = 0] = "New", a4[a4.Learning = 1] = "Learning", a4[a4.Review = 2] = "Review", a4[a4.Relearning = 3] = "Relearning", a4))(u4 || {});
  var l = ((a4) => (a4[a4.Manual = 0] = "Manual", a4[a4.Again = 1] = "Again", a4[a4.Hard = 2] = "Hard", a4[a4.Good = 3] = "Good", a4[a4.Easy = 4] = "Easy", a4))(l || {});
  var h = class _h {
    static card(t) {
      return { ...t, state: _h.state(t.state), due: _h.time(t.due), last_review: t.last_review ? _h.time(t.last_review) : void 0 };
    }
    static rating(t) {
      if (typeof t == "string") {
        const e = t.charAt(0).toUpperCase(), i = t.slice(1).toLowerCase(), r = l[`${e}${i}`];
        if (r === void 0) throw new Error(`Invalid rating:[${t}]`);
        return r;
      } else if (typeof t == "number") return t;
      throw new Error(`Invalid rating:[${t}]`);
    }
    static state(t) {
      if (typeof t == "string") {
        const e = t.charAt(0).toUpperCase(), i = t.slice(1).toLowerCase(), r = u4[`${e}${i}`];
        if (r === void 0) throw new Error(`Invalid state:[${t}]`);
        return r;
      } else if (typeof t == "number") return t;
      throw new Error(`Invalid state:[${t}]`);
    }
    static time(t) {
      if (typeof t == "object" && t instanceof Date) return t;
      if (typeof t == "string") {
        const e = Date.parse(t);
        if (isNaN(e)) throw new Error(`Invalid date:[${t}]`);
        return new Date(e);
      } else if (typeof t == "number") return new Date(t);
      throw new Error(`Invalid date:[${t}]`);
    }
    static review_log(t) {
      return { ...t, due: _h.time(t.due), rating: _h.rating(t.rating), state: _h.state(t.state), review: _h.time(t.review) };
    }
  };
  Date.prototype.scheduler = function(a4, t) {
    return H(this, a4, t);
  }, Date.prototype.diff = function(a4, t) {
    return G(this, a4, t);
  }, Date.prototype.format = function() {
    return z(this);
  }, Date.prototype.dueFormat = function(a4, t, e) {
    return C3(this, a4, t, e);
  };
  function H(a4, t, e) {
    return new Date(e ? h.time(a4).getTime() + t * 24 * 60 * 60 * 1e3 : h.time(a4).getTime() + t * 60 * 1e3);
  }
  function G(a4, t, e) {
    if (!a4 || !t) throw new Error("Invalid date");
    const i = h.time(a4).getTime() - h.time(t).getTime();
    let r = 0;
    switch (e) {
      case "days":
        r = Math.floor(i / (24 * 60 * 60 * 1e3));
        break;
      case "minutes":
        r = Math.floor(i / (60 * 1e3));
        break;
    }
    return r;
  }
  function z(a4) {
    const t = h.time(a4), e = t.getFullYear(), i = t.getMonth() + 1, r = t.getDate(), s2 = t.getHours(), n = t.getMinutes(), d = t.getSeconds();
    return `${e}-${v2(i)}-${v2(r)} ${v2(s2)}:${v2(n)}:${v2(d)}`;
  }
  function v2(a4) {
    return a4 < 10 ? `0${a4}` : `${a4}`;
  }
  var F = [60, 60, 24, 31, 12];
  var A5 = ["second", "min", "hour", "day", "month", "year"];
  function C3(a4, t, e, i = A5) {
    a4 = h.time(a4), t = h.time(t), i.length !== A5.length && (i = A5);
    let r = a4.getTime() - t.getTime(), s2;
    for (r /= 1e3, s2 = 0; s2 < F.length && !(r < F[s2]); s2++) r /= F[s2];
    return `${Math.floor(r)}${e ? i[s2] : ""}`;
  }
  var T = Object.freeze([l.Again, l.Hard, l.Good, l.Easy]);
  var nt = [{ start: 2.5, end: 7, factor: 0.15 }, { start: 7, end: 20, factor: 0.1 }, { start: 20, end: 1 / 0, factor: 0.05 }];
  function U(a4, t, e) {
    let i = 1;
    for (const n of nt) i += n.factor * Math.max(Math.min(a4, n.end) - n.start, 0);
    a4 = Math.min(a4, e);
    let r = Math.max(2, Math.round(a4 - i));
    const s2 = Math.min(Math.round(a4 + i), e);
    return a4 > t && (r = Math.max(r, t + 1)), r = Math.min(r, s2), { min_ivl: r, max_ivl: s2 };
  }
  function m3(a4, t, e) {
    return Math.min(Math.max(a4, t), e);
  }
  function k2(a4, t) {
    const e = Date.UTC(a4.getUTCFullYear(), a4.getUTCMonth(), a4.getUTCDate()), i = Date.UTC(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate());
    return Math.floor((i - e) / 864e5);
  }
  var lt = "5.0.0";
  var q = 0.9;
  var P = 36500;
  var j = false;
  var O = true;
  var Y3 = Object.freeze(["1m", "10m"]);
  var W = Object.freeze(["10m"]);
  var dt = `v${lt} using FSRS-6.0`;
  var y4 = 1e-3;
  var x4 = 100;
  var L = 0.5;
  var B3 = 0.2;
  var N = Object.freeze([0.2172, 1.1771, 3.2602, 16.1507, 7.0114, 0.57, 2.0966, 69e-4, 1.5261, 0.112, 1.0178, 1.849, 0.1133, 0.3127, 2.2934, 0.2191, 3.0004, 0.7536, 0.3332, 0.1437, B3]);
  var X3 = 2;
  var V = (a4) => [[y4, x4], [y4, x4], [y4, x4], [y4, x4], [1, 10], [1e-3, 4], [1e-3, 4], [1e-3, 0.75], [0, 4.5], [0, 0.8], [1e-3, 3.5], [1e-3, 5], [1e-3, 0.25], [1e-3, 0.9], [0, 4], [0, 1], [1, 6], [0, a4], [0, a4], [0, 0.8], [0.1, 0.8]];
  var M2 = (a4, t) => {
    let e = X3;
    if (Math.max(0, t) > 1) {
      const i = -(Math.log(a4[11]) + Math.log(Math.pow(2, a4[13]) - 1) + a4[14] * 0.3) / t;
      e = m3(+i.toFixed(8), 0.01, 2);
    }
    return V(e).map(([i, r], s2) => m3(a4[s2], i, r));
  };
  var ot = (a4) => {
    if (a4.find((t) => !isFinite(t) && !isNaN(t)) !== void 0) throw Error(`Non-finite or NaN value in parameters ${a4}`);
    if (![17, 19, 21].includes(a4.length)) throw Error(`Invalid parameter length: ${a4.length}. Must be 17, 19 or 21 for FSRSv4, 5 and 6 respectively.`);
    return a4;
  };
  var S = (a4) => {
    if (a4 === void 0) return [...N];
    switch (a4.length) {
      case 21:
        return [...a4];
      case 19:
        return console.debug("[FSRS-6]auto fill w from 19 to 21 length"), [...a4, 0, L];
      case 17: {
        const t = [...a4];
        return t[4] = +(t[5] * 2 + t[4]).toFixed(8), t[5] = +(Math.log(t[5] * 3 + 1) / 3).toFixed(8), t[6] = +(t[6] + 0.5).toFixed(8), console.debug("[FSRS-6]auto fill w from 17 to 21 length"), t.concat([0, 0, 0, L]);
      }
      default:
        return console.warn("[FSRS]Invalid parameters length, using default parameters"), [...N];
    }
  };
  var $ = (a4) => {
    const t = Array.isArray(a4?.learning_steps) ? a4.learning_steps : Y3, e = Array.isArray(a4?.relearning_steps) ? a4.relearning_steps : W, i = M2(S(a4?.w), e.length);
    return { request_retention: a4?.request_retention || q, maximum_interval: a4?.maximum_interval || P, w: i, enable_fuzz: a4?.enable_fuzz ?? j, enable_short_term: a4?.enable_short_term ?? O, learning_steps: t, relearning_steps: e };
  };
  function E2(a4, t) {
    const e = { due: a4 ? h.time(a4) : /* @__PURE__ */ new Date(), stability: 0, difficulty: 0, elapsed_days: 0, scheduled_days: 0, reps: 0, lapses: 0, learning_steps: 0, state: u4.New, last_review: void 0 };
    return t && typeof t == "function" ? t(e) : e;
  }
  var ut = class {
    c;
    s0;
    s1;
    s2;
    constructor(t) {
      const e = ct();
      this.c = 1, this.s0 = e(" "), this.s1 = e(" "), this.s2 = e(" "), t == null && (t = +/* @__PURE__ */ new Date()), this.s0 -= e(t), this.s0 < 0 && (this.s0 += 1), this.s1 -= e(t), this.s1 < 0 && (this.s1 += 1), this.s2 -= e(t), this.s2 < 0 && (this.s2 += 1);
    }
    next() {
      const t = 2091639 * this.s0 + this.c * 23283064365386963e-26;
      return this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - (this.c = t | 0), this.s2;
    }
    set state(t) {
      this.c = t.c, this.s0 = t.s0, this.s1 = t.s1, this.s2 = t.s2;
    }
    get state() {
      return { c: this.c, s0: this.s0, s1: this.s1, s2: this.s2 };
    }
  };
  function ct() {
    let a4 = 4022871197;
    return function(t) {
      t = String(t);
      for (let e = 0; e < t.length; e++) {
        a4 += t.charCodeAt(e);
        let i = 0.02519603282416938 * a4;
        a4 = i >>> 0, i -= a4, i *= a4, a4 = i >>> 0, i -= a4, a4 += i * 4294967296;
      }
      return (a4 >>> 0) * 23283064365386963e-26;
    };
  }
  function ft(a4) {
    const t = new ut(a4), e = () => t.next();
    return e.int32 = () => t.next() * 4294967296 | 0, e.double = () => e() + (e() * 2097152 | 0) * 11102230246251565e-32, e.state = () => t.state, e.importState = (i) => (t.state = i, e), e;
  }
  var D3 = (a4) => {
    const t = typeof a4 == "number" ? -a4 : -a4[20], e = Math.exp(Math.pow(t, -1) * Math.log(0.9)) - 1;
    return { decay: t, factor: +e.toFixed(8) };
  };
  function R(a4, t, e) {
    const { decay: i, factor: r } = D3(a4);
    return +Math.pow(1 + r * t / e, i).toFixed(8);
  }
  var J = class {
    param;
    intervalModifier;
    _seed;
    constructor(t) {
      this.param = new Proxy($(t), this.params_handler_proxy()), this.intervalModifier = this.calculate_interval_modifier(this.param.request_retention), this.forgetting_curve = R.bind(this, this.param.w);
    }
    get interval_modifier() {
      return this.intervalModifier;
    }
    set seed(t) {
      this._seed = t;
    }
    calculate_interval_modifier(t) {
      if (t <= 0 || t > 1) throw new Error("Requested retention rate should be in the range (0,1]");
      const { decay: e, factor: i } = D3(this.param.w);
      return +((Math.pow(t, 1 / e) - 1) / i).toFixed(8);
    }
    get parameters() {
      return this.param;
    }
    set parameters(t) {
      this.update_parameters(t);
    }
    params_handler_proxy() {
      const t = this;
      return { set: function(e, i, r) {
        return i === "request_retention" && Number.isFinite(r) ? t.intervalModifier = t.calculate_interval_modifier(Number(r)) : i === "w" && (r = M2(S(r), e.relearning_steps.length), t.forgetting_curve = R.bind(this, r), t.intervalModifier = t.calculate_interval_modifier(Number(e.request_retention))), Reflect.set(e, i, r), true;
      } };
    }
    update_parameters(t) {
      const e = $(t);
      for (const i in e) if (i in this.param) {
        const r = i;
        this.param[r] = e[r];
      }
    }
    init_stability(t) {
      return Math.max(this.param.w[t - 1], 0.1);
    }
    init_difficulty(t) {
      const e = this.param.w[4] - Math.exp((t - 1) * this.param.w[5]) + 1;
      return m3(+e.toFixed(8), 1, 10);
    }
    apply_fuzz(t, e) {
      if (!this.param.enable_fuzz || t < 2.5) return Math.round(t);
      const i = ft(this._seed)(), { min_ivl: r, max_ivl: s2 } = U(t, e, this.param.maximum_interval);
      return Math.floor(i * (s2 - r + 1) + r);
    }
    next_interval(t, e) {
      const i = Math.min(Math.max(1, Math.round(t * this.intervalModifier)), this.param.maximum_interval);
      return this.apply_fuzz(i, e);
    }
    linear_damping(t, e) {
      return +(t * (10 - e) / 9).toFixed(8);
    }
    next_difficulty(t, e) {
      const i = -this.param.w[6] * (e - 3), r = t + this.linear_damping(i, t);
      return m3(this.mean_reversion(this.init_difficulty(l.Easy), r), 1, 10);
    }
    mean_reversion(t, e) {
      return +(this.param.w[7] * t + (1 - this.param.w[7]) * e).toFixed(8);
    }
    next_recall_stability(t, e, i, r) {
      const s2 = l.Hard === r ? this.param.w[15] : 1, n = l.Easy === r ? this.param.w[16] : 1;
      return +m3(e * (1 + Math.exp(this.param.w[8]) * (11 - t) * Math.pow(e, -this.param.w[9]) * (Math.exp((1 - i) * this.param.w[10]) - 1) * s2 * n), y4, 36500).toFixed(8);
    }
    next_forget_stability(t, e, i) {
      return +m3(this.param.w[11] * Math.pow(t, -this.param.w[12]) * (Math.pow(e + 1, this.param.w[13]) - 1) * Math.exp((1 - i) * this.param.w[14]), y4, 36500).toFixed(8);
    }
    next_short_term_stability(t, e) {
      const i = Math.pow(t, -this.param.w[19]) * Math.exp(this.param.w[17] * (e - 3 + this.param.w[18])), r = e >= 3 ? Math.max(i, 1) : i;
      return +m3(t * r, y4, 36500).toFixed(8);
    }
    forgetting_curve;
    next_state(t, e, i) {
      const { difficulty: r, stability: s2 } = t ?? { difficulty: 0, stability: 0 };
      if (e < 0) throw new Error(`Invalid delta_t "${e}"`);
      if (i < 0 || i > 4) throw new Error(`Invalid grade "${i}"`);
      if (r === 0 && s2 === 0) return { difficulty: this.init_difficulty(i), stability: this.init_stability(i) };
      if (i === 0) return { difficulty: r, stability: s2 };
      if (r < 1 || s2 < y4) throw new Error(`Invalid memory state { difficulty: ${r}, stability: ${s2} }`);
      const n = this.forgetting_curve(e, s2), d = this.next_recall_stability(r, s2, n, i), o = this.next_forget_stability(r, s2, n), c6 = this.next_short_term_stability(s2, i);
      let f = d;
      if (i === 1) {
        let [g, p] = [0, 0];
        this.param.enable_short_term && (g = this.param.w[17], p = this.param.w[18]);
        const _25 = s2 / Math.exp(g * p);
        f = m3(+_25.toFixed(8), y4, o);
      }
      return e === 0 && this.param.enable_short_term && (f = c6), { difficulty: this.next_difficulty(r, i), stability: f };
    }
  };
  function K2() {
    const a4 = this.review_time.getTime(), t = this.current.reps, e = this.current.difficulty * this.current.stability;
    return `${a4}_${t}_${e}`;
  }
  var Q = (a4) => {
    const t = a4.slice(-1), e = parseInt(a4.slice(0, -1), 10);
    if (isNaN(e) || !Number.isFinite(e) || e < 0) throw new Error(`Invalid step value: ${a4}`);
    switch (t) {
      case "m":
        return e;
      case "h":
        return e * 60;
      case "d":
        return e * 1440;
      default:
        throw new Error(`Invalid step unit: ${a4}, expected m/h/d`);
    }
  };
  var Z = (a4, t, e) => {
    const i = t === u4.Relearning || t === u4.Review ? a4.relearning_steps : a4.learning_steps, r = i.length;
    if (r === 0 || e >= r) return {};
    const s2 = i[0], n = Q, d = () => n(s2), o = () => {
      if (r === 1) return Math.round(n(s2) * 1.5);
      const _25 = i[1];
      return Math.round((n(s2) + n(_25)) / 2);
    }, c6 = (_25) => _25 < 0 || _25 >= r ? null : i[_25], f = (_25) => n(_25), g = {}, p = c6(Math.max(0, e));
    if (t === u4.Review) return g[l.Again] = { scheduled_minutes: n(p), next_step: 0 }, g;
    {
      g[l.Again] = { scheduled_minutes: d(), next_step: 0 }, g[l.Hard] = { scheduled_minutes: o(), next_step: e };
      const _25 = c6(e + 1);
      if (_25) {
        const w = f(_25);
        w && (g[l.Good] = { scheduled_minutes: Math.round(w), next_step: e + 1 });
      }
    }
    return g;
  };
  var b = ((a4) => (a4.SCHEDULER = "Scheduler", a4.LEARNING_STEPS = "LearningSteps", a4.SEED = "Seed", a4))(b || {});
  var I = class {
    last;
    current;
    review_time;
    next = /* @__PURE__ */ new Map();
    algorithm;
    strategies;
    constructor(t, e, i, r) {
      this.algorithm = i, this.last = h.card(t), this.current = h.card(t), this.review_time = h.time(e), this.strategies = r, this.init();
    }
    checkGrade(t) {
      if (!Number.isFinite(t) || t < 0 || t > 4) throw new Error(`Invalid grade "${t}",expected 1-4`);
    }
    init() {
      const { state: t, last_review: e } = this.current;
      let i = 0;
      t !== u4.New && e && (i = k2(e, this.review_time)), this.current.last_review = this.review_time, this.current.elapsed_days = i, this.current.reps += 1;
      let r = K2;
      if (this.strategies) {
        const s2 = this.strategies.get(b.SEED);
        s2 && (r = s2);
      }
      this.algorithm.seed = r.call(this);
    }
    preview() {
      return { [l.Again]: this.review(l.Again), [l.Hard]: this.review(l.Hard), [l.Good]: this.review(l.Good), [l.Easy]: this.review(l.Easy), [Symbol.iterator]: this.previewIterator.bind(this) };
    }
    *previewIterator() {
      for (const t of T) yield this.review(t);
    }
    review(t) {
      const { state: e } = this.last;
      let i;
      switch (this.checkGrade(t), e) {
        case u4.New:
          i = this.newState(t);
          break;
        case u4.Learning:
        case u4.Relearning:
          i = this.learningState(t);
          break;
        case u4.Review:
          i = this.reviewState(t);
          break;
      }
      return i;
    }
    buildLog(t) {
      const { last_review: e, due: i, elapsed_days: r } = this.last;
      return { rating: t, state: this.current.state, due: e || i, stability: this.current.stability, difficulty: this.current.difficulty, elapsed_days: this.current.elapsed_days, last_elapsed_days: r, scheduled_days: this.current.scheduled_days, learning_steps: this.current.learning_steps, review: this.review_time };
    }
  };
  var tt = class extends I {
    learningStepsStrategy;
    constructor(t, e, i, r) {
      super(t, e, i, r);
      let s2 = Z;
      if (this.strategies) {
        const n = this.strategies.get(b.LEARNING_STEPS);
        n && (s2 = n);
      }
      this.learningStepsStrategy = s2;
    }
    getLearningInfo(t, e) {
      const i = this.algorithm.parameters;
      t.learning_steps = t.learning_steps || 0;
      const r = this.learningStepsStrategy(i, t.state, this.current.state === u4.Learning ? t.learning_steps + 1 : t.learning_steps), s2 = Math.max(0, r[e]?.scheduled_minutes ?? 0), n = Math.max(0, r[e]?.next_step ?? 0);
      return { scheduled_minutes: s2, next_steps: n };
    }
    applyLearningSteps(t, e, i) {
      const { scheduled_minutes: r, next_steps: s2 } = this.getLearningInfo(this.current, e);
      if (r > 0 && r < 1440) t.learning_steps = s2, t.scheduled_days = 0, t.state = i, t.due = this.review_time.scheduler(Math.round(r), false);
      else if (t.state = u4.Review, r >= 1440) t.learning_steps = s2, t.due = this.review_time.scheduler(Math.round(r), false), t.scheduled_days = Math.floor(r / 1440);
      else {
        t.learning_steps = 0;
        const n = this.algorithm.next_interval(t.stability, this.current.elapsed_days);
        t.scheduled_days = n, t.due = this.review_time.scheduler(n, true);
      }
    }
    newState(t) {
      const e = this.next.get(t);
      if (e) return e;
      const i = h.card(this.current);
      i.difficulty = this.algorithm.init_difficulty(t), i.stability = this.algorithm.init_stability(t), this.applyLearningSteps(i, t, u4.Learning);
      const r = { card: i, log: this.buildLog(t) };
      return this.next.set(t, r), r;
    }
    learningState(t) {
      const e = this.next.get(t);
      if (e) return e;
      const { state: i, difficulty: r, stability: s2 } = this.last, n = h.card(this.current);
      n.difficulty = this.algorithm.next_difficulty(r, t), n.stability = this.algorithm.next_short_term_stability(s2, t), this.applyLearningSteps(n, t, i);
      const d = { card: n, log: this.buildLog(t) };
      return this.next.set(t, d), d;
    }
    reviewState(t) {
      const e = this.next.get(t);
      if (e) return e;
      const i = this.current.elapsed_days, { difficulty: r, stability: s2 } = this.last, n = this.algorithm.forgetting_curve(i, s2), d = h.card(this.current), o = h.card(this.current), c6 = h.card(this.current), f = h.card(this.current);
      this.next_ds(d, o, c6, f, r, s2, n), this.next_interval(o, c6, f, i), this.next_state(o, c6, f), this.applyLearningSteps(d, l.Again, u4.Relearning), d.lapses += 1;
      const g = { card: d, log: this.buildLog(l.Again) }, p = { card: o, log: super.buildLog(l.Hard) }, _25 = { card: c6, log: super.buildLog(l.Good) }, w = { card: f, log: super.buildLog(l.Easy) };
      return this.next.set(l.Again, g), this.next.set(l.Hard, p), this.next.set(l.Good, _25), this.next.set(l.Easy, w), this.next.get(t);
    }
    next_ds(t, e, i, r, s2, n, d) {
      t.difficulty = this.algorithm.next_difficulty(s2, l.Again);
      const o = n / Math.exp(this.algorithm.parameters.w[17] * this.algorithm.parameters.w[18]), c6 = this.algorithm.next_forget_stability(s2, n, d);
      t.stability = m3(+o.toFixed(8), y4, c6), e.difficulty = this.algorithm.next_difficulty(s2, l.Hard), e.stability = this.algorithm.next_recall_stability(s2, n, d, l.Hard), i.difficulty = this.algorithm.next_difficulty(s2, l.Good), i.stability = this.algorithm.next_recall_stability(s2, n, d, l.Good), r.difficulty = this.algorithm.next_difficulty(s2, l.Easy), r.stability = this.algorithm.next_recall_stability(s2, n, d, l.Easy);
    }
    next_interval(t, e, i, r) {
      let s2, n;
      s2 = this.algorithm.next_interval(t.stability, r), n = this.algorithm.next_interval(e.stability, r), s2 = Math.min(s2, n), n = Math.max(n, s2 + 1);
      const d = Math.max(this.algorithm.next_interval(i.stability, r), n + 1);
      t.scheduled_days = s2, t.due = this.review_time.scheduler(s2, true), e.scheduled_days = n, e.due = this.review_time.scheduler(n, true), i.scheduled_days = d, i.due = this.review_time.scheduler(d, true);
    }
    next_state(t, e, i) {
      t.state = u4.Review, t.learning_steps = 0, e.state = u4.Review, e.learning_steps = 0, i.state = u4.Review, i.learning_steps = 0;
    }
  };
  var et = class extends I {
    newState(t) {
      const e = this.next.get(t);
      if (e) return e;
      this.current.scheduled_days = 0, this.current.elapsed_days = 0;
      const i = h.card(this.current), r = h.card(this.current), s2 = h.card(this.current), n = h.card(this.current);
      return this.init_ds(i, r, s2, n), this.next_interval(i, r, s2, n, 0), this.next_state(i, r, s2, n), this.update_next(i, r, s2, n), this.next.get(t);
    }
    init_ds(t, e, i, r) {
      t.difficulty = this.algorithm.init_difficulty(l.Again), t.stability = this.algorithm.init_stability(l.Again), e.difficulty = this.algorithm.init_difficulty(l.Hard), e.stability = this.algorithm.init_stability(l.Hard), i.difficulty = this.algorithm.init_difficulty(l.Good), i.stability = this.algorithm.init_stability(l.Good), r.difficulty = this.algorithm.init_difficulty(l.Easy), r.stability = this.algorithm.init_stability(l.Easy);
    }
    learningState(t) {
      return this.reviewState(t);
    }
    reviewState(t) {
      const e = this.next.get(t);
      if (e) return e;
      const i = this.current.elapsed_days, { difficulty: r, stability: s2 } = this.last, n = this.algorithm.forgetting_curve(i, s2), d = h.card(this.current), o = h.card(this.current), c6 = h.card(this.current), f = h.card(this.current);
      return this.next_ds(d, o, c6, f, r, s2, n), this.next_interval(d, o, c6, f, i), this.next_state(d, o, c6, f), d.lapses += 1, this.update_next(d, o, c6, f), this.next.get(t);
    }
    next_ds(t, e, i, r, s2, n, d) {
      t.difficulty = this.algorithm.next_difficulty(s2, l.Again);
      const o = this.algorithm.next_forget_stability(s2, n, d);
      t.stability = m3(n, y4, o), e.difficulty = this.algorithm.next_difficulty(s2, l.Hard), e.stability = this.algorithm.next_recall_stability(s2, n, d, l.Hard), i.difficulty = this.algorithm.next_difficulty(s2, l.Good), i.stability = this.algorithm.next_recall_stability(s2, n, d, l.Good), r.difficulty = this.algorithm.next_difficulty(s2, l.Easy), r.stability = this.algorithm.next_recall_stability(s2, n, d, l.Easy);
    }
    next_interval(t, e, i, r, s2) {
      let n, d, o, c6;
      n = this.algorithm.next_interval(t.stability, s2), d = this.algorithm.next_interval(e.stability, s2), o = this.algorithm.next_interval(i.stability, s2), c6 = this.algorithm.next_interval(r.stability, s2), n = Math.min(n, d), d = Math.max(d, n + 1), o = Math.max(o, d + 1), c6 = Math.max(c6, o + 1), t.scheduled_days = n, t.due = this.review_time.scheduler(n, true), e.scheduled_days = d, e.due = this.review_time.scheduler(d, true), i.scheduled_days = o, i.due = this.review_time.scheduler(o, true), r.scheduled_days = c6, r.due = this.review_time.scheduler(c6, true);
    }
    next_state(t, e, i, r) {
      t.state = u4.Review, t.learning_steps = 0, e.state = u4.Review, e.learning_steps = 0, i.state = u4.Review, i.learning_steps = 0, r.state = u4.Review, r.learning_steps = 0;
    }
    update_next(t, e, i, r) {
      const s2 = { card: t, log: this.buildLog(l.Again) }, n = { card: e, log: super.buildLog(l.Hard) }, d = { card: i, log: super.buildLog(l.Good) }, o = { card: r, log: super.buildLog(l.Easy) };
      this.next.set(l.Again, s2), this.next.set(l.Hard, n), this.next.set(l.Good, d), this.next.set(l.Easy, o);
    }
  };
  var gt = class {
    fsrs;
    constructor(t) {
      this.fsrs = t;
    }
    replay(t, e, i) {
      return this.fsrs.next(t, e, i);
    }
    handleManualRating(t, e, i, r, s2, n, d) {
      if (typeof e > "u") throw new Error("reschedule: state is required for manual rating");
      let o, c6;
      if (e === u4.New) o = { rating: l.Manual, state: e, due: d ?? i, stability: t.stability, difficulty: t.difficulty, elapsed_days: r, last_elapsed_days: t.elapsed_days, scheduled_days: t.scheduled_days, learning_steps: t.learning_steps, review: i }, c6 = E2(i), c6.last_review = i;
      else {
        if (typeof d > "u") throw new Error("reschedule: due is required for manual rating");
        const f = d.diff(i, "days");
        o = { rating: l.Manual, state: t.state, due: t.last_review || t.due, stability: t.stability, difficulty: t.difficulty, elapsed_days: r, last_elapsed_days: t.elapsed_days, scheduled_days: t.scheduled_days, learning_steps: t.learning_steps, review: i }, c6 = { ...t, state: e, due: d, last_review: i, stability: s2 || t.stability, difficulty: n || t.difficulty, elapsed_days: r, scheduled_days: f, reps: t.reps + 1 };
      }
      return { card: c6, log: o };
    }
    reschedule(t, e) {
      const i = [];
      let r = E2(t.due);
      for (const s2 of e) {
        let n;
        if (s2.review = h.time(s2.review), s2.rating === l.Manual) {
          let d = 0;
          r.state !== u4.New && r.last_review && (d = s2.review.diff(r.last_review, "days")), n = this.handleManualRating(r, s2.state, s2.review, d, s2.stability, s2.difficulty, s2.due ? h.time(s2.due) : void 0);
        } else n = this.replay(r, s2.review, s2.rating);
        i.push(n), r = n.card;
      }
      return i;
    }
    calculateManualRecord(t, e, i, r) {
      if (!i) return null;
      const { card: s2, log: n } = i, d = h.card(t);
      return d.due.getTime() === s2.due.getTime() ? null : (d.scheduled_days = s2.due.diff(d.due, "days"), this.handleManualRating(d, s2.state, h.time(e), n.elapsed_days, r ? s2.stability : void 0, r ? s2.difficulty : void 0, s2.due));
    }
  };
  var it = class extends J {
    strategyHandler = /* @__PURE__ */ new Map();
    Scheduler;
    constructor(t) {
      super(t);
      const { enable_short_term: e } = this.parameters;
      this.Scheduler = e ? tt : et;
    }
    params_handler_proxy() {
      const t = this;
      return { set: function(e, i, r) {
        return i === "request_retention" && Number.isFinite(r) ? t.intervalModifier = t.calculate_interval_modifier(Number(r)) : i === "enable_short_term" ? t.Scheduler = r === true ? tt : et : i === "w" && (r = M2(S(r), e.relearning_steps.length), t.forgetting_curve = R.bind(this, r), t.intervalModifier = t.calculate_interval_modifier(Number(e.request_retention))), Reflect.set(e, i, r), true;
      } };
    }
    useStrategy(t, e) {
      return this.strategyHandler.set(t, e), this;
    }
    clearStrategy(t) {
      return t ? this.strategyHandler.delete(t) : this.strategyHandler.clear(), this;
    }
    getScheduler(t, e) {
      const i = this.strategyHandler.get(b.SCHEDULER) || this.Scheduler;
      return new i(t, e, this, this.strategyHandler);
    }
    repeat(t, e, i) {
      const r = this.getScheduler(t, e).preview();
      return i && typeof i == "function" ? i(r) : r;
    }
    next(t, e, i, r) {
      const s2 = this.getScheduler(t, e), n = h.rating(i);
      if (n === l.Manual) throw new Error("Cannot review a manual rating");
      const d = s2.review(n);
      return r && typeof r == "function" ? r(d) : d;
    }
    get_retrievability(t, e, i = true) {
      const r = h.card(t);
      e = e ? h.time(e) : /* @__PURE__ */ new Date();
      const s2 = r.state !== u4.New ? Math.max(e.diff(r.last_review, "days"), 0) : 0, n = r.state !== u4.New ? this.forgetting_curve(s2, +r.stability.toFixed(8)) : 0;
      return i ? `${(n * 100).toFixed(2)}%` : n;
    }
    rollback(t, e, i) {
      const r = h.card(t), s2 = h.review_log(e);
      if (s2.rating === l.Manual) throw new Error("Cannot rollback a manual rating");
      let n, d, o;
      switch (s2.state) {
        case u4.New:
          n = s2.due, d = void 0, o = 0;
          break;
        case u4.Learning:
        case u4.Relearning:
        case u4.Review:
          n = s2.review, d = s2.due, o = r.lapses - (s2.rating === l.Again && s2.state === u4.Review ? 1 : 0);
          break;
      }
      const c6 = { ...r, due: n, stability: s2.stability, difficulty: s2.difficulty, elapsed_days: s2.last_elapsed_days, scheduled_days: s2.scheduled_days, reps: Math.max(0, r.reps - 1), lapses: Math.max(0, o), learning_steps: s2.learning_steps, state: s2.state, last_review: d };
      return i && typeof i == "function" ? i(c6) : c6;
    }
    forget(t, e, i = false, r) {
      const s2 = h.card(t);
      e = h.time(e);
      const n = s2.state === u4.New ? 0 : e.diff(s2.last_review, "days"), d = { rating: l.Manual, state: s2.state, due: s2.due, stability: s2.stability, difficulty: s2.difficulty, elapsed_days: 0, last_elapsed_days: s2.elapsed_days, scheduled_days: n, learning_steps: s2.learning_steps, review: e }, o = { card: { ...s2, due: e, stability: 0, difficulty: 0, elapsed_days: 0, scheduled_days: 0, reps: i ? 0 : s2.reps, lapses: i ? 0 : s2.lapses, learning_steps: 0, state: u4.New, last_review: s2.last_review }, log: d };
      return r && typeof r == "function" ? r(o) : o;
    }
    reschedule(t, e = [], i = {}) {
      const { recordLogHandler: r, reviewsOrderBy: s2, skipManual: n = true, now: d = /* @__PURE__ */ new Date(), update_memory_state: o = false } = i;
      s2 && typeof s2 == "function" && e.sort(s2), n && (e = e.filter((w) => w.rating !== l.Manual));
      const c6 = new gt(this), f = c6.reschedule(i.first_card || E2(), e), g = f.length, p = h.card(t), _25 = c6.calculateManualRecord(p, d, g ? f[g - 1] : void 0, o);
      return r && typeof r == "function" ? { collections: f.map(r), reschedule_item: _25 ? r(_25) : null } : { collections: f, reschedule_item: _25 };
    }
  };
  var yt = (a4) => new it(a4 || {});

  // node_modules/@bufbuild/protobuf/dist/esm/private/assert.js
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  var FLOAT32_MAX = 34028234663852886e22;
  var FLOAT32_MIN = -34028234663852886e22;
  var UINT32_MAX = 4294967295;
  var INT32_MAX = 2147483647;
  var INT32_MIN = -2147483648;
  function assertInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw new Error("invalid int 32: " + arg);
  }
  function assertUInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw new Error("invalid uint 32: " + arg);
  }
  function assertFloat32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg))
      return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
      throw new Error("invalid float 32: " + arg);
  }

  // node_modules/@bufbuild/protobuf/dist/esm/private/enum.js
  var enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
  function getEnumType(enumObject) {
    const t = enumObject[enumTypeSymbol];
    assert(t, "missing enum type on enum object");
    return t;
  }
  function setEnumType(enumObject, typeName, values2, opt) {
    enumObject[enumTypeSymbol] = makeEnumType(typeName, values2.map((v3) => ({
      no: v3.no,
      name: v3.name,
      localName: enumObject[v3.no]
    })), opt);
  }
  function makeEnumType(typeName, values2, _opt) {
    const names = /* @__PURE__ */ Object.create(null);
    const numbers2 = /* @__PURE__ */ Object.create(null);
    const normalValues = [];
    for (const value of values2) {
      const n = normalizeEnumValue(value);
      normalValues.push(n);
      names[value.name] = n;
      numbers2[value.no] = n;
    }
    return {
      typeName,
      values: normalValues,
      // We do not surface options at this time
      // options: opt?.options ?? Object.create(null),
      findName(name) {
        return names[name];
      },
      findNumber(no) {
        return numbers2[no];
      }
    };
  }
  function makeEnum(typeName, values2, opt) {
    const enumObject = {};
    for (const value of values2) {
      const n = normalizeEnumValue(value);
      enumObject[n.localName] = n.no;
      enumObject[n.no] = n.localName;
    }
    setEnumType(enumObject, typeName, values2, opt);
    return enumObject;
  }
  function normalizeEnumValue(value) {
    if ("localName" in value) {
      return value;
    }
    return Object.assign(Object.assign({}, value), { localName: value.name });
  }

  // node_modules/@bufbuild/protobuf/dist/esm/message.js
  var Message = class {
    /**
     * Compare with a message of the same type.
     * Note that this function disregards extensions and unknown fields.
     */
    equals(other2) {
      return this.getType().runtime.util.equals(this.getType(), this, other2);
    }
    /**
     * Create a deep copy.
     */
    clone() {
      return this.getType().runtime.util.clone(this);
    }
    /**
     * Parse from binary data, merging fields.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    fromBinary(bytes, options) {
      const type2 = this.getType(), format2 = type2.runtime.bin, opt = format2.makeReadOptions(options);
      format2.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
      return this;
    }
    /**
     * Parse a message from a JSON value.
     */
    fromJson(jsonValue, options) {
      const type2 = this.getType(), format2 = type2.runtime.json, opt = format2.makeReadOptions(options);
      format2.readMessage(type2, jsonValue, opt, this);
      return this;
    }
    /**
     * Parse a message from a JSON string.
     */
    fromJsonString(jsonString, options) {
      let json;
      try {
        json = JSON.parse(jsonString);
      } catch (e) {
        throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e instanceof Error ? e.message : String(e)}`);
      }
      return this.fromJson(json, options);
    }
    /**
     * Serialize the message to binary data.
     */
    toBinary(options) {
      const type2 = this.getType(), bin2 = type2.runtime.bin, opt = bin2.makeWriteOptions(options), writer = opt.writerFactory();
      bin2.writeMessage(this, writer, opt);
      return writer.finish();
    }
    /**
     * Serialize the message to a JSON value, a JavaScript value that can be
     * passed to JSON.stringify().
     */
    toJson(options) {
      const type2 = this.getType(), json = type2.runtime.json, opt = json.makeWriteOptions(options);
      return json.writeMessage(this, opt);
    }
    /**
     * Serialize the message to a JSON string.
     */
    toJsonString(options) {
      var _a;
      const value = this.toJson(options);
      return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Override for serialization behavior. This will be invoked when calling
     * JSON.stringify on this message (i.e. JSON.stringify(msg)).
     *
     * Note that this will not serialize google.protobuf.Any with a packed
     * message because the protobuf JSON format specifies that it needs to be
     * unpacked, and this is only possible with a type registry to look up the
     * message type.  As a result, attempting to serialize a message with this
     * type will throw an Error.
     *
     * This method is protected because you should not need to invoke it
     * directly -- instead use JSON.stringify or toJsonString for
     * stringified JSON.  Alternatively, if actual JSON is desired, you should
     * use toJson.
     */
    toJSON() {
      return this.toJson({
        emitDefaultValues: true
      });
    }
    /**
     * Retrieve the MessageType of this message - a singleton that represents
     * the protobuf message declaration and provides metadata for reflection-
     * based operations.
     */
    getType() {
      return Object.getPrototypeOf(this).constructor;
    }
  };

  // node_modules/@bufbuild/protobuf/dist/esm/private/message-type.js
  function makeMessageType(runtime, typeName, fields, opt) {
    var _a;
    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(".") + 1);
    const type2 = {
      [localName]: function(data2) {
        runtime.util.initFields(this);
        runtime.util.initPartial(data2, this);
      }
    }[localName];
    Object.setPrototypeOf(type2.prototype, new Message());
    Object.assign(type2, {
      runtime,
      typeName,
      fields: runtime.util.newFieldList(fields),
      fromBinary(bytes, options) {
        return new type2().fromBinary(bytes, options);
      },
      fromJson(jsonValue, options) {
        return new type2().fromJson(jsonValue, options);
      },
      fromJsonString(jsonString, options) {
        return new type2().fromJsonString(jsonString, options);
      },
      equals(a4, b10) {
        return runtime.util.equals(type2, a4, b10);
      }
    });
    return type2;
  }

  // node_modules/@bufbuild/protobuf/dist/esm/google/varint.js
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
      let b10 = this.buf[this.pos++];
      lowBits |= (b10 & 127) << shift;
      if ((b10 & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 15) << 28;
    highBits = (middleByte & 112) >> 4;
    if ((middleByte & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
      let b10 = this.buf[this.pos++];
      highBits |= (b10 & 127) << shift;
      if ((b10 & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error("invalid varint");
  }
  function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
      const shift = lo >>> i;
      const hasNext = !(shift >>> 7 == 0 && hi == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
    if (!hasMoreBits) {
      return;
    }
    for (let i = 3; i < 31; i = i + 7) {
      const shift = hi >>> i;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push(hi >>> 31 & 1);
  }
  var TWO_PWR_32_DBL = 4294967296;
  function int64FromString(dec) {
    const minus = dec[0] === "-";
    if (minus) {
      dec = dec.slice(1);
    }
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base;
      lowBits = lowBits * base + digit1e6;
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate2(lowBits, highBits) : newBits(lowBits, highBits);
  }
  function int64ToString(lo, hi) {
    let bits = newBits(lo, hi);
    const negative = bits.hi & 2147483648;
    if (negative) {
      bits = negate2(bits.lo, bits.hi);
    }
    const result = uInt64ToString(bits.lo, bits.hi);
    return negative ? "-" + result : result;
  }
  function uInt64ToString(lo, hi) {
    ({ lo, hi } = toUnsigned(lo, hi));
    if (hi <= 2097151) {
      return String(TWO_PWR_32_DBL * hi + lo);
    }
    const low = lo & 16777215;
    const mid = (lo >>> 24 | hi << 8) & 16777215;
    const high = hi >> 16 & 65535;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    const base = 1e7;
    if (digitA >= base) {
      digitB += Math.floor(digitA / base);
      digitA %= base;
    }
    if (digitB >= base) {
      digitC += Math.floor(digitB / base);
      digitB %= base;
    }
    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
  }
  function toUnsigned(lo, hi) {
    return { lo: lo >>> 0, hi: hi >>> 0 };
  }
  function newBits(lo, hi) {
    return { lo: lo | 0, hi: hi | 0 };
  }
  function negate2(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) {
      lowBits = ~lowBits + 1;
    } else {
      highBits += 1;
    }
    return newBits(lowBits, highBits);
  }
  var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
    const partial = String(digit1e7);
    return "0000000".slice(partial.length) + partial;
  };
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127) {
        bytes.push(value & 127 | 128);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i = 0; i < 9; i++) {
        bytes.push(value & 127 | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  function varint32read() {
    let b10 = this.buf[this.pos++];
    let result = b10 & 127;
    if ((b10 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b10 = this.buf[this.pos++];
    result |= (b10 & 127) << 7;
    if ((b10 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b10 = this.buf[this.pos++];
    result |= (b10 & 127) << 14;
    if ((b10 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b10 = this.buf[this.pos++];
    result |= (b10 & 127) << 21;
    if ((b10 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b10 = this.buf[this.pos++];
    result |= (b10 & 15) << 28;
    for (let readBytes = 5; (b10 & 128) !== 0 && readBytes < 10; readBytes++)
      b10 = this.buf[this.pos++];
    if ((b10 & 128) != 0)
      throw new Error("invalid varint");
    this.assertBounds();
    return result >>> 0;
  }

  // node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
  function makeInt64Support() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
    if (ok) {
      const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
      return {
        zero: BigInt(0),
        supported: true,
        parse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > MAX || bi < MIN) {
            throw new Error(`int64 invalid: ${value}`);
          }
          return bi;
        },
        uParse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > UMAX || bi < UMIN) {
            throw new Error(`uint64 invalid: ${value}`);
          }
          return bi;
        },
        enc(value) {
          dv.setBigInt64(0, this.parse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        uEnc(value) {
          dv.setBigInt64(0, this.uParse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        dec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigInt64(0, true);
        },
        uDec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigUint64(0, true);
        }
      };
    }
    const assertInt64String = (value) => assert(/^-?[0-9]+$/.test(value), `int64 invalid: ${value}`);
    const assertUInt64String = (value) => assert(/^[0-9]+$/.test(value), `uint64 invalid: ${value}`);
    return {
      zero: "0",
      supported: false,
      parse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return value;
      },
      uParse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return value;
      },
      enc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return int64FromString(value);
      },
      uEnc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return int64FromString(value);
      },
      dec(lo, hi) {
        return int64ToString(lo, hi);
      },
      uDec(lo, hi) {
        return uInt64ToString(lo, hi);
      }
    };
  }
  var protoInt64 = makeInt64Support();

  // node_modules/@bufbuild/protobuf/dist/esm/scalar.js
  var ScalarType;
  (function(ScalarType2) {
    ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
    ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
    ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
    ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
    ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
    ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
    ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
    ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
    ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
    ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
    ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
    ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
    ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
    ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
    ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
  })(ScalarType || (ScalarType = {}));
  var LongType;
  (function(LongType2) {
    LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
    LongType2[LongType2["STRING"] = 1] = "STRING";
  })(LongType || (LongType = {}));

  // node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js
  function scalarEquals(type2, a4, b10) {
    if (a4 === b10) {
      return true;
    }
    if (type2 == ScalarType.BYTES) {
      if (!(a4 instanceof Uint8Array) || !(b10 instanceof Uint8Array)) {
        return false;
      }
      if (a4.length !== b10.length) {
        return false;
      }
      for (let i = 0; i < a4.length; i++) {
        if (a4[i] !== b10[i]) {
          return false;
        }
      }
      return true;
    }
    switch (type2) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return a4 == b10;
    }
    return false;
  }
  function scalarZeroValue(type2, longType) {
    switch (type2) {
      case ScalarType.BOOL:
        return false;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return longType == 0 ? protoInt64.zero : "0";
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return 0;
      case ScalarType.BYTES:
        return new Uint8Array(0);
      case ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  function isScalarZeroValue(type2, value) {
    switch (type2) {
      case ScalarType.BOOL:
        return value === false;
      case ScalarType.STRING:
        return value === "";
      case ScalarType.BYTES:
        return value instanceof Uint8Array && !value.byteLength;
      default:
        return value == 0;
    }
  }

  // node_modules/@bufbuild/protobuf/dist/esm/binary-encoding.js
  var WireType;
  (function(WireType2) {
    WireType2[WireType2["Varint"] = 0] = "Varint";
    WireType2[WireType2["Bit64"] = 1] = "Bit64";
    WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
    WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
    WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
    WireType2[WireType2["Bit32"] = 5] = "Bit32";
  })(WireType || (WireType = {}));
  var BinaryWriter = class {
    constructor(textEncoder) {
      this.stack = [];
      this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
      this.chunks = [];
      this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let len = 0;
      for (let i = 0; i < this.chunks.length; i++)
        len += this.chunks[i].length;
      let bytes = new Uint8Array(len);
      let offset = 0;
      for (let i = 0; i < this.chunks.length; i++) {
        bytes.set(this.chunks[i], offset);
        offset += this.chunks[i].length;
      }
      this.chunks = [];
      return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
      this.stack.push({ chunks: this.chunks, buf: this.buf });
      this.chunks = [];
      this.buf = [];
      return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
      let chunk = this.finish();
      let prev = this.stack.pop();
      if (!prev)
        throw new Error("invalid state, fork stack empty");
      this.chunks = prev.chunks;
      this.buf = prev.buf;
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type2) {
      return this.uint32((fieldNo << 3 | type2) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
      if (this.buf.length) {
        this.chunks.push(new Uint8Array(this.buf));
        this.buf = [];
      }
      this.chunks.push(chunk);
      return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
      assertUInt32(value);
      while (value > 127) {
        this.buf.push(value & 127 | 128);
        value = value >>> 7;
      }
      this.buf.push(value);
      return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
      assertInt32(value);
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
      this.buf.push(value ? 1 : 0);
      return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
      this.uint32(value.byteLength);
      return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
      let chunk = this.textEncoder.encode(value);
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
      assertFloat32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setFloat32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
      let chunk = new Uint8Array(8);
      new DataView(chunk.buffer).setFloat64(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
      assertUInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setUint32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
      assertInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setInt32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
      assertInt32(value);
      value = (value << 1 ^ value >> 31) >>> 0;
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
      let tc = protoInt64.enc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
      let tc = protoInt64.enc(value), sign3 = tc.hi >> 31, lo = tc.lo << 1 ^ sign3, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign3;
      varint64write(lo, hi, this.buf);
      return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
      let tc = protoInt64.uEnc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
  };
  var BinaryReader = class {
    constructor(buf, textDecoder) {
      this.varint64 = varint64read;
      this.uint32 = varint32read;
      this.buf = buf;
      this.len = buf.length;
      this.pos = 0;
      this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
      let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5)
        throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType];
    }
    /**
     * Skip one element and return the skipped data.
     *
     * When skipping StartGroup, provide the tags field number to check for
     * matching field number in the EndGroup tag.
     */
    skip(wireType, fieldNo) {
      let start2 = this.pos;
      switch (wireType) {
        case WireType.Varint:
          while (this.buf[this.pos++] & 128) {
          }
          break;
        // eslint-disable-next-line
        // @ts-ignore TS7029: Fallthrough case in switch
        case WireType.Bit64:
          this.pos += 4;
        // eslint-disable-next-line
        // @ts-ignore TS7029: Fallthrough case in switch
        case WireType.Bit32:
          this.pos += 4;
          break;
        case WireType.LengthDelimited:
          let len = this.uint32();
          this.pos += len;
          break;
        case WireType.StartGroup:
          for (; ; ) {
            const [fn, wt] = this.tag();
            if (wt === WireType.EndGroup) {
              if (fieldNo !== void 0 && fn !== fieldNo) {
                throw new Error("invalid end group tag");
              }
              break;
            }
            this.skip(wt, fn);
          }
          break;
        default:
          throw new Error("cant skip wire type " + wireType);
      }
      this.assertBounds();
      return this.buf.subarray(start2, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
      if (this.pos > this.len)
        throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
      return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
      let zze = this.uint32();
      return zze >>> 1 ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
      return protoInt64.dec(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
      return protoInt64.uDec(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
      let [lo, hi] = this.varint64();
      let s2 = -(lo & 1);
      lo = (lo >>> 1 | (hi & 1) << 31) ^ s2;
      hi = hi >>> 1 ^ s2;
      return protoInt64.dec(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
      let [lo, hi] = this.varint64();
      return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
      return protoInt64.uDec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
      return protoInt64.dec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
      let len = this.uint32(), start2 = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start2, start2 + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  };

  // node_modules/@bufbuild/protobuf/dist/esm/private/extensions.js
  function makeExtension(runtime, typeName, extendee, field) {
    let fi;
    return {
      typeName,
      extendee,
      get field() {
        if (!fi) {
          const i = typeof field == "function" ? field() : field;
          i.name = typeName.split(".").pop();
          i.jsonName = `[${typeName}]`;
          fi = runtime.util.newFieldList([i]).list()[0];
        }
        return fi;
      },
      runtime
    };
  }
  function createExtensionContainer(extension) {
    const localName = extension.field.localName;
    const container = /* @__PURE__ */ Object.create(null);
    container[localName] = initExtensionField(extension);
    return [container, () => container[localName]];
  }
  function initExtensionField(ext) {
    const field = ext.field;
    if (field.repeated) {
      return [];
    }
    if (field.default !== void 0) {
      return field.default;
    }
    switch (field.kind) {
      case "enum":
        return field.T.values[0].no;
      case "scalar":
        return scalarZeroValue(field.T, field.L);
      case "message":
        const T2 = field.T, value = new T2();
        return T2.fieldWrapper ? T2.fieldWrapper.unwrapField(value) : value;
      case "map":
        throw "map fields are not allowed to be extensions";
    }
  }
  function filterUnknownFields(unknownFields, field) {
    if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
      for (let i = unknownFields.length - 1; i >= 0; --i) {
        if (unknownFields[i].no == field.no) {
          return [unknownFields[i]];
        }
      }
      return [];
    }
    return unknownFields.filter((uf) => uf.no === field.no);
  }

  // node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js
  var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  var decTable = [];
  for (let i = 0; i < encTable.length; i++)
    decTable[encTable[i].charCodeAt(0)] = i;
  decTable["-".charCodeAt(0)] = encTable.indexOf("+");
  decTable["_".charCodeAt(0)] = encTable.indexOf("/");
  var protoBase64 = {
    /**
     * Decodes a base64 string to a byte array.
     *
     * - ignores white-space, including line breaks and tabs
     * - allows inner padding (can decode concatenated base64 strings)
     * - does not require padding
     * - understands base64url encoding:
     *   "-" instead of "+",
     *   "_" instead of "/",
     *   no padding
     */
    dec(base64Str) {
      let es = base64Str.length * 3 / 4;
      if (base64Str[base64Str.length - 2] == "=")
        es -= 2;
      else if (base64Str[base64Str.length - 1] == "=")
        es -= 1;
      let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b10, p = 0;
      for (let i = 0; i < base64Str.length; i++) {
        b10 = decTable[base64Str.charCodeAt(i)];
        if (b10 === void 0) {
          switch (base64Str[i]) {
            // @ts-ignore TS7029: Fallthrough case in switch
            case "=":
              groupPos = 0;
            // reset state when padding found
            // @ts-ignore TS7029: Fallthrough case in switch
            case "\n":
            case "\r":
            case "	":
            case " ":
              continue;
            // skip white-space, and padding
            default:
              throw Error("invalid base64 string.");
          }
        }
        switch (groupPos) {
          case 0:
            p = b10;
            groupPos = 1;
            break;
          case 1:
            bytes[bytePos++] = p << 2 | (b10 & 48) >> 4;
            p = b10;
            groupPos = 2;
            break;
          case 2:
            bytes[bytePos++] = (p & 15) << 4 | (b10 & 60) >> 2;
            p = b10;
            groupPos = 3;
            break;
          case 3:
            bytes[bytePos++] = (p & 3) << 6 | b10;
            groupPos = 0;
            break;
        }
      }
      if (groupPos == 1)
        throw Error("invalid base64 string.");
      return bytes.subarray(0, bytePos);
    },
    /**
     * Encode a byte array to a base64 string.
     */
    enc(bytes) {
      let base64 = "", groupPos = 0, b10, p = 0;
      for (let i = 0; i < bytes.length; i++) {
        b10 = bytes[i];
        switch (groupPos) {
          case 0:
            base64 += encTable[b10 >> 2];
            p = (b10 & 3) << 4;
            groupPos = 1;
            break;
          case 1:
            base64 += encTable[p | b10 >> 4];
            p = (b10 & 15) << 2;
            groupPos = 2;
            break;
          case 2:
            base64 += encTable[p | b10 >> 6];
            base64 += encTable[b10 & 63];
            groupPos = 0;
            break;
        }
      }
      if (groupPos) {
        base64 += encTable[p];
        base64 += "=";
        if (groupPos == 1)
          base64 += "=";
      }
      return base64;
    }
  };

  // node_modules/@bufbuild/protobuf/dist/esm/extension-accessor.js
  function getExtension(message, extension, options) {
    assertExtendee(extension, message);
    const opt = extension.runtime.bin.makeReadOptions(options);
    const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);
    const [container, get5] = createExtensionContainer(extension);
    for (const uf of ufs) {
      extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
    }
    return get5();
  }
  function setExtension(message, extension, value, options) {
    assertExtendee(extension, message);
    const readOpt = extension.runtime.bin.makeReadOptions(options);
    const writeOpt = extension.runtime.bin.makeWriteOptions(options);
    if (hasExtension(message, extension)) {
      const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf) => uf.no != extension.field.no);
      message.getType().runtime.bin.discardUnknownFields(message);
      for (const uf of ufs) {
        message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);
      }
    }
    const writer = writeOpt.writerFactory();
    let f = extension.field;
    if (!f.opt && !f.repeated && (f.kind == "enum" || f.kind == "scalar")) {
      f = Object.assign(Object.assign({}, extension.field), { opt: true });
    }
    extension.runtime.bin.writeField(f, value, writer, writeOpt);
    const reader = readOpt.readerFactory(writer.finish());
    while (reader.pos < reader.len) {
      const [no, wireType] = reader.tag();
      const data2 = reader.skip(wireType, no);
      message.getType().runtime.bin.onUnknownField(message, no, wireType, data2);
    }
  }
  function hasExtension(message, extension) {
    const messageType = message.getType();
    return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf) => uf.no == extension.field.no);
  }
  function assertExtendee(extension, message) {
    assert(extension.extendee.typeName == message.getType().typeName, `extension ${extension.typeName} can only be applied to message ${extension.extendee.typeName}`);
  }

  // node_modules/@bufbuild/protobuf/dist/esm/private/reflect.js
  function isFieldSet(field, target) {
    const localName = field.localName;
    if (field.repeated) {
      return target[localName].length > 0;
    }
    if (field.oneof) {
      return target[field.oneof.localName].case === localName;
    }
    switch (field.kind) {
      case "enum":
      case "scalar":
        if (field.opt || field.req) {
          return target[localName] !== void 0;
        }
        if (field.kind == "enum") {
          return target[localName] !== field.T.values[0].no;
        }
        return !isScalarZeroValue(field.T, target[localName]);
      case "message":
        return target[localName] !== void 0;
      case "map":
        return Object.keys(target[localName]).length > 0;
    }
  }
  function clearField(field, target) {
    const localName = field.localName;
    const implicitPresence = !field.opt && !field.req;
    if (field.repeated) {
      target[localName] = [];
    } else if (field.oneof) {
      target[field.oneof.localName] = { case: void 0 };
    } else {
      switch (field.kind) {
        case "map":
          target[localName] = {};
          break;
        case "enum":
          target[localName] = implicitPresence ? field.T.values[0].no : void 0;
          break;
        case "scalar":
          target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
          break;
        case "message":
          target[localName] = void 0;
          break;
      }
    }
  }

  // node_modules/@bufbuild/protobuf/dist/esm/is-message.js
  function isMessage(arg, type2) {
    if (arg === null || typeof arg != "object") {
      return false;
    }
    if (!Object.getOwnPropertyNames(Message.prototype).every((m4) => m4 in arg && typeof arg[m4] == "function")) {
      return false;
    }
    const actualType = arg.getType();
    if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
      return false;
    }
    return type2 === void 0 ? true : actualType.typeName == type2.typeName;
  }

  // node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js
  function wrapField(type2, value) {
    if (isMessage(value) || !type2.fieldWrapper) {
      return value;
    }
    return type2.fieldWrapper.wrapField(value);
  }
  var wktWrapperToScalarType = {
    "google.protobuf.DoubleValue": ScalarType.DOUBLE,
    "google.protobuf.FloatValue": ScalarType.FLOAT,
    "google.protobuf.Int64Value": ScalarType.INT64,
    "google.protobuf.UInt64Value": ScalarType.UINT64,
    "google.protobuf.Int32Value": ScalarType.INT32,
    "google.protobuf.UInt32Value": ScalarType.UINT32,
    "google.protobuf.BoolValue": ScalarType.BOOL,
    "google.protobuf.StringValue": ScalarType.STRING,
    "google.protobuf.BytesValue": ScalarType.BYTES
  };

  // node_modules/@bufbuild/protobuf/dist/esm/private/json-format.js
  var jsonReadDefaults = {
    ignoreUnknownFields: false
  };
  var jsonWriteDefaults = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0
  };
  function makeReadOptions(options) {
    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
  }
  function makeWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
  }
  var tokenNull = Symbol();
  var tokenIgnoredUnknownEnum = Symbol();
  function makeJsonFormat() {
    return {
      makeReadOptions,
      makeWriteOptions,
      readMessage(type2, json, options, message) {
        if (json == null || Array.isArray(json) || typeof json != "object") {
          throw new Error(`cannot decode message ${type2.typeName} from JSON: ${debugJsonValue(json)}`);
        }
        message = message !== null && message !== void 0 ? message : new type2();
        const oneofSeen = /* @__PURE__ */ new Map();
        const registry = options.typeRegistry;
        for (const [jsonKey, jsonValue] of Object.entries(json)) {
          const field = type2.fields.findJsonName(jsonKey);
          if (field) {
            if (field.oneof) {
              if (jsonValue === null && field.kind == "scalar") {
                continue;
              }
              const seen = oneofSeen.get(field.oneof);
              if (seen !== void 0) {
                throw new Error(`cannot decode message ${type2.typeName} from JSON: multiple keys for oneof "${field.oneof.name}" present: "${seen}", "${jsonKey}"`);
              }
              oneofSeen.set(field.oneof, jsonKey);
            }
            readField(message, jsonValue, field, options, type2);
          } else {
            let found = false;
            if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
              const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
              if (ext && ext.extendee.typeName == type2.typeName) {
                found = true;
                const [container, get5] = createExtensionContainer(ext);
                readField(container, jsonValue, ext.field, options, ext);
                setExtension(message, ext, get5(), options);
              }
            }
            if (!found && !options.ignoreUnknownFields) {
              throw new Error(`cannot decode message ${type2.typeName} from JSON: key "${jsonKey}" is unknown`);
            }
          }
        }
        return message;
      },
      writeMessage(message, options) {
        const type2 = message.getType();
        const json = {};
        let field;
        try {
          for (field of type2.fields.byNumber()) {
            if (!isFieldSet(field, message)) {
              if (field.req) {
                throw `required field not set`;
              }
              if (!options.emitDefaultValues) {
                continue;
              }
              if (!canEmitFieldDefaultValue(field)) {
                continue;
              }
            }
            const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
            const jsonValue = writeField(field, value, options);
            if (jsonValue !== void 0) {
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
            }
          }
          const registry = options.typeRegistry;
          if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
            for (const uf of type2.runtime.bin.listUnknownFields(message)) {
              const ext = registry.findExtensionFor(type2.typeName, uf.no);
              if (ext && hasExtension(message, ext)) {
                const value = getExtension(message, ext, options);
                const jsonValue = writeField(ext.field, value, options);
                if (jsonValue !== void 0) {
                  json[ext.field.jsonName] = jsonValue;
                }
              }
            }
          }
        } catch (e) {
          const m4 = field ? `cannot encode field ${type2.typeName}.${field.name} to JSON` : `cannot encode message ${type2.typeName} to JSON`;
          const r = e instanceof Error ? e.message : String(e);
          throw new Error(m4 + (r.length > 0 ? `: ${r}` : ""));
        }
        return json;
      },
      readScalar(type2, json, longType) {
        return readScalar(type2, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
      },
      writeScalar(type2, value, emitDefaultValues) {
        if (value === void 0) {
          return void 0;
        }
        if (emitDefaultValues || isScalarZeroValue(type2, value)) {
          return writeScalar(type2, value);
        }
        return void 0;
      },
      debug: debugJsonValue
    };
  }
  function debugJsonValue(json) {
    if (json === null) {
      return "null";
    }
    switch (typeof json) {
      case "object":
        return Array.isArray(json) ? "array" : "object";
      case "string":
        return json.length > 100 ? "string" : `"${json.split('"').join('\\"')}"`;
      default:
        return String(json);
    }
  }
  function readField(target, jsonValue, field, options, parentType) {
    let localName = field.localName;
    if (field.repeated) {
      assert(field.kind != "map");
      if (jsonValue === null) {
        return;
      }
      if (!Array.isArray(jsonValue)) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
      }
      const targetArray = target[localName];
      for (const jsonItem of jsonValue) {
        if (jsonItem === null) {
          throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`);
        }
        switch (field.kind) {
          case "message":
            targetArray.push(field.T.fromJson(jsonItem, options));
            break;
          case "enum":
            const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetArray.push(enumValue);
            }
            break;
          case "scalar":
            try {
              targetArray.push(readScalar(field.T, jsonItem, field.L, true));
            } catch (e) {
              let m4 = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`;
              if (e instanceof Error && e.message.length > 0) {
                m4 += `: ${e.message}`;
              }
              throw new Error(m4);
            }
            break;
        }
      }
    } else if (field.kind == "map") {
      if (jsonValue === null) {
        return;
      }
      if (typeof jsonValue != "object" || Array.isArray(jsonValue)) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
      }
      const targetMap = target[localName];
      for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
        if (jsonMapValue === null) {
          throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: map value null`);
        }
        let key;
        try {
          key = readMapKey(field.K, jsonMapKey);
        } catch (e) {
          let m4 = `cannot decode map key for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
          if (e instanceof Error && e.message.length > 0) {
            m4 += `: ${e.message}`;
          }
          throw new Error(m4);
        }
        switch (field.V.kind) {
          case "message":
            targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
            break;
          case "enum":
            const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetMap[key] = enumValue;
            }
            break;
          case "scalar":
            try {
              targetMap[key] = readScalar(field.V.T, jsonMapValue, LongType.BIGINT, true);
            } catch (e) {
              let m4 = `cannot decode map value for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
              if (e instanceof Error && e.message.length > 0) {
                m4 += `: ${e.message}`;
              }
              throw new Error(m4);
            }
            break;
        }
      }
    } else {
      if (field.oneof) {
        target = target[field.oneof.localName] = { case: localName };
        localName = "value";
      }
      switch (field.kind) {
        case "message":
          const messageType = field.T;
          if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
            return;
          }
          let currentValue = target[localName];
          if (isMessage(currentValue)) {
            currentValue.fromJson(jsonValue, options);
          } else {
            target[localName] = currentValue = messageType.fromJson(jsonValue, options);
            if (messageType.fieldWrapper && !field.oneof) {
              target[localName] = messageType.fieldWrapper.unwrapField(currentValue);
            }
          }
          break;
        case "enum":
          const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
          switch (enumValue) {
            case tokenNull:
              clearField(field, target);
              break;
            case tokenIgnoredUnknownEnum:
              break;
            default:
              target[localName] = enumValue;
              break;
          }
          break;
        case "scalar":
          try {
            const scalarValue = readScalar(field.T, jsonValue, field.L, false);
            switch (scalarValue) {
              case tokenNull:
                clearField(field, target);
                break;
              default:
                target[localName] = scalarValue;
                break;
            }
          } catch (e) {
            let m4 = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
            if (e instanceof Error && e.message.length > 0) {
              m4 += `: ${e.message}`;
            }
            throw new Error(m4);
          }
          break;
      }
    }
  }
  function readMapKey(type2, json) {
    if (type2 === ScalarType.BOOL) {
      switch (json) {
        case "true":
          json = true;
          break;
        case "false":
          json = false;
          break;
      }
    }
    return readScalar(type2, json, LongType.BIGINT, true).toString();
  }
  function readScalar(type2, json, longType, nullAsZeroValue) {
    if (json === null) {
      if (nullAsZeroValue) {
        return scalarZeroValue(type2, longType);
      }
      return tokenNull;
    }
    switch (type2) {
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        if (json === "NaN")
          return Number.NaN;
        if (json === "Infinity")
          return Number.POSITIVE_INFINITY;
        if (json === "-Infinity")
          return Number.NEGATIVE_INFINITY;
        if (json === "") {
          break;
        }
        if (typeof json == "string" && json.trim().length !== json.length) {
          break;
        }
        if (typeof json != "string" && typeof json != "number") {
          break;
        }
        const float = Number(json);
        if (Number.isNaN(float)) {
          break;
        }
        if (!Number.isFinite(float)) {
          break;
        }
        if (type2 == ScalarType.FLOAT)
          assertFloat32(float);
        return float;
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        let int32;
        if (typeof json == "number")
          int32 = json;
        else if (typeof json == "string" && json.length > 0) {
          if (json.trim().length === json.length)
            int32 = Number(json);
        }
        if (int32 === void 0)
          break;
        if (type2 == ScalarType.UINT32 || type2 == ScalarType.FIXED32)
          assertUInt32(int32);
        else
          assertInt32(int32);
        return int32;
      // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        if (typeof json != "number" && typeof json != "string")
          break;
        const long = protoInt64.parse(json);
        return longType ? long.toString() : long;
      case ScalarType.FIXED64:
      case ScalarType.UINT64:
        if (typeof json != "number" && typeof json != "string")
          break;
        const uLong = protoInt64.uParse(json);
        return longType ? uLong.toString() : uLong;
      // bool:
      case ScalarType.BOOL:
        if (typeof json !== "boolean")
          break;
        return json;
      // string:
      case ScalarType.STRING:
        if (typeof json !== "string") {
          break;
        }
        try {
          encodeURIComponent(json);
        } catch (e) {
          throw new Error("invalid UTF8");
        }
        return json;
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        if (json === "")
          return new Uint8Array(0);
        if (typeof json !== "string")
          break;
        return protoBase64.dec(json);
    }
    throw new Error();
  }
  function readEnum(type2, json, ignoreUnknownFields, nullAsZeroValue) {
    if (json === null) {
      if (type2.typeName == "google.protobuf.NullValue") {
        return 0;
      }
      return nullAsZeroValue ? type2.values[0].no : tokenNull;
    }
    switch (typeof json) {
      case "number":
        if (Number.isInteger(json)) {
          return json;
        }
        break;
      case "string":
        const value = type2.findName(json);
        if (value !== void 0) {
          return value.no;
        }
        if (ignoreUnknownFields) {
          return tokenIgnoredUnknownEnum;
        }
        break;
    }
    throw new Error(`cannot decode enum ${type2.typeName} from JSON: ${debugJsonValue(json)}`);
  }
  function canEmitFieldDefaultValue(field) {
    if (field.repeated || field.kind == "map") {
      return true;
    }
    if (field.oneof) {
      return false;
    }
    if (field.kind == "message") {
      return false;
    }
    if (field.opt || field.req) {
      return false;
    }
    return true;
  }
  function writeField(field, value, options) {
    if (field.kind == "map") {
      assert(typeof value == "object" && value != null);
      const jsonObj = {};
      const entries = Object.entries(value);
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeScalar(field.V.T, entryValue);
          }
          break;
        case "message":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = entryValue.toJson(options);
          }
          break;
        case "enum":
          const enumType = field.V.T;
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);
          }
          break;
      }
      return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
    }
    if (field.repeated) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i = 0; i < value.length; i++) {
            jsonArr.push(writeScalar(field.T, value[i]));
          }
          break;
        case "enum":
          for (let i = 0; i < value.length; i++) {
            jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));
          }
          break;
        case "message":
          for (let i = 0; i < value.length; i++) {
            jsonArr.push(value[i].toJson(options));
          }
          break;
      }
      return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
    }
    switch (field.kind) {
      case "scalar":
        return writeScalar(field.T, value);
      case "enum":
        return writeEnum(field.T, value, options.enumAsInteger);
      case "message":
        return wrapField(field.T, value).toJson(options);
    }
  }
  function writeEnum(type2, value, enumAsInteger) {
    var _a;
    assert(typeof value == "number");
    if (type2.typeName == "google.protobuf.NullValue") {
      return null;
    }
    if (enumAsInteger) {
      return value;
    }
    const val = type2.findNumber(value);
    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value;
  }
  function writeScalar(type2, value) {
    switch (type2) {
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        assert(typeof value == "number");
        return value;
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.FLOAT:
      // assertFloat32(value);
      case ScalarType.DOUBLE:
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      // string:
      case ScalarType.STRING:
        assert(typeof value == "string");
        return value;
      // bool:
      case ScalarType.BOOL:
        assert(typeof value == "boolean");
        return value;
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
        return value.toString();
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        return protoBase64.enc(value);
    }
  }

  // node_modules/@bufbuild/protobuf/dist/esm/private/binary-format.js
  var unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
  var readDefaults = {
    readUnknownFields: true,
    readerFactory: (bytes) => new BinaryReader(bytes)
  };
  var writeDefaults = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter()
  };
  function makeReadOptions2(options) {
    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
  }
  function makeWriteOptions2(options) {
    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
  }
  function makeBinaryFormat() {
    return {
      makeReadOptions: makeReadOptions2,
      makeWriteOptions: makeWriteOptions2,
      listUnknownFields(message) {
        var _a;
        return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];
      },
      discardUnknownFields(message) {
        delete message[unknownFieldsSymbol];
      },
      writeUnknownFields(message, writer) {
        const m4 = message;
        const c6 = m4[unknownFieldsSymbol];
        if (c6) {
          for (const f of c6) {
            writer.tag(f.no, f.wireType).raw(f.data);
          }
        }
      },
      onUnknownField(message, no, wireType, data2) {
        const m4 = message;
        if (!Array.isArray(m4[unknownFieldsSymbol])) {
          m4[unknownFieldsSymbol] = [];
        }
        m4[unknownFieldsSymbol].push({ no, wireType, data: data2 });
      },
      readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
        const type2 = message.getType();
        const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
        let fieldNo, wireType;
        while (reader.pos < end) {
          [fieldNo, wireType] = reader.tag();
          if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
            break;
          }
          const field = type2.fields.find(fieldNo);
          if (!field) {
            const data2 = reader.skip(wireType, fieldNo);
            if (options.readUnknownFields) {
              this.onUnknownField(message, fieldNo, wireType, data2);
            }
            continue;
          }
          readField2(message, reader, field, wireType, options);
        }
        if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
        (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
          throw new Error(`invalid end group tag`);
        }
      },
      readField: readField2,
      writeMessage(message, writer, options) {
        const type2 = message.getType();
        for (const field of type2.fields.byNumber()) {
          if (!isFieldSet(field, message)) {
            if (field.req) {
              throw new Error(`cannot encode field ${type2.typeName}.${field.name} to binary: required field not set`);
            }
            continue;
          }
          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
          writeField2(field, value, writer, options);
        }
        if (options.writeUnknownFields) {
          this.writeUnknownFields(message, writer);
        }
        return writer;
      },
      writeField(field, value, writer, options) {
        if (value === void 0) {
          return void 0;
        }
        writeField2(field, value, writer, options);
      }
    };
  }
  function readField2(target, reader, field, wireType, options) {
    let { repeated, localName } = field;
    if (field.oneof) {
      target = target[field.oneof.localName];
      if (target.case != localName) {
        delete target.value;
      }
      target.case = localName;
      localName = "value";
    }
    switch (field.kind) {
      case "scalar":
      case "enum":
        const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        let read = readScalar2;
        if (field.kind == "scalar" && field.L > 0) {
          read = readScalarLTString;
        }
        if (repeated) {
          let arr = target[localName];
          const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
          if (isPacked) {
            let e = reader.uint32() + reader.pos;
            while (reader.pos < e) {
              arr.push(read(reader, scalarType));
            }
          } else {
            arr.push(read(reader, scalarType));
          }
        } else {
          target[localName] = read(reader, scalarType);
        }
        break;
      case "message":
        const messageType = field.T;
        if (repeated) {
          target[localName].push(readMessageField(reader, new messageType(), options, field));
        } else {
          if (isMessage(target[localName])) {
            readMessageField(reader, target[localName], options, field);
          } else {
            target[localName] = readMessageField(reader, new messageType(), options, field);
            if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
              target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);
            }
          }
        }
        break;
      case "map":
        let [mapKey, mapVal] = readMapEntry(field, reader, options);
        target[localName][mapKey] = mapVal;
        break;
    }
  }
  function readMessageField(reader, message, options, field) {
    const format2 = message.getType().runtime.bin;
    const delimited = field === null || field === void 0 ? void 0 : field.delimited;
    format2.readMessage(
      message,
      reader,
      delimited ? field.no : reader.uint32(),
      // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      options,
      delimited
    );
    return message;
  }
  function readMapEntry(field, reader, options) {
    const length3 = reader.uint32(), end = reader.pos + length3;
    let key, val;
    while (reader.pos < end) {
      const [fieldNo] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = readScalar2(reader, field.K);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = readScalar2(reader, field.V.T);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = readMessageField(reader, new field.V.T(), options, void 0);
              break;
          }
          break;
      }
    }
    if (key === void 0) {
      key = scalarZeroValue(field.K, LongType.BIGINT);
    }
    if (typeof key != "string" && typeof key != "number") {
      key = key.toString();
    }
    if (val === void 0) {
      switch (field.V.kind) {
        case "scalar":
          val = scalarZeroValue(field.V.T, LongType.BIGINT);
          break;
        case "enum":
          val = field.V.T.values[0].no;
          break;
        case "message":
          val = new field.V.T();
          break;
      }
    }
    return [key, val];
  }
  function readScalarLTString(reader, type2) {
    const v3 = readScalar2(reader, type2);
    return typeof v3 == "bigint" ? v3.toString() : v3;
  }
  function readScalar2(reader, type2) {
    switch (type2) {
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.INT64:
        return reader.int64();
      case ScalarType.UINT64:
        return reader.uint64();
      case ScalarType.FIXED64:
        return reader.fixed64();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reader.sfixed64();
      case ScalarType.SINT64:
        return reader.sint64();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SINT32:
        return reader.sint32();
    }
  }
  function writeField2(field, value, writer, options) {
    assert(value !== void 0);
    const repeated = field.repeated;
    switch (field.kind) {
      case "scalar":
      case "enum":
        let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (repeated) {
          assert(Array.isArray(value));
          if (field.packed) {
            writePacked(writer, scalarType, field.no, value);
          } else {
            for (const item of value) {
              writeScalar2(writer, scalarType, field.no, item);
            }
          }
        } else {
          writeScalar2(writer, scalarType, field.no, value);
        }
        break;
      case "message":
        if (repeated) {
          assert(Array.isArray(value));
          for (const item of value) {
            writeMessageField(writer, options, field, item);
          }
        } else {
          writeMessageField(writer, options, field, value);
        }
        break;
      case "map":
        assert(typeof value == "object" && value != null);
        for (const [key, val] of Object.entries(value)) {
          writeMapEntry(writer, options, field, key, val);
        }
        break;
    }
  }
  function writeMapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    writeScalar2(writer, field.K, 1, keyValue);
    switch (field.V.kind) {
      case "scalar":
        writeScalar2(writer, field.V.T, 2, value);
        break;
      case "enum":
        writeScalar2(writer, ScalarType.INT32, 2, value);
        break;
      case "message":
        assert(value !== void 0);
        writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
        break;
    }
    writer.join();
  }
  function writeMessageField(writer, options, field, value) {
    const message = wrapField(field.T, value);
    if (field.delimited)
      writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);
    else
      writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));
  }
  function writeScalar2(writer, type2, fieldNo, value) {
    assert(value !== void 0);
    let [wireType, method] = scalarTypeInfo(type2);
    writer.tag(fieldNo, wireType)[method](value);
  }
  function writePacked(writer, type2, fieldNo, value) {
    if (!value.length) {
      return;
    }
    writer.tag(fieldNo, WireType.LengthDelimited).fork();
    let [, method] = scalarTypeInfo(type2);
    for (let i = 0; i < value.length; i++) {
      writer[method](value[i]);
    }
    writer.join();
  }
  function scalarTypeInfo(type2) {
    let wireType = WireType.Varint;
    switch (type2) {
      case ScalarType.BYTES:
      case ScalarType.STRING:
        wireType = WireType.LengthDelimited;
        break;
      case ScalarType.DOUBLE:
      case ScalarType.FIXED64:
      case ScalarType.SFIXED64:
        wireType = WireType.Bit64;
        break;
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.FLOAT:
        wireType = WireType.Bit32;
        break;
    }
    const method = ScalarType[type2].toLowerCase();
    return [wireType, method];
  }

  // node_modules/@bufbuild/protobuf/dist/esm/private/util-common.js
  function makeUtilCommon() {
    return {
      setEnumType,
      initPartial(source2, target) {
        if (source2 === void 0) {
          return;
        }
        const type2 = target.getType();
        for (const member of type2.fields.byMember()) {
          const localName = member.localName, t = target, s2 = source2;
          if (s2[localName] == null) {
            continue;
          }
          switch (member.kind) {
            case "oneof":
              const sk = s2[localName].case;
              if (sk === void 0) {
                continue;
              }
              const sourceField = member.findField(sk);
              let val = s2[localName].value;
              if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
                val = new sourceField.T(val);
              } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
                val = toU8Arr(val);
              }
              t[localName] = { case: sk, value: val };
              break;
            case "scalar":
            case "enum":
              let copy3 = s2[localName];
              if (member.T === ScalarType.BYTES) {
                copy3 = member.repeated ? copy3.map(toU8Arr) : toU8Arr(copy3);
              }
              t[localName] = copy3;
              break;
            case "map":
              switch (member.V.kind) {
                case "scalar":
                case "enum":
                  if (member.V.T === ScalarType.BYTES) {
                    for (const [k3, v3] of Object.entries(s2[localName])) {
                      t[localName][k3] = toU8Arr(v3);
                    }
                  } else {
                    Object.assign(t[localName], s2[localName]);
                  }
                  break;
                case "message":
                  const messageType = member.V.T;
                  for (const k3 of Object.keys(s2[localName])) {
                    let val2 = s2[localName][k3];
                    if (!messageType.fieldWrapper) {
                      val2 = new messageType(val2);
                    }
                    t[localName][k3] = val2;
                  }
                  break;
              }
              break;
            case "message":
              const mt = member.T;
              if (member.repeated) {
                t[localName] = s2[localName].map((val2) => isMessage(val2, mt) ? val2 : new mt(val2));
              } else {
                const val2 = s2[localName];
                if (mt.fieldWrapper) {
                  if (
                    // We can't use BytesValue.typeName as that will create a circular import
                    mt.typeName === "google.protobuf.BytesValue"
                  ) {
                    t[localName] = toU8Arr(val2);
                  } else {
                    t[localName] = val2;
                  }
                } else {
                  t[localName] = isMessage(val2, mt) ? val2 : new mt(val2);
                }
              }
              break;
          }
        }
      },
      // TODO use isFieldSet() here to support future field presence
      equals(type2, a4, b10) {
        if (a4 === b10) {
          return true;
        }
        if (!a4 || !b10) {
          return false;
        }
        return type2.fields.byMember().every((m4) => {
          const va = a4[m4.localName];
          const vb = b10[m4.localName];
          if (m4.repeated) {
            if (va.length !== vb.length) {
              return false;
            }
            switch (m4.kind) {
              case "message":
                return va.every((a5, i) => m4.T.equals(a5, vb[i]));
              case "scalar":
                return va.every((a5, i) => scalarEquals(m4.T, a5, vb[i]));
              case "enum":
                return va.every((a5, i) => scalarEquals(ScalarType.INT32, a5, vb[i]));
            }
            throw new Error(`repeated cannot contain ${m4.kind}`);
          }
          switch (m4.kind) {
            case "message":
              return m4.T.equals(va, vb);
            case "enum":
              return scalarEquals(ScalarType.INT32, va, vb);
            case "scalar":
              return scalarEquals(m4.T, va, vb);
            case "oneof":
              if (va.case !== vb.case) {
                return false;
              }
              const s2 = m4.findField(va.case);
              if (s2 === void 0) {
                return true;
              }
              switch (s2.kind) {
                case "message":
                  return s2.T.equals(va.value, vb.value);
                case "enum":
                  return scalarEquals(ScalarType.INT32, va.value, vb.value);
                case "scalar":
                  return scalarEquals(s2.T, va.value, vb.value);
              }
              throw new Error(`oneof cannot contain ${s2.kind}`);
            case "map":
              const keys = Object.keys(va).concat(Object.keys(vb));
              switch (m4.V.kind) {
                case "message":
                  const messageType = m4.V.T;
                  return keys.every((k3) => messageType.equals(va[k3], vb[k3]));
                case "enum":
                  return keys.every((k3) => scalarEquals(ScalarType.INT32, va[k3], vb[k3]));
                case "scalar":
                  const scalarType = m4.V.T;
                  return keys.every((k3) => scalarEquals(scalarType, va[k3], vb[k3]));
              }
              break;
          }
        });
      },
      // TODO use isFieldSet() here to support future field presence
      clone(message) {
        const type2 = message.getType(), target = new type2(), any = target;
        for (const member of type2.fields.byMember()) {
          const source2 = message[member.localName];
          let copy3;
          if (member.repeated) {
            copy3 = source2.map(cloneSingularField);
          } else if (member.kind == "map") {
            copy3 = any[member.localName];
            for (const [key, v3] of Object.entries(source2)) {
              copy3[key] = cloneSingularField(v3);
            }
          } else if (member.kind == "oneof") {
            const f = member.findField(source2.case);
            copy3 = f ? { case: source2.case, value: cloneSingularField(source2.value) } : { case: void 0 };
          } else {
            copy3 = cloneSingularField(source2);
          }
          any[member.localName] = copy3;
        }
        for (const uf of type2.runtime.bin.listUnknownFields(message)) {
          type2.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);
        }
        return target;
      }
    };
  }
  function cloneSingularField(value) {
    if (value === void 0) {
      return value;
    }
    if (isMessage(value)) {
      return value.clone();
    }
    if (value instanceof Uint8Array) {
      const c6 = new Uint8Array(value.byteLength);
      c6.set(value);
      return c6;
    }
    return value;
  }
  function toU8Arr(input) {
    return input instanceof Uint8Array ? input : new Uint8Array(input);
  }

  // node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js
  function makeProtoRuntime(syntax, newFieldList, initFields) {
    return {
      syntax,
      json: makeJsonFormat(),
      bin: makeBinaryFormat(),
      util: Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList,
        initFields
      }),
      makeMessageType(typeName, fields, opt) {
        return makeMessageType(this, typeName, fields, opt);
      },
      makeEnum,
      makeEnumType,
      getEnumType,
      makeExtension(typeName, extendee, field) {
        return makeExtension(this, typeName, extendee, field);
      }
    };
  }

  // node_modules/@bufbuild/protobuf/dist/esm/private/field-list.js
  var InternalFieldList = class {
    constructor(fields, normalizer) {
      this._fields = fields;
      this._normalizer = normalizer;
    }
    findJsonName(jsonName) {
      if (!this.jsonNames) {
        const t = {};
        for (const f of this.list()) {
          t[f.jsonName] = t[f.name] = f;
        }
        this.jsonNames = t;
      }
      return this.jsonNames[jsonName];
    }
    find(fieldNo) {
      if (!this.numbers) {
        const t = {};
        for (const f of this.list()) {
          t[f.no] = f;
        }
        this.numbers = t;
      }
      return this.numbers[fieldNo];
    }
    list() {
      if (!this.all) {
        this.all = this._normalizer(this._fields);
      }
      return this.all;
    }
    byNumber() {
      if (!this.numbersAsc) {
        this.numbersAsc = this.list().concat().sort((a4, b10) => a4.no - b10.no);
      }
      return this.numbersAsc;
    }
    byMember() {
      if (!this.members) {
        this.members = [];
        const a4 = this.members;
        let o;
        for (const f of this.list()) {
          if (f.oneof) {
            if (f.oneof !== o) {
              o = f.oneof;
              a4.push(o);
            }
          } else {
            a4.push(f);
          }
        }
      }
      return this.members;
    }
  };

  // node_modules/@bufbuild/protobuf/dist/esm/private/names.js
  function localFieldName(protoName, inOneof) {
    const name = protoCamelCase(protoName);
    if (inOneof) {
      return name;
    }
    return safeObjectProperty(safeMessageProperty(name));
  }
  function localOneofName(protoName) {
    return localFieldName(protoName, false);
  }
  var fieldJsonName = protoCamelCase;
  function protoCamelCase(snakeCase) {
    let capNext = false;
    const b10 = [];
    for (let i = 0; i < snakeCase.length; i++) {
      let c6 = snakeCase.charAt(i);
      switch (c6) {
        case "_":
          capNext = true;
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          b10.push(c6);
          capNext = false;
          break;
        default:
          if (capNext) {
            capNext = false;
            c6 = c6.toUpperCase();
          }
          b10.push(c6);
          break;
      }
    }
    return b10.join("");
  }
  var reservedObjectProperties = /* @__PURE__ */ new Set([
    // names reserved by JavaScript
    "constructor",
    "toString",
    "toJSON",
    "valueOf"
  ]);
  var reservedMessageProperties = /* @__PURE__ */ new Set([
    // names reserved by the runtime
    "getType",
    "clone",
    "equals",
    "fromBinary",
    "fromJson",
    "fromJsonString",
    "toBinary",
    "toJson",
    "toJsonString",
    // names reserved by the runtime for the future
    "toObject"
  ]);
  var fallback3 = (name) => `${name}$`;
  var safeMessageProperty = (name) => {
    if (reservedMessageProperties.has(name)) {
      return fallback3(name);
    }
    return name;
  };
  var safeObjectProperty = (name) => {
    if (reservedObjectProperties.has(name)) {
      return fallback3(name);
    }
    return name;
  };

  // node_modules/@bufbuild/protobuf/dist/esm/private/field.js
  var InternalOneofInfo = class {
    constructor(name) {
      this.kind = "oneof";
      this.repeated = false;
      this.packed = false;
      this.opt = false;
      this.req = false;
      this.default = void 0;
      this.fields = [];
      this.name = name;
      this.localName = localOneofName(name);
    }
    addField(field) {
      assert(field.oneof === this, `field ${field.name} not one of ${this.name}`);
      this.fields.push(field);
    }
    findField(localName) {
      if (!this._lookup) {
        this._lookup = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < this.fields.length; i++) {
          this._lookup[this.fields[i].localName] = this.fields[i];
        }
      }
      return this._lookup[localName];
    }
  };

  // node_modules/@bufbuild/protobuf/dist/esm/private/field-normalize.js
  function normalizeFieldInfos(fieldInfos, packedByDefault) {
    var _a, _b, _c, _d, _e, _f;
    const r = [];
    let o;
    for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
      const f = field;
      f.localName = localFieldName(field.name, field.oneof !== void 0);
      f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);
      f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
      if (field.kind == "scalar") {
        f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;
      }
      f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;
      f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;
      f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;
      if (field.packed === void 0) {
        if (packedByDefault) {
          f.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
        } else {
          f.packed = false;
        }
      }
      if (field.oneof !== void 0) {
        const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
        if (!o || o.name != ooname) {
          o = new InternalOneofInfo(ooname);
        }
        f.oneof = o;
        o.addField(f);
      }
      r.push(f);
    }
    return r;
  }

  // node_modules/@bufbuild/protobuf/dist/esm/proto3.js
  var proto3 = makeProtoRuntime(
    "proto3",
    (fields) => {
      return new InternalFieldList(fields, (source2) => normalizeFieldInfos(source2, true));
    },
    // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
    (target) => {
      for (const member of target.getType().fields.byMember()) {
        if (member.opt) {
          continue;
        }
        const name = member.localName, t = target;
        if (member.repeated) {
          t[name] = [];
          continue;
        }
        switch (member.kind) {
          case "oneof":
            t[name] = { case: void 0 };
            break;
          case "enum":
            t[name] = 0;
            break;
          case "map":
            t[name] = {};
            break;
          case "scalar":
            t[name] = scalarZeroValue(member.T, member.L);
            break;
          case "message":
            break;
        }
      }
    }
  );

  // src/ts/proto/anki/cards_pb.ts
  var CardId = class _CardId extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: int64 cid = 1;
       */
      this.cid = protoInt64.zero;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.cards.CardId";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "cid",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _CardId().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CardId().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CardId().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_CardId, a4, b10);
    }
  };
  var CardIds = class _CardIds extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: repeated int64 cids = 1;
       */
      this.cids = [];
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.cards.CardIds";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "cids", kind: "scalar", T: 3, repeated: true }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _CardIds().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CardIds().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CardIds().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_CardIds, a4, b10);
    }
  };
  var Card = class _Card extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: int64 id = 1;
       */
      this.id = protoInt64.zero;
      /**
       * @generated from field: int64 note_id = 2;
       */
      this.noteId = protoInt64.zero;
      /**
       * @generated from field: int64 deck_id = 3;
       */
      this.deckId = protoInt64.zero;
      /**
       * @generated from field: uint32 template_idx = 4;
       */
      this.templateIdx = 0;
      /**
       * @generated from field: int64 mtime_secs = 5;
       */
      this.mtimeSecs = protoInt64.zero;
      /**
       * @generated from field: sint32 usn = 6;
       */
      this.usn = 0;
      /**
       * @generated from field: uint32 ctype = 7;
       */
      this.ctype = 0;
      /**
       * @generated from field: sint32 queue = 8;
       */
      this.queue = 0;
      /**
       * @generated from field: sint32 due = 9;
       */
      this.due = 0;
      /**
       * @generated from field: uint32 interval = 10;
       */
      this.interval = 0;
      /**
       * @generated from field: uint32 ease_factor = 11;
       */
      this.easeFactor = 0;
      /**
       * @generated from field: uint32 reps = 12;
       */
      this.reps = 0;
      /**
       * @generated from field: uint32 lapses = 13;
       */
      this.lapses = 0;
      /**
       * @generated from field: uint32 remaining_steps = 14;
       */
      this.remainingSteps = 0;
      /**
       * @generated from field: sint32 original_due = 15;
       */
      this.originalDue = 0;
      /**
       * @generated from field: int64 original_deck_id = 16;
       */
      this.originalDeckId = protoInt64.zero;
      /**
       * @generated from field: uint32 flags = 17;
       */
      this.flags = 0;
      /**
       * @generated from field: string custom_data = 19;
       */
      this.customData = "";
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.cards.Card";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 2,
          name: "note_id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 3,
          name: "deck_id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 4,
          name: "template_idx",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 5,
          name: "mtime_secs",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 6,
          name: "usn",
          kind: "scalar",
          T: 17
          /* ScalarType.SINT32 */
        },
        {
          no: 7,
          name: "ctype",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 8,
          name: "queue",
          kind: "scalar",
          T: 17
          /* ScalarType.SINT32 */
        },
        {
          no: 9,
          name: "due",
          kind: "scalar",
          T: 17
          /* ScalarType.SINT32 */
        },
        {
          no: 10,
          name: "interval",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 11,
          name: "ease_factor",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 12,
          name: "reps",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 13,
          name: "lapses",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 14,
          name: "remaining_steps",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 15,
          name: "original_due",
          kind: "scalar",
          T: 17
          /* ScalarType.SINT32 */
        },
        {
          no: 16,
          name: "original_deck_id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 17,
          name: "flags",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        { no: 18, name: "original_position", kind: "scalar", T: 13, opt: true },
        { no: 20, name: "memory_state", kind: "message", T: FsrsMemoryState, opt: true },
        { no: 21, name: "desired_retention", kind: "scalar", T: 2, opt: true },
        {
          no: 19,
          name: "custom_data",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _Card().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _Card().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _Card().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_Card, a4, b10);
    }
  };
  var FsrsMemoryState = class _FsrsMemoryState extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: float stability = 1;
       */
      this.stability = 0;
      /**
       * @generated from field: float difficulty = 2;
       */
      this.difficulty = 0;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.cards.FsrsMemoryState";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "stability",
          kind: "scalar",
          T: 2
          /* ScalarType.FLOAT */
        },
        {
          no: 2,
          name: "difficulty",
          kind: "scalar",
          T: 2
          /* ScalarType.FLOAT */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _FsrsMemoryState().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _FsrsMemoryState().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _FsrsMemoryState().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_FsrsMemoryState, a4, b10);
    }
  };
  var UpdateCardsRequest = class _UpdateCardsRequest extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: repeated anki.cards.Card cards = 1;
       */
      this.cards = [];
      /**
       * @generated from field: bool skip_undo_entry = 2;
       */
      this.skipUndoEntry = false;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.cards.UpdateCardsRequest";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "cards", kind: "message", T: Card, repeated: true },
        {
          no: 2,
          name: "skip_undo_entry",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _UpdateCardsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _UpdateCardsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _UpdateCardsRequest().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_UpdateCardsRequest, a4, b10);
    }
  };
  var RemoveCardsRequest = class _RemoveCardsRequest extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: repeated int64 card_ids = 1;
       */
      this.cardIds = [];
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.cards.RemoveCardsRequest";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "card_ids", kind: "scalar", T: 3, repeated: true }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _RemoveCardsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RemoveCardsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RemoveCardsRequest().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_RemoveCardsRequest, a4, b10);
    }
  };
  var SetDeckRequest = class _SetDeckRequest extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: repeated int64 card_ids = 1;
       */
      this.cardIds = [];
      /**
       * @generated from field: int64 deck_id = 2;
       */
      this.deckId = protoInt64.zero;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.cards.SetDeckRequest";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "card_ids", kind: "scalar", T: 3, repeated: true },
        {
          no: 2,
          name: "deck_id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _SetDeckRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _SetDeckRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _SetDeckRequest().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_SetDeckRequest, a4, b10);
    }
  };
  var SetFlagRequest = class _SetFlagRequest extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: repeated int64 card_ids = 1;
       */
      this.cardIds = [];
      /**
       * @generated from field: uint32 flag = 2;
       */
      this.flag = 0;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.cards.SetFlagRequest";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "card_ids", kind: "scalar", T: 3, repeated: true },
        {
          no: 2,
          name: "flag",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _SetFlagRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _SetFlagRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _SetFlagRequest().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_SetFlagRequest, a4, b10);
    }
  };

  // src/ts/proto/anki/stats_pb.ts
  var ReviewLogs = class _ReviewLogs extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: repeated anki.stats.CardStatsResponse.StatsRevlogEntry entries = 1;
       */
      this.entries = [];
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.ReviewLogs";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "entries", kind: "message", T: CardStatsResponse_StatsRevlogEntry, repeated: true }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _ReviewLogs().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ReviewLogs().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ReviewLogs().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_ReviewLogs, a4, b10);
    }
  };
  var CardStatsResponse = class _CardStatsResponse extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: repeated anki.stats.CardStatsResponse.StatsRevlogEntry revlog = 1;
       */
      this.revlog = [];
      /**
       * @generated from field: int64 card_id = 2;
       */
      this.cardId = protoInt64.zero;
      /**
       * @generated from field: int64 note_id = 3;
       */
      this.noteId = protoInt64.zero;
      /**
       * @generated from field: string deck = 4;
       */
      this.deck = "";
      /**
       * Unix timestamps
       *
       * @generated from field: int64 added = 5;
       */
      this.added = protoInt64.zero;
      /**
       * days
       *
       * @generated from field: uint32 interval = 10;
       */
      this.interval = 0;
      /**
       * per mill
       *
       * @generated from field: uint32 ease = 11;
       */
      this.ease = 0;
      /**
       * @generated from field: uint32 reviews = 12;
       */
      this.reviews = 0;
      /**
       * @generated from field: uint32 lapses = 13;
       */
      this.lapses = 0;
      /**
       * @generated from field: float average_secs = 14;
       */
      this.averageSecs = 0;
      /**
       * @generated from field: float total_secs = 15;
       */
      this.totalSecs = 0;
      /**
       * @generated from field: string card_type = 16;
       */
      this.cardType = "";
      /**
       * @generated from field: string notetype = 17;
       */
      this.notetype = "";
      /**
       * @generated from field: string custom_data = 20;
       */
      this.customData = "";
      /**
       * @generated from field: string preset = 21;
       */
      this.preset = "";
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.CardStatsResponse";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "revlog", kind: "message", T: CardStatsResponse_StatsRevlogEntry, repeated: true },
        {
          no: 2,
          name: "card_id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 3,
          name: "note_id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 4,
          name: "deck",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 5,
          name: "added",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        { no: 6, name: "first_review", kind: "scalar", T: 3, opt: true },
        { no: 7, name: "latest_review", kind: "scalar", T: 3, opt: true },
        { no: 8, name: "due_date", kind: "scalar", T: 3, opt: true },
        { no: 9, name: "due_position", kind: "scalar", T: 5, opt: true },
        {
          no: 10,
          name: "interval",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 11,
          name: "ease",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 12,
          name: "reviews",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 13,
          name: "lapses",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 14,
          name: "average_secs",
          kind: "scalar",
          T: 2
          /* ScalarType.FLOAT */
        },
        {
          no: 15,
          name: "total_secs",
          kind: "scalar",
          T: 2
          /* ScalarType.FLOAT */
        },
        {
          no: 16,
          name: "card_type",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 17,
          name: "notetype",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        { no: 18, name: "memory_state", kind: "message", T: FsrsMemoryState, opt: true },
        { no: 19, name: "fsrs_retrievability", kind: "scalar", T: 2, opt: true },
        {
          no: 20,
          name: "custom_data",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 21,
          name: "preset",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        { no: 22, name: "original_deck", kind: "scalar", T: 9, opt: true }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _CardStatsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CardStatsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CardStatsResponse().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_CardStatsResponse, a4, b10);
    }
  };
  var CardStatsResponse_StatsRevlogEntry = class _CardStatsResponse_StatsRevlogEntry extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: int64 time = 1;
       */
      this.time = protoInt64.zero;
      /**
       * @generated from field: anki.stats.RevlogEntry.ReviewKind review_kind = 2;
       */
      this.reviewKind = 0 /* LEARNING */;
      /**
       * @generated from field: uint32 button_chosen = 3;
       */
      this.buttonChosen = 0;
      /**
       * seconds
       *
       * @generated from field: uint32 interval = 4;
       */
      this.interval = 0;
      /**
       * per mill
       *
       * @generated from field: uint32 ease = 5;
       */
      this.ease = 0;
      /**
       * @generated from field: float taken_secs = 6;
       */
      this.takenSecs = 0;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.CardStatsResponse.StatsRevlogEntry";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "time",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        { no: 2, name: "review_kind", kind: "enum", T: proto3.getEnumType(RevlogEntry_ReviewKind) },
        {
          no: 3,
          name: "button_chosen",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 4,
          name: "interval",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 5,
          name: "ease",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 6,
          name: "taken_secs",
          kind: "scalar",
          T: 2
          /* ScalarType.FLOAT */
        },
        { no: 7, name: "memory_state", kind: "message", T: FsrsMemoryState, opt: true }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _CardStatsResponse_StatsRevlogEntry().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CardStatsResponse_StatsRevlogEntry().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CardStatsResponse_StatsRevlogEntry().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_CardStatsResponse_StatsRevlogEntry, a4, b10);
    }
  };
  var GraphsRequest = class _GraphsRequest extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: string search = 1;
       */
      this.search = "";
      /**
       * @generated from field: uint32 days = 2;
       */
      this.days = 0;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsRequest";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "search",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 2,
          name: "days",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsRequest().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsRequest, a4, b10);
    }
  };
  var GraphsResponse = class _GraphsResponse extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: uint32 rollover_hour = 10;
       */
      this.rolloverHour = 0;
      /**
       * @generated from field: bool fsrs = 13;
       */
      this.fsrs = false;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "buttons", kind: "message", T: GraphsResponse_Buttons },
        { no: 2, name: "card_counts", kind: "message", T: GraphsResponse_CardCounts },
        { no: 3, name: "hours", kind: "message", T: GraphsResponse_Hours },
        { no: 4, name: "today", kind: "message", T: GraphsResponse_Today },
        { no: 5, name: "eases", kind: "message", T: GraphsResponse_Eases },
        { no: 11, name: "difficulty", kind: "message", T: GraphsResponse_Eases },
        { no: 6, name: "intervals", kind: "message", T: GraphsResponse_Intervals },
        { no: 7, name: "future_due", kind: "message", T: GraphsResponse_FutureDue },
        { no: 8, name: "added", kind: "message", T: GraphsResponse_Added },
        { no: 9, name: "reviews", kind: "message", T: GraphsResponse_ReviewCountsAndTimes },
        {
          no: 10,
          name: "rollover_hour",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        { no: 12, name: "retrievability", kind: "message", T: GraphsResponse_Retrievability },
        {
          no: 13,
          name: "fsrs",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        },
        { no: 14, name: "stability", kind: "message", T: GraphsResponse_Intervals },
        { no: 15, name: "true_retention", kind: "message", T: GraphsResponse_TrueRetentionStats }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse, a4, b10);
    }
  };
  var GraphsResponse_Added = class _GraphsResponse_Added extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: map<int32, uint32> added = 1;
       */
      this.added = {};
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.Added";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "added", kind: "map", K: 5, V: {
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        } }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_Added().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_Added().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_Added().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_Added, a4, b10);
    }
  };
  var GraphsResponse_Intervals = class _GraphsResponse_Intervals extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: map<uint32, uint32> intervals = 1;
       */
      this.intervals = {};
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.Intervals";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "intervals", kind: "map", K: 13, V: {
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        } }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_Intervals().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_Intervals().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_Intervals().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_Intervals, a4, b10);
    }
  };
  var GraphsResponse_Eases = class _GraphsResponse_Eases extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: map<uint32, uint32> eases = 1;
       */
      this.eases = {};
      /**
       * @generated from field: float average = 2;
       */
      this.average = 0;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.Eases";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "eases", kind: "map", K: 13, V: {
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        } },
        {
          no: 2,
          name: "average",
          kind: "scalar",
          T: 2
          /* ScalarType.FLOAT */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_Eases().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_Eases().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_Eases().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_Eases, a4, b10);
    }
  };
  var GraphsResponse_Retrievability = class _GraphsResponse_Retrievability extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: map<uint32, uint32> retrievability = 1;
       */
      this.retrievability = {};
      /**
       * @generated from field: float average = 2;
       */
      this.average = 0;
      /**
       * @generated from field: float sum_by_card = 3;
       */
      this.sumByCard = 0;
      /**
       * @generated from field: float sum_by_note = 4;
       */
      this.sumByNote = 0;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.Retrievability";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "retrievability", kind: "map", K: 13, V: {
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        } },
        {
          no: 2,
          name: "average",
          kind: "scalar",
          T: 2
          /* ScalarType.FLOAT */
        },
        {
          no: 3,
          name: "sum_by_card",
          kind: "scalar",
          T: 2
          /* ScalarType.FLOAT */
        },
        {
          no: 4,
          name: "sum_by_note",
          kind: "scalar",
          T: 2
          /* ScalarType.FLOAT */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_Retrievability().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_Retrievability().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_Retrievability().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_Retrievability, a4, b10);
    }
  };
  var GraphsResponse_FutureDue = class _GraphsResponse_FutureDue extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: map<int32, uint32> future_due = 1;
       */
      this.futureDue = {};
      /**
       * @generated from field: bool have_backlog = 2;
       */
      this.haveBacklog = false;
      /**
       * @generated from field: uint32 daily_load = 3;
       */
      this.dailyLoad = 0;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.FutureDue";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "future_due", kind: "map", K: 5, V: {
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        } },
        {
          no: 2,
          name: "have_backlog",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        },
        {
          no: 3,
          name: "daily_load",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_FutureDue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_FutureDue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_FutureDue().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_FutureDue, a4, b10);
    }
  };
  var GraphsResponse_Today = class _GraphsResponse_Today extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: uint32 answer_count = 1;
       */
      this.answerCount = 0;
      /**
       * @generated from field: uint32 answer_millis = 2;
       */
      this.answerMillis = 0;
      /**
       * @generated from field: uint32 correct_count = 3;
       */
      this.correctCount = 0;
      /**
       * @generated from field: uint32 mature_correct = 4;
       */
      this.matureCorrect = 0;
      /**
       * @generated from field: uint32 mature_count = 5;
       */
      this.matureCount = 0;
      /**
       * @generated from field: uint32 learn_count = 6;
       */
      this.learnCount = 0;
      /**
       * @generated from field: uint32 review_count = 7;
       */
      this.reviewCount = 0;
      /**
       * @generated from field: uint32 relearn_count = 8;
       */
      this.relearnCount = 0;
      /**
       * @generated from field: uint32 early_review_count = 9;
       */
      this.earlyReviewCount = 0;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.Today";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "answer_count",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 2,
          name: "answer_millis",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 3,
          name: "correct_count",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 4,
          name: "mature_correct",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 5,
          name: "mature_count",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 6,
          name: "learn_count",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 7,
          name: "review_count",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 8,
          name: "relearn_count",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 9,
          name: "early_review_count",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_Today().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_Today().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_Today().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_Today, a4, b10);
    }
  };
  var GraphsResponse_Hours = class _GraphsResponse_Hours extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: repeated anki.stats.GraphsResponse.Hours.Hour one_month = 1;
       */
      this.oneMonth = [];
      /**
       * @generated from field: repeated anki.stats.GraphsResponse.Hours.Hour three_months = 2;
       */
      this.threeMonths = [];
      /**
       * @generated from field: repeated anki.stats.GraphsResponse.Hours.Hour one_year = 3;
       */
      this.oneYear = [];
      /**
       * @generated from field: repeated anki.stats.GraphsResponse.Hours.Hour all_time = 4;
       */
      this.allTime = [];
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.Hours";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "one_month", kind: "message", T: GraphsResponse_Hours_Hour, repeated: true },
        { no: 2, name: "three_months", kind: "message", T: GraphsResponse_Hours_Hour, repeated: true },
        { no: 3, name: "one_year", kind: "message", T: GraphsResponse_Hours_Hour, repeated: true },
        { no: 4, name: "all_time", kind: "message", T: GraphsResponse_Hours_Hour, repeated: true }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_Hours().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_Hours().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_Hours().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_Hours, a4, b10);
    }
  };
  var GraphsResponse_Hours_Hour = class _GraphsResponse_Hours_Hour extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: uint32 total = 1;
       */
      this.total = 0;
      /**
       * @generated from field: uint32 correct = 2;
       */
      this.correct = 0;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.Hours.Hour";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "total",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 2,
          name: "correct",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_Hours_Hour().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_Hours_Hour().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_Hours_Hour().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_Hours_Hour, a4, b10);
    }
  };
  var GraphsResponse_ReviewCountsAndTimes = class _GraphsResponse_ReviewCountsAndTimes extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: map<int32, anki.stats.GraphsResponse.ReviewCountsAndTimes.Reviews> count = 1;
       */
      this.count = {};
      /**
       * @generated from field: map<int32, anki.stats.GraphsResponse.ReviewCountsAndTimes.Reviews> time = 2;
       */
      this.time = {};
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.ReviewCountsAndTimes";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "count", kind: "map", K: 5, V: { kind: "message", T: GraphsResponse_ReviewCountsAndTimes_Reviews } },
        { no: 2, name: "time", kind: "map", K: 5, V: { kind: "message", T: GraphsResponse_ReviewCountsAndTimes_Reviews } }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_ReviewCountsAndTimes().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_ReviewCountsAndTimes().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_ReviewCountsAndTimes().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_ReviewCountsAndTimes, a4, b10);
    }
  };
  var GraphsResponse_ReviewCountsAndTimes_Reviews = class _GraphsResponse_ReviewCountsAndTimes_Reviews extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: uint32 learn = 1;
       */
      this.learn = 0;
      /**
       * @generated from field: uint32 relearn = 2;
       */
      this.relearn = 0;
      /**
       * @generated from field: uint32 young = 3;
       */
      this.young = 0;
      /**
       * @generated from field: uint32 mature = 4;
       */
      this.mature = 0;
      /**
       * @generated from field: uint32 filtered = 5;
       */
      this.filtered = 0;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.ReviewCountsAndTimes.Reviews";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "learn",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 2,
          name: "relearn",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 3,
          name: "young",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 4,
          name: "mature",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 5,
          name: "filtered",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_ReviewCountsAndTimes_Reviews().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_ReviewCountsAndTimes_Reviews().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_ReviewCountsAndTimes_Reviews().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_ReviewCountsAndTimes_Reviews, a4, b10);
    }
  };
  var GraphsResponse_Buttons = class _GraphsResponse_Buttons extends Message {
    constructor(data2) {
      super();
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.Buttons";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "one_month", kind: "message", T: GraphsResponse_Buttons_ButtonCounts },
        { no: 2, name: "three_months", kind: "message", T: GraphsResponse_Buttons_ButtonCounts },
        { no: 3, name: "one_year", kind: "message", T: GraphsResponse_Buttons_ButtonCounts },
        { no: 4, name: "all_time", kind: "message", T: GraphsResponse_Buttons_ButtonCounts }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_Buttons().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_Buttons().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_Buttons().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_Buttons, a4, b10);
    }
  };
  var GraphsResponse_Buttons_ButtonCounts = class _GraphsResponse_Buttons_ButtonCounts extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: repeated uint32 learning = 1;
       */
      this.learning = [];
      /**
       * @generated from field: repeated uint32 young = 2;
       */
      this.young = [];
      /**
       * @generated from field: repeated uint32 mature = 3;
       */
      this.mature = [];
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.Buttons.ButtonCounts";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "learning", kind: "scalar", T: 13, repeated: true },
        { no: 2, name: "young", kind: "scalar", T: 13, repeated: true },
        { no: 3, name: "mature", kind: "scalar", T: 13, repeated: true }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_Buttons_ButtonCounts().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_Buttons_ButtonCounts().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_Buttons_ButtonCounts().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_Buttons_ButtonCounts, a4, b10);
    }
  };
  var GraphsResponse_CardCounts = class _GraphsResponse_CardCounts extends Message {
    constructor(data2) {
      super();
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.CardCounts";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "including_inactive", kind: "message", T: GraphsResponse_CardCounts_Counts },
        { no: 2, name: "excluding_inactive", kind: "message", T: GraphsResponse_CardCounts_Counts }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_CardCounts().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_CardCounts().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_CardCounts().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_CardCounts, a4, b10);
    }
  };
  var GraphsResponse_CardCounts_Counts = class _GraphsResponse_CardCounts_Counts extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: uint32 newCards = 1;
       */
      this.newCards = 0;
      /**
       * @generated from field: uint32 learn = 2;
       */
      this.learn = 0;
      /**
       * @generated from field: uint32 relearn = 3;
       */
      this.relearn = 0;
      /**
       * @generated from field: uint32 young = 4;
       */
      this.young = 0;
      /**
       * @generated from field: uint32 mature = 5;
       */
      this.mature = 0;
      /**
       * @generated from field: uint32 suspended = 6;
       */
      this.suspended = 0;
      /**
       * @generated from field: uint32 buried = 7;
       */
      this.buried = 0;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.CardCounts.Counts";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "newCards",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 2,
          name: "learn",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 3,
          name: "relearn",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 4,
          name: "young",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 5,
          name: "mature",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 6,
          name: "suspended",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 7,
          name: "buried",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_CardCounts_Counts().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_CardCounts_Counts().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_CardCounts_Counts().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_CardCounts_Counts, a4, b10);
    }
  };
  var GraphsResponse_TrueRetentionStats = class _GraphsResponse_TrueRetentionStats extends Message {
    constructor(data2) {
      super();
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.TrueRetentionStats";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "today", kind: "message", T: GraphsResponse_TrueRetentionStats_TrueRetention },
        { no: 2, name: "yesterday", kind: "message", T: GraphsResponse_TrueRetentionStats_TrueRetention },
        { no: 3, name: "week", kind: "message", T: GraphsResponse_TrueRetentionStats_TrueRetention },
        { no: 4, name: "month", kind: "message", T: GraphsResponse_TrueRetentionStats_TrueRetention },
        { no: 5, name: "year", kind: "message", T: GraphsResponse_TrueRetentionStats_TrueRetention },
        { no: 6, name: "all_time", kind: "message", T: GraphsResponse_TrueRetentionStats_TrueRetention }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_TrueRetentionStats().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_TrueRetentionStats().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_TrueRetentionStats().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_TrueRetentionStats, a4, b10);
    }
  };
  var GraphsResponse_TrueRetentionStats_TrueRetention = class _GraphsResponse_TrueRetentionStats_TrueRetention extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: uint32 young_passed = 1;
       */
      this.youngPassed = 0;
      /**
       * @generated from field: uint32 young_failed = 2;
       */
      this.youngFailed = 0;
      /**
       * @generated from field: uint32 mature_passed = 3;
       */
      this.maturePassed = 0;
      /**
       * @generated from field: uint32 mature_failed = 4;
       */
      this.matureFailed = 0;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphsResponse.TrueRetentionStats.TrueRetention";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "young_passed",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 2,
          name: "young_failed",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 3,
          name: "mature_passed",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 4,
          name: "mature_failed",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphsResponse_TrueRetentionStats_TrueRetention().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphsResponse_TrueRetentionStats_TrueRetention().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphsResponse_TrueRetentionStats_TrueRetention().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphsResponse_TrueRetentionStats_TrueRetention, a4, b10);
    }
  };
  var GraphPreferences = class _GraphPreferences extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: anki.stats.GraphPreferences.Weekday calendar_first_day_of_week = 1;
       */
      this.calendarFirstDayOfWeek = 0 /* SUNDAY */;
      /**
       * @generated from field: bool card_counts_separate_inactive = 2;
       */
      this.cardCountsSeparateInactive = false;
      /**
       * @generated from field: bool browser_links_supported = 3;
       */
      this.browserLinksSupported = false;
      /**
       * @generated from field: bool future_due_show_backlog = 4;
       */
      this.futureDueShowBacklog = false;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.GraphPreferences";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "calendar_first_day_of_week", kind: "enum", T: proto3.getEnumType(GraphPreferences_Weekday) },
        {
          no: 2,
          name: "card_counts_separate_inactive",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        },
        {
          no: 3,
          name: "browser_links_supported",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        },
        {
          no: 4,
          name: "future_due_show_backlog",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _GraphPreferences().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _GraphPreferences().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _GraphPreferences().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_GraphPreferences, a4, b10);
    }
  };
  var GraphPreferences_Weekday = /* @__PURE__ */ ((GraphPreferences_Weekday2) => {
    GraphPreferences_Weekday2[GraphPreferences_Weekday2["SUNDAY"] = 0] = "SUNDAY";
    GraphPreferences_Weekday2[GraphPreferences_Weekday2["MONDAY"] = 1] = "MONDAY";
    GraphPreferences_Weekday2[GraphPreferences_Weekday2["FRIDAY"] = 5] = "FRIDAY";
    GraphPreferences_Weekday2[GraphPreferences_Weekday2["SATURDAY"] = 6] = "SATURDAY";
    return GraphPreferences_Weekday2;
  })(GraphPreferences_Weekday || {});
  proto3.util.setEnumType(GraphPreferences_Weekday, "anki.stats.GraphPreferences.Weekday", [
    { no: 0, name: "SUNDAY" },
    { no: 1, name: "MONDAY" },
    { no: 5, name: "FRIDAY" },
    { no: 6, name: "SATURDAY" }
  ]);
  var RevlogEntry = class _RevlogEntry extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: int64 id = 1;
       */
      this.id = protoInt64.zero;
      /**
       * @generated from field: int64 cid = 2;
       */
      this.cid = protoInt64.zero;
      /**
       * @generated from field: int32 usn = 3;
       */
      this.usn = 0;
      /**
       * @generated from field: uint32 button_chosen = 4;
       */
      this.buttonChosen = 0;
      /**
       * @generated from field: int32 interval = 5;
       */
      this.interval = 0;
      /**
       * @generated from field: int32 last_interval = 6;
       */
      this.lastInterval = 0;
      /**
       * @generated from field: uint32 ease_factor = 7;
       */
      this.easeFactor = 0;
      /**
       * @generated from field: uint32 taken_millis = 8;
       */
      this.takenMillis = 0;
      /**
       * @generated from field: anki.stats.RevlogEntry.ReviewKind review_kind = 9;
       */
      this.reviewKind = 0 /* LEARNING */;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.RevlogEntry";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 2,
          name: "cid",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 3,
          name: "usn",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        },
        {
          no: 4,
          name: "button_chosen",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 5,
          name: "interval",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        },
        {
          no: 6,
          name: "last_interval",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        },
        {
          no: 7,
          name: "ease_factor",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        {
          no: 8,
          name: "taken_millis",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        },
        { no: 9, name: "review_kind", kind: "enum", T: proto3.getEnumType(RevlogEntry_ReviewKind) }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _RevlogEntry().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RevlogEntry().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RevlogEntry().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_RevlogEntry, a4, b10);
    }
  };
  var RevlogEntry_ReviewKind = /* @__PURE__ */ ((RevlogEntry_ReviewKind2) => {
    RevlogEntry_ReviewKind2[RevlogEntry_ReviewKind2["LEARNING"] = 0] = "LEARNING";
    RevlogEntry_ReviewKind2[RevlogEntry_ReviewKind2["REVIEW"] = 1] = "REVIEW";
    RevlogEntry_ReviewKind2[RevlogEntry_ReviewKind2["RELEARNING"] = 2] = "RELEARNING";
    RevlogEntry_ReviewKind2[RevlogEntry_ReviewKind2["FILTERED"] = 3] = "FILTERED";
    RevlogEntry_ReviewKind2[RevlogEntry_ReviewKind2["MANUAL"] = 4] = "MANUAL";
    RevlogEntry_ReviewKind2[RevlogEntry_ReviewKind2["RESCHEDULED"] = 5] = "RESCHEDULED";
    return RevlogEntry_ReviewKind2;
  })(RevlogEntry_ReviewKind || {});
  proto3.util.setEnumType(RevlogEntry_ReviewKind, "anki.stats.RevlogEntry.ReviewKind", [
    { no: 0, name: "LEARNING" },
    { no: 1, name: "REVIEW" },
    { no: 2, name: "RELEARNING" },
    { no: 3, name: "FILTERED" },
    { no: 4, name: "MANUAL" },
    { no: 5, name: "RESCHEDULED" }
  ]);
  var CardEntry = class _CardEntry extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: int64 id = 1;
       */
      this.id = protoInt64.zero;
      /**
       * @generated from field: int64 note_id = 2;
       */
      this.noteId = protoInt64.zero;
      /**
       * @generated from field: int64 deck_id = 3;
       */
      this.deckId = protoInt64.zero;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.CardEntry";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 2,
          name: "note_id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 3,
          name: "deck_id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _CardEntry().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CardEntry().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CardEntry().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_CardEntry, a4, b10);
    }
  };
  var DeckEntry = class _DeckEntry extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: int64 id = 1;
       */
      this.id = protoInt64.zero;
      /**
       * @generated from field: int64 parent_id = 2;
       */
      this.parentId = protoInt64.zero;
      /**
       * @generated from field: int64 preset_id = 3;
       */
      this.presetId = protoInt64.zero;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.DeckEntry";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 2,
          name: "parent_id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 3,
          name: "preset_id",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _DeckEntry().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _DeckEntry().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _DeckEntry().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_DeckEntry, a4, b10);
    }
  };
  var Dataset = class _Dataset extends Message {
    constructor(data2) {
      super();
      /**
       * @generated from field: repeated anki.stats.RevlogEntry revlogs = 1;
       */
      this.revlogs = [];
      /**
       * @generated from field: repeated anki.stats.CardEntry cards = 2;
       */
      this.cards = [];
      /**
       * @generated from field: repeated anki.stats.DeckEntry decks = 3;
       */
      this.decks = [];
      /**
       * @generated from field: int64 next_day_at = 4;
       */
      this.nextDayAt = protoInt64.zero;
      proto3.util.initPartial(data2, this);
    }
    static {
      this.runtime = proto3;
    }
    static {
      this.typeName = "anki.stats.Dataset";
    }
    static {
      this.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "revlogs", kind: "message", T: RevlogEntry, repeated: true },
        { no: 2, name: "cards", kind: "message", T: CardEntry, repeated: true },
        { no: 3, name: "decks", kind: "message", T: DeckEntry, repeated: true },
        {
          no: 4,
          name: "next_day_at",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        }
      ]);
    }
    static fromBinary(bytes, options) {
      return new _Dataset().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _Dataset().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _Dataset().fromJsonString(jsonString, options);
    }
    static equals(a4, b10) {
      return proto3.util.equals(_Dataset, a4, b10);
    }
  };

  // src/ts/root.ts
  async function decodeResponse(resp) {
    const blob = await resp.blob();
    const respBuf = await new Response(blob).arrayBuffer();
    const bytes = new Uint8Array(respBuf);
    return GraphsResponse.fromBinary(bytes);
  }
  var encoder = new TextEncoder();
  var realFetch = fetch;
  function decodeRequest(req) {
    if (typeof req == "string") {
      req = encoder.encode(req);
    }
    return GraphsRequest.fromBinary(req);
  }
  function searchJoin(user, added) {
    if (user && added) {
      return `(${user}) (${added})`;
    } else if (user && !added) {
      return user;
    } else if (!user && added) {
      return added;
    } else {
      return "";
    }
  }
  function bodySwap(req, newSearch) {
    const request = decodeRequest(req);
    request.search = searchJoin(request?.search, newSearch);
    return request.toBinary();
  }
  async function fetchAndDecode(fetchPromise) {
    const resp = await fetchPromise;
    return await decodeResponse(resp);
  }
  function patchFetch() {
    fetch = (req, headers) => {
      if (req == "/_anki/graphs") {
        let fetchSwappedSearch2 = function(criteria) {
          headers.body = bodySwap(origBody, criteria);
          return fetchAndDecode(realFetch(req, headers));
        };
        var fetchSwappedSearch = fetchSwappedSearch2;
        data.set(null);
        mature_data.set(null);
        learn_data.set(null);
        relearn_data.set(null);
        not_suspended_data.set(null);
        const origBody = headers.body;
        const search_request = decodeRequest(origBody);
        graphsRequest.set(search_request);
        const cidSearch = search(search_request?.search);
        cidSearch.then(getCardData).then(card_data.set);
        cidSearch.then(cids.set);
        fetchAndDecode(realFetch(req, headers)).then(data.set);
        fetchSwappedSearch2("prop:ivl>=21").then(mature_data.set);
        fetchSwappedSearch2("is:learn").then(learn_data.set);
        fetchSwappedSearch2("is:learn is:review").then(relearn_data.set);
        fetchSwappedSearch2("-is:suspended").then(not_suspended_data.set);
        headers.body = origBody;
      }
      return realFetch(req, headers);
    };
  }

  // src/ts/search.ts
  function catchErrors(func) {
    try {
      return func();
    } catch (e) {
      alert(`Search Stats Extended has encountered an error.

--- *** If you have recently updated the addon please ensure you have restarted Anki. *** ---

JS:
${e?.stack ? e.stack : e}`);
      throw e;
    }
  }
  async function endpoint(endpoint2, body) {
    const resp = await realFetch(`/_anki/${endpoint2}`, {
      method: "POST",
      body,
      headers: { "Content-Type": "application/binary" }
    });
    if (!resp.ok) {
      alert(`Search Stats Extended has encountered an error.

--- *** If you have recently updated the addon please ensure you have restarted Anki. *** ---




If the problem persists copy the following information into a github issue (https://github.com/Luc-Mcgrady/Anki-Search-Stats-Extended/issues/new) with a description of what you were doing at the time:

Fetch Response: ${resp.status}
${await resp.text()}`);
      throw resp.status;
    }
    const blob = await resp.text();
    return JSON.parse(blob);
  }
  async function search(search2) {
    return await endpoint("cardSearch", search2);
  }
  function getExtraDataFromCard(card) {
    return JSON.parse(card.data);
  }
  function getCardDecay(card) {
    return getDecay(getExtraDataFromCard(card));
  }
  function getDecay(data2) {
    return data2.decay ?? L;
  }
  async function getCardData(cids2) {
    return await endpoint("cardData", JSON.stringify(cids2));
  }
  async function saveConfigValue(key, value) {
    await endpoint("writeConfig", JSON.stringify({ key, value }));
  }
  async function getRevlogs(cids2, day_range) {
    return await endpoint("revlogs", JSON.stringify({ cids: cids2, day_range }));
  }
  function browserSearch(search2) {
    window.bridgeCommand(`browserSearch:${search2}`);
  }
  function browserSearchCids(cids2) {
    browserSearch(`cid:${cids2.join(",")}`);
  }

  // src/ts/stores.ts
  var data = writable(null);
  var not_suspended_data = writable(null);
  var mature_data = writable(null);
  var learn_data = writable(null);
  var relearn_data = writable(null);
  var graphsRequest = writable(null);
  var searchString = derived2(graphsRequest, (searchRequest) => searchRequest?.search ?? null);
  var searchLimit = derived2(graphsRequest, (searchRequest) => searchRequest?.days ?? 0);
  var cids = writable(null);
  var card_data = writable(null);
  var revlogs = writable(null);
  var include_suspended = writable(false);
  var zero_inclusive = writable(false);
  var custom_pie_mode = writable("Count");
  var graph_mode = writable("Pie");
  var other = writable();
  var config = writable();
  var showRevlogStats = writable(false);
  var shownCategories = writable(SSEconfig.categories ?? {});
  shownCategories.subscribe(($shownCategories) => saveConfigValue("categories", $shownCategories));
  var pieLast = writable(59);
  var pieSteps = writable(10);
  var scroll = writable(0);
  var binSize = writable(1);
  var target_R_days = writable([]);
  var memorised_stats = writable(void 0);
  var tooltip = writable({
    text: [""],
    x: 0,
    y: 0
  });
  var tooltipShown = writable(false);
  var updateRevlogs = () => {
    const $cids = get2(cids);
    const $showRevlogStats = get2(showRevlogStats);
    const $date_range = get2(searchLimit);
    revlogs.set(null);
    if ($showRevlogStats && $cids) {
      return getRevlogs($cids, $date_range).then(revlogs.set);
    }
  };
  searchString.subscribe(() => showRevlogStats.set(!get2(config)?.confirmExpensiveStats || false));
  cids.subscribe(updateRevlogs);
  showRevlogStats.subscribe(updateRevlogs);
  tooltipShown.subscribe(
    () => setTimeout(() => {
      if (!get2(tooltipShown)) {
        tooltip.update(($tooltip) => ({ text: $tooltip.text, x: 0, y: 0 }));
      }
    }, 1e3)
  );
  config.subscribe(
    ($config) => graph_mode.set($config?.graphMode?.toLowerCase() == "bar" ? "Bar" : "Pie")
  );

  // src/ts/tooltip.ts
  function tooltipX(e) {
    return e.pageX - e.pageX / document.body.scrollWidth * 200;
  }
  var day_ms = 24 * 60 * 60 * 1e3;
  function tooltipDate(index4, width2) {
    const left_date = new Date(Date.now() + day_ms * index4);
    const right_date = new Date(Date.now() + day_ms * (index4 + width2 - 1));
    return left_date.toLocaleDateString() + (width2 > 1 ? `-${right_date.toLocaleDateString()}` : "");
  }

  // src/ts/bar.ts
  var { width, height } = defaultGraphBounds();
  function defaultX3(labels) {
    return band().domain(labels).range([0, width]).padding(0.1);
  }
  function defaultY3(min4, max5) {
    return linear3().domain([max5, min4]).range([0, height]);
  }
  function createAxis(svg2, tick_spacing = 1, x5, y5, bounds = defaultGraphBounds()) {
    select_default2(svg2).selectAll("g").remove();
    const axis2 = select_default2(svg2).attr("viewBox", `-40 -10 ${bounds.width + 50} ${bounds.height + 50}`).append("g");
    axis2.append("g").call(axisLeft(y5)).attr("opacity", 0.5);
    axis2.append("g").attr("transform", `translate(0, ${bounds.height})`).attr("opacity", 0.5).call(
      axisBottom(x5).tickValues(
        x5.domain().filter(function(d, i) {
          return !(i % tick_spacing);
        })
      )
    );
    return axis2;
  }
  var limit_area_border = 2;
  function SetDateInfinite() {
    ;
    document.querySelector(
      "body > div:nth-child(1) > div > div:nth-child(3) > label:nth-child(2)"
    ).click();
  }
  function limitArea(chart, width2, height2 = defaultGraphBounds().height) {
    const { svg: svg2 } = chart;
    svg2.append("rect").attr("x", limit_area_border).attr("y", 0).attr("height", height2).attr("width", width2).attr("fill", "url(#stripe)").style("outline", "red 2px solid").style("outline-offset", `-${limit_area_border}px`).style("cursor", "pointer").style("display", width2 <= 0 ? "none" : "default").on("mouseover", (e) => {
      tooltipShown.set(true);
      tooltip.set({
        text: [
          'To calculate this area, select "all history" under the search bar.',
          "Alternatively, click here."
        ],
        x: tooltipX(e),
        y: e.pageY
      });
    }).on("mouseleave", () => tooltipShown.set(false)).on("click", () => {
      SetDateInfinite();
      tooltipShown.set(false);
    });
  }
  function limit_area_width(x5, limit, offset, binSize2, min4, realOffset) {
    if (limit === -1) {
      return 0;
    }
    const absOffset = Math.abs(offset);
    if (realOffset === void 0) {
      realOffset = -absOffset;
    }
    const limitBin = Math.ceil((limit + absOffset) / binSize2) * binSize2 + min4 - absOffset;
    return x5(limitBin.toString()) ?? (realOffset < limitBin ? defaultGraphBounds().width - limit_area_border : 0);
  }
  function hoverBars(axis2, x5, data2) {
    const { height: height2 } = defaultGraphBounds();
    return axis2.append("g").selectAll("g").data(data2).join("rect").attr("class", "hover-bar").attr("height", height2).attr("width", x5.bandwidth()).attr("x", (d) => x5(d.label)).attr("y", 0);
  }
  function renderBarChart(chart, svg2) {
    const max5 = import_lodash2.default.maxBy(chart.data, (d) => import_lodash2.default.sum(Object.values(d?.values ?? [])));
    const maxValue = import_lodash2.default.sum(Object.values(max5?.values ?? []));
    const x5 = defaultX3(chart.data.map((datum2) => datum2.label));
    const y5 = defaultY3(0, maxValue);
    const axis2 = createAxis(svg2, chart.tick_spacing, x5, y5);
    const stack2 = stack_default().keys(import_lodash2.default.range(0, chart.row_labels.length)).value((obj, key) => obj.values[key])(chart.data);
    const {
      columnLabeler = (a4) => `"${a4}"`,
      extraStats = totalCalc,
      column_counts = true,
      precision = 2
    } = chart;
    axis2.append("g").selectAll("g").data(stack2).join("g").attr("fill", (d) => chart.row_colours[d.key]).selectAll("rect").data((d) => d).join("rect").attr("x", (d) => x5(d.data.label)).attr("y", (d) => y5(d[1])).attr("height", (d) => y5(d[0]) - y5(d[1])).attr("width", x5.bandwidth());
    hoverBars(axis2, x5, chart.data).on("mouseover", function(e, d) {
      const columnString = columnLabeler(d.label, chart.barWidth);
      const columnCounts = column_counts ? d.values.map(
        (v3, i) => `${chart.row_labels[i]}: ${parseFloat(v3.toFixed(precision))}`
      ) : [];
      tooltipShown.set(true);
      tooltip.set({
        text: [columnString, ...columnCounts, ...extraStats(d)],
        x: tooltipX(e),
        y: e.pageY
      });
    }).on("mouseleave", () => tooltipShown.set(false)).on("click", (_25, d) => {
      if (d.onClick) {
        d.onClick();
      }
    }).style("cursor", (d) => d.onClick ? "pointer" : "default");
    return { x: x5, y: y5, svg: axis2, maxValue, chart };
  }
  function barDateLabeler(label, width2 = 1) {
    return tooltipDate(+label, width2) + ":";
  }
  function barHourLabeler(hour) {
    return `${hour.padStart(2, "0")}:00`;
  }
  function barStringLabeler(pattern) {
    return (label, width2 = 1) => {
      const rightmost = width2 > 1 ? `-${import_lodash2.default.round(+label + width2 - 1, 2)}` : "";
      const value = `${label}${rightmost}`;
      return i18n_bundle.formatPattern(pattern, { value });
    };
  }
  function rangeBarStringLabeler(pattern, x5) {
    return (label, width2 = 1) => {
      const rightmost = width2 > 1 ? `-${+label + width2 - 1}` : "";
      const value = `${label}${rightmost}`;
      return i18n_bundle.formatPattern(pattern, { range: value, x: x5 });
    };
  }

  // src/ts/NoGraph.svelte
  var root3 = template(`<div class="svelte-mu9flq"><!></div>`);
  function NoGraph($$anchor, $$props) {
    push($$props, false);
    let faded = prop($$props, "faded", 8, true);
    init();
    var div = root3();
    var node = child(div);
    slot(node, $$props, "default", {}, ($$anchor2) => {
      var text2 = text();
      template_effect(($0) => set_text(text2, $0), [() => i18n("no-data")], derived_safe_equal);
      append($$anchor2, text2);
    });
    reset(div);
    template_effect(() => set_style(div, "opacity", faded() ? 0.5 : 1));
    append($$anchor, div);
    pop();
  }

  // src/ts/Bar.svelte
  var root_3 = template(`<div><span>\u25A0&nbsp;</span> </div>`);
  var root_2 = template(`<div class="glossary svelte-tlw5tc"></div> <svg><pattern id="stripe" patternUnits="userSpaceOnUse" width="10" height="10" patternTransform="rotate(45)"><line x1="0" y="0" x2="0" y2="10" stroke="#921717" stroke-width="10"></line></pattern></svg>`, 1);
  function Bar($$anchor, $$props) {
    push($$props, false);
    let svg2 = mutable_state(null);
    let extraRender = prop($$props, "extraRender", 8, (chart) => {
    });
    let data2 = prop($$props, "data", 8);
    let glossary = mutable_state();
    legacy_pre_effect(
      () => (get(svg2), deep_read_state(data2()), renderBarChart, deep_read_state(extraRender())),
      () => {
        if (get(svg2) && data2().data.length) {
          const chart = renderBarChart(data2(), get(svg2));
          extraRender()(chart);
        }
      }
    );
    legacy_pre_effect(
      () => (get(glossary), import_lodash3.default, deep_read_state(data2())),
      () => {
        set(glossary, import_lodash3.default.zip(data2().row_labels, data2().row_colours));
        if (data2().reverse_legend) set(glossary, get(glossary).reverse());
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        NoGraph($$anchor2, {});
      };
      var alternate = ($$anchor2) => {
        var fragment_2 = root_2();
        var div = first_child(fragment_2);
        each(div, 5, () => get(glossary), index, ($$anchor3, $$item) => {
          let label = () => get($$item)[0];
          let colour = () => get($$item)[1];
          var div_1 = root_3();
          var span = child(div_1);
          var text2 = sibling(span);
          reset(div_1);
          template_effect(() => {
            set_attribute(span, "style", `color:${colour()}`);
            set_text(text2, ` ${label() ?? ""}`);
          });
          append($$anchor3, div_1);
        });
        reset(div);
        var svg_1 = sibling(div, 2);
        bind_this(svg_1, ($$value) => set(svg2, $$value), () => get(svg2));
        append($$anchor2, fragment_2);
      };
      if_block(node, ($$render) => {
        if (!data2().data.length) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    pop();
  }

  // src/ts/DueBar.svelte
  function DueBar($$anchor, $$props) {
    push($$props, false);
    var _a = mutable_state(), _b = mutable_state(), _c = mutable_state(), _d = mutable_state();
    let all = prop($$props, "all", 8);
    let mature = prop($$props, "mature", 8);
    let learn = prop($$props, "learn", 8);
    let relearn = prop($$props, "relearn", 8);
    let bars = mutable_state();
    legacy_pre_effect(
      () => (deep_read_state(all()), import_lodash4.default, get(bars), safe_get(_a), safe_get(_b), deep_read_state(mature()), safe_get(_c), deep_read_state(relearn()), safe_get(_d), deep_read_state(learn())),
      () => {
        const len = Object.keys(all().futureDue).reduce((a4, b10) => a4 > +b10 ? a4 : +b10, 0);
        let newbars = import_lodash4.default.range(0, len);
        set(bars, newbars.map((i) => ({
          label: i.toString(),
          values: [0, 0, 0, 0]
        })));
        for (const day in all().futureDue) {
          const all_day = set(_a, all().futureDue[day]) !== null && safe_get(_a) !== void 0 ? safe_get(_a) : 0;
          const mature_day = set(_b, mature().futureDue[day]) !== null && safe_get(_b) !== void 0 ? safe_get(_b) : 0;
          const relearn_day = set(_c, relearn().futureDue[day]) !== null && safe_get(_c) !== void 0 ? safe_get(_c) : 0;
          const learn_day = (set(_d, learn().futureDue[day]) !== null && safe_get(_d) !== void 0 ? safe_get(_d) : 0) - relearn_day;
          const young_day = all_day - learn_day - relearn_day - mature_day;
          mutate(bars, get(bars)[+day] = {
            label: day,
            values: [
              mature_day,
              young_day,
              relearn_day,
              learn_day
            ]
          });
        }
        set(bars, get(bars).slice(0, 30));
      }
    );
    legacy_pre_effect_reset();
    init();
    const expression = derived_safe_equal(() => ({
      row_colours: [
        MATURE_COLOUR,
        YOUNG_COLOUR,
        RELEARN_COLOUR,
        LEARN_COLOUR
      ],
      row_labels: [
        i18n("mature-count"),
        i18n("young-count"),
        i18n("relearning-count"),
        i18n("learning-count")
      ],
      data: get(bars),
      tick_spacing: 5,
      columnLabeler: barDateLabeler
    }));
    Bar($$anchor, {
      get data() {
        return get(expression);
      }
    });
    pop();
  }

  // src/ts/IntervalBar.svelte
  var import_lodash7 = __toESM(require_lodash());

  // src/ts/BarScrollable.svelte
  var import_lodash6 = __toESM(require_lodash());

  // src/ts/TrendValue.svelte
  var root_22 = template(` <br>`, 1);
  var root_1 = template(`<br> <div><!> </div>`, 1);
  function TrendValue($$anchor, $$props) {
    push($$props, false);
    const pattern = mutable_state();
    const percentage = mutable_state();
    const absolute = mutable_state();
    const trend_day_value = mutable_state();
    let trend = prop($$props, "trend", 8);
    let n = prop($$props, "n", 8, 1);
    let info = prop($$props, "info", 24, () => ({}));
    let trend_value = mutable_state();
    function display(trend_value2) {
      return (trend_value2 > 1 ? trend_value2.toFixed(2) : trend_value2.toPrecision(2)) + (get(percentage) ? "%" : "");
    }
    legacy_pre_effect(
      () => (get(pattern), get(percentage), get(absolute), deep_read_state(info())),
      () => {
        (($$value) => (set(pattern, fallback($$value.pattern, "")), set(percentage, fallback($$value.percentage, false)), set(absolute, fallback($$value.absolute, false))))(info());
      }
    );
    legacy_pre_effect(
      () => (deep_read_state(trend()), get(trend_value), deep_read_state(n()), get(percentage), get(absolute)),
      () => {
        if (trend()) {
          set(trend_value, (trend().calcY(n()) - trend().yStart) * (get(percentage) ? 100 : 1));
          if (get(absolute)) {
            set(trend_value, Math.abs(get(trend_value)));
          }
        }
      }
    );
    legacy_pre_effect(
      () => (get(trend_value), deep_read_state(n())),
      () => {
        set(trend_day_value, get(trend_value) / n());
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent_1 = ($$anchor2) => {
        var fragment_1 = root_1();
        var text2 = sibling(first_child(fragment_1));
        var div = sibling(text2);
        var node_1 = child(div);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = root_22();
            var text_1 = first_child(fragment_2);
            next();
            template_effect(
              ($0) => set_text(text_1, `${$0 ?? ""} `),
              [
                () => i18n_bundle.formatPattern(get(pattern), {
                  n: 1,
                  value: display(get(trend_day_value))
                })
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_2);
          };
          if_block(node_1, ($$render) => {
            if (n() > 1) $$render(consequent);
          });
        }
        var text_2 = sibling(node_1);
        reset(div);
        template_effect(
          ($0, $1) => {
            set_text(text2, ` ${$0 ?? ""} = `);
            set_text(text_2, ` ${$1 ?? ""}`);
          },
          [
            () => i18n("trend"),
            () => i18n_bundle.formatPattern(get(pattern), {
              n: n(),
              value: display(get(trend_value))
            })
          ],
          derived_safe_equal
        );
        append($$anchor2, fragment_1);
      };
      if_block(node, ($$render) => {
        if (get(trend_value)) $$render(consequent_1);
      });
    }
    append($$anchor, fragment);
    pop();
  }

  // src/ts/trend.ts
  var import_lodash5 = __toESM(require_lodash());

  // node_modules/trendline/dist/index.mjs
  function getAverage(arr) {
    const total = arr.reduce((acc, c6) => acc + c6, 0);
    return total / arr.length;
  }
  function getSum(arr) {
    return arr.reduce((acc, c6) => acc + c6, 0);
  }
  function createTrend(data2, xKey, yKey) {
    const xData = data2.map((value) => value[xKey]);
    const yData = data2.map((value) => value[yKey]);
    const xMean = getAverage(xData);
    const yMean = getAverage(yData);
    const xMinusxMean = xData.map((val) => val - xMean);
    const yMinusyMean = yData.map((val) => val - yMean);
    const xMinusxMeanSq = xMinusxMean.map((val) => Math.pow(val, 2));
    const xy = [];
    for (let x5 = 0; x5 < data2.length; x5++) {
      xy.push(xMinusxMean[x5] * yMinusyMean[x5]);
    }
    const xySum = getSum(xy);
    const b12 = xySum / getSum(xMinusxMeanSq);
    const b02 = yMean - b12 * xMean;
    return {
      slope: b12,
      yStart: b02,
      calcY: (x5) => b02 + b12 * x5
    };
  }
  var src_default = createTrend;

  // src/ts/trend.ts
  function trendLine({ svg: svg2, x: x5, y: y5 }, data2) {
    if (!SSEconfig.trends) {
      return;
    }
    data2 = data2.filter((a4) => !!a4.y);
    const trend = src_default(data2, "x", "y");
    const leftmost = import_lodash5.default.minBy(data2, (datum2) => datum2.x);
    const rightmost = import_lodash5.default.maxBy(data2, (datum2) => datum2.x);
    if (rightmost == void 0 || leftmost == void 0) {
      return;
    }
    const half_step = x5.step() / 2;
    svg2.append("line").attr("x1", (x5(leftmost.x.toString()) ?? 0) + half_step).attr("y1", y5(trend.calcY(leftmost.x))).attr("x2", (x5(rightmost.x.toString()) ?? 0) + half_step).attr("y2", y5(trend.calcY(rightmost.x))).style("stroke", "black").style("stroke-width");
    return trend;
  }

  // src/ts/BarScrollable.svelte
  var root4 = template(`<div class="options svelte-1d6gow"><label class="svelte-1d6gow"> <input type="number" class="svelte-1d6gow"></label> <label class="svelte-1d6gow"> <input type="number" class="svelte-1d6gow"></label></div> <!> <!>`, 1);
  function BarScrollable($$anchor, $$props) {
    push($$props, false);
    const min4 = mutable_state();
    const absOffset = mutable_state();
    const realOffset = mutable_state();
    const leftmost = mutable_state();
    const seperate_bars = mutable_state();
    let data2 = prop($$props, "data", 8);
    let extraRender = prop($$props, "extraRender", 8, (chart) => {
    });
    let binSize2 = prop($$props, "binSize", 12, 1);
    let offset = prop($$props, "offset", 12, 0);
    let bins = prop($$props, "bins", 8, 30);
    let average = prop($$props, "average", 8, false);
    let left_aligned = prop($$props, "left_aligned", 8, false);
    let limit = prop($$props, "limit", 24, () => -1);
    let trend = prop($$props, "trend", 8, false);
    let trend_by = prop($$props, "trend_by", 24, () => import_lodash6.default.sum);
    let trend_info = prop($$props, "trend_info", 24, () => ({}));
    let loss = prop($$props, "loss", 8, false);
    let trend_values = prop($$props, "trend_values", 12, void 0);
    function inner_extra_render(chart) {
      extraRender()(chart);
      limitArea(chart, limit_area_width(chart.x, limit(), offset(), binSize2(), get(min4), get(realOffset)));
      const trend_data = chart.chart.data.map((datum2) => ({
        x: +datum2.label,
        y: trend_by()(datum2.values)
      }));
      if (trend()) {
        trend_values(trendLine(chart, trend_data));
      } else {
        trend_values(void 0);
      }
    }
    let bars = mutable_state();
    legacy_pre_effect(() => deep_read_state(left_aligned()), () => {
      set(min4, left_aligned() ? 0 : 1);
    });
    legacy_pre_effect(() => deep_read_state(offset()), () => {
      set(absOffset, Math.abs(offset()));
    });
    legacy_pre_effect(() => deep_read_state(binSize2()), () => {
      binSize2(binSize2() > 0 ? binSize2() : 1);
    });
    legacy_pre_effect(
      () => (deep_read_state(left_aligned()), get(absOffset), deep_read_state(bins()), deep_read_state(binSize2()), get(min4)),
      () => {
        set(realOffset, left_aligned() ? get(absOffset) + bins() * binSize2() + get(min4) : -get(absOffset));
      }
    );
    legacy_pre_effect(
      () => (get(realOffset), deep_read_state(bins()), deep_read_state(binSize2())),
      () => {
        set(leftmost, get(realOffset) - bins() * binSize2());
      }
    );
    legacy_pre_effect(
      () => (deep_read_state(data2()), get(leftmost), get(realOffset)),
      () => {
        set(seperate_bars, data2().data.slice(get(leftmost), get(realOffset) == 0 || get(realOffset) >= data2().data.length ? void 0 : get(realOffset)));
      }
    );
    legacy_pre_effect(
      () => (get(bars), import_lodash6.default, get(leftmost), get(realOffset), deep_read_state(binSize2()), get(min4), deep_read_state(loss()), deep_read_state(data2()), get(seperate_bars), deep_read_state(average())),
      () => {
        set(bars, import_lodash6.default.range(get(leftmost), get(realOffset), binSize2()).map((i) => ({
          label: (i + get(min4)).toString(),
          values: loss() ? [0, 0] : data2().row_labels.map((_25) => 0)
        })));
        for (const [i, bar] of get(seperate_bars).entries()) {
          const newIndex = Math.floor(i / binSize2());
          mutate(bars, get(bars)[newIndex].values = get(bars)[newIndex].values.map((a4, i2) => a4 + ((bar === null || bar === void 0 ? void 0 : bar.values) ? (bar === null || bar === void 0 ? void 0 : bar.values[i2]) || 0 : 0)));
        }
        if (average()) {
          get(bars).map((bar, i) => {
            const count3 = get(seperate_bars).slice(i * binSize2(), (i + 1) * binSize2()).reduce((p, n) => p + (import_lodash6.default.sum(n.values) > 0 ? 1 : 0), 0);
            if (loss()) {
              bar.values = bar.values ? [Math.sqrt(bar.values[0] / bar.values[1])] : [0, 0];
            } else {
              bar.values = bar.values.map((a4) => a4 / (count3 || 1));
            }
          });
        }
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = root4();
    var div = first_child(fragment);
    var label = child(div);
    var text2 = child(label);
    var input = sibling(text2);
    remove_input_defaults(input);
    reset(label);
    var label_1 = sibling(label, 2);
    var text_1 = child(label_1);
    var input_1 = sibling(text_1);
    remove_input_defaults(input_1);
    reset(label_1);
    reset(div);
    var node = sibling(div, 2);
    const expression = derived_safe_equal(() => ({
      ...data2(),
      data: get(bars),
      barWidth: binSize2()
    }));
    Bar(node, {
      get data() {
        return get(expression);
      },
      extraRender: inner_extra_render
    });
    var node_1 = sibling(node, 2);
    {
      var consequent = ($$anchor2) => {
        TrendValue($$anchor2, {
          get trend() {
            return trend_values();
          },
          get n() {
            return binSize2();
          },
          get info() {
            return trend_info();
          }
        });
      };
      if_block(node_1, ($$render) => {
        if (trend_values()) $$render(consequent);
      });
    }
    template_effect(
      ($0, $1) => {
        set_text(text2, `${$0 ?? ""} `);
        set_text(text_1, `${$1 ?? ""} `);
        set_attribute(input_1, "step", binSize2());
      },
      [
        () => i18n("bar-width"),
        () => i18n("scroll")
      ],
      derived_safe_equal
    );
    bind_value(input, binSize2);
    bind_value(input_1, offset);
    append($$anchor, fragment);
    pop();
  }

  // src/ts/IntervalBar.svelte
  function IntervalBar($$anchor, $$props) {
    push($$props, false);
    var _a = mutable_state(), _b = mutable_state(), _c = mutable_state(), _d = mutable_state();
    let intervals = prop($$props, "intervals", 8);
    let pieInfo = prop($$props, "pieInfo", 24, () => ({}));
    let binSize2 = prop($$props, "binSize", 12, 1);
    let offset = prop($$props, "offset", 12, 0);
    let interval_array = mutable_state([]);
    let bar_data = mutable_state();
    legacy_pre_effect(() => deep_read_state(intervals()), () => {
      set(interval_array, []);
      for (const [i, val] of Object.entries(intervals())) {
        mutate(interval_array, get(interval_array)[+i] = val);
      }
    });
    legacy_pre_effect(
      () => (safe_get(_a), deep_read_state(pieInfo()), i18n, safe_get(_b), YOUNG_COLOUR, get(interval_array), rangeBarStringLabeler, safe_get(_c), i18n_bundle, safe_get(_d)),
      () => {
        set(bar_data, {
          row_labels: [
            set(_a, pieInfo().legend_right) !== null && safe_get(_a) !== void 0 ? safe_get(_a) : i18n("cards")
          ],
          row_colours: [
            set(_b, pieInfo().spectrumFrom) !== null && safe_get(_b) !== void 0 ? safe_get(_b) : YOUNG_COLOUR
          ],
          data: Array.from(get(interval_array)).map((val, i) => ({
            values: [val !== null && val !== void 0 ? val : 0],
            label: i.toString()
          })),
          columnLabeler: rangeBarStringLabeler(set(_c, i18n_bundle.getMessage("x-in-range")) === null || safe_get(_c) === void 0 ? void 0 : safe_get(_c).value, set(_d, pieInfo().legend_left) !== null && safe_get(_d) !== void 0 ? safe_get(_d) : i18n("interval")),
          tick_spacing: 5
        });
      }
    );
    legacy_pre_effect_reset();
    init();
    BarScrollable($$anchor, {
      get data() {
        return get(bar_data);
      },
      left_aligned: true,
      get binSize() {
        return binSize2();
      },
      set binSize($$value) {
        binSize2($$value);
      },
      get offset() {
        return offset();
      },
      set offset($$value) {
        offset($$value);
      },
      $$legacy: true
    });
    pop();
  }

  // src/ts/IntervalPie.svelte
  var import_lodash9 = __toESM(require_lodash());
  var import_rainbowvis = __toESM(require_rainbowvis());

  // src/ts/Pie.svelte
  var import_lodash8 = __toESM(require_lodash());

  // src/ts/pie.ts
  function PieDatumFactory(start2, end, value, colour) {
    return {
      label: start2 != end ? `${start2}-${end}` : `${start2}`,
      value,
      colour
    };
  }
  function renderPie(data2, svg2, radius) {
    const pie = pie_default().value((d) => d.value).sort(null);
    const data_ready = pie(data2);
    select_default2(svg2).selectAll("slices").data(data_ready).enter().append("path").attr("d", arc_default().innerRadius(0).outerRadius(radius)).attr("fill", (d) => d.data.colour);
  }

  // src/ts/Pie.svelte
  var root_32 = template(`<span class="colour svelte-q9ruih">\u25A0&nbsp;</span> <span> </span> <span> </span> <!>`, 1);
  var root_12 = template(`<div class="root svelte-q9ruih"><svg><g></g></svg> <div class="glossary svelte-q9ruih"><div class="grid svelte-q9ruih"><span></span> <span> </span> <span> </span> <!> <!></div></div></div>`);
  function Pie($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $config = () => store_get(config, "$config", $$stores);
    const total = mutable_state();
    let data2 = prop($$props, "data", 8);
    let svg2 = mutable_state(null);
    let legend_left = prop($$props, "legend_left", 8, "");
    let legend_right = prop($$props, "legend_right", 8, "");
    let percentage = prop($$props, "percentage", 24, () => $config().piePercentages);
    const diameter = 250;
    legacy_pre_effect(() => (import_lodash8.default, deep_read_state(data2())), () => {
      set(total, import_lodash8.default.sumBy(data2(), (d) => d.value));
    });
    legacy_pre_effect(
      () => (renderPie, deep_read_state(data2()), get(svg2)),
      () => {
        renderPie(data2(), get(svg2), diameter / 2);
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent_2 = ($$anchor2) => {
        var div = root_12();
        var svg_1 = child(div);
        set_attribute(svg_1, "width", diameter);
        set_attribute(svg_1, "height", diameter);
        var g = child(svg_1);
        set_attribute(g, "transform", `translate(${diameter / 2},${diameter / 2})`);
        bind_this(g, ($$value) => set(svg2, $$value), () => get(svg2));
        reset(svg_1);
        var div_1 = sibling(svg_1, 2);
        set_style(div_1, "max-height", `${diameter}px`);
        var div_2 = child(div_1);
        var span = sibling(child(div_2), 2);
        var text2 = child(span);
        reset(span);
        var span_1 = sibling(span, 2);
        var text_1 = child(span_1, true);
        reset(span_1);
        var node_1 = sibling(span_1, 2);
        {
          var consequent = ($$anchor3) => {
            var text_2 = text("%");
            append($$anchor3, text_2);
          };
          if_block(node_1, ($$render) => {
            if (percentage()) $$render(consequent);
          });
        }
        var node_2 = sibling(node_1, 2);
        each(node_2, 1, data2, index, ($$anchor3, datum2) => {
          var fragment_1 = root_32();
          var span_2 = first_child(fragment_1);
          var span_3 = sibling(span_2, 2);
          var text_3 = child(span_3);
          reset(span_3);
          var span_4 = sibling(span_3, 2);
          var text_4 = child(span_4, true);
          reset(span_4);
          var node_3 = sibling(span_4, 2);
          {
            var consequent_1 = ($$anchor4) => {
              var text_5 = text();
              template_effect(
                ($0) => set_text(text_5, `${$0 ?? ""}%`),
                [
                  () => import_lodash8.default.round(100 * get(datum2).value / get(total), 2)
                ],
                derived_safe_equal
              );
              append($$anchor4, text_5);
            };
            if_block(node_3, ($$render) => {
              if (percentage()) $$render(consequent_1);
            });
          }
          template_effect(
            ($0) => {
              set_style(span_2, "color", get(datum2).colour);
              set_text(text_3, `${get(datum2).label ?? ""}:`);
              set_text(text_4, $0);
            },
            [
              () => import_lodash8.default.round(get(datum2).value, 2).toLocaleString()
            ],
            derived_safe_equal
          );
          append($$anchor3, fragment_1);
        });
        reset(div_2);
        reset(div_1);
        reset(div);
        template_effect(() => {
          set_style(div_2, "grid-template-columns", percentage() ? "auto auto auto 6ch" : void 0);
          set_text(text2, `${legend_left() ?? ""}:`);
          set_text(text_1, legend_right());
        });
        append($$anchor2, div);
      };
      var alternate = ($$anchor2) => {
        NoGraph($$anchor2, {});
      };
      if_block(node, ($$render) => {
        if (import_lodash8.default.sumBy(data2(), (d) => d.value)) $$render(consequent_2);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/IntervalPie.svelte
  var root5 = template(`<div class="options svelte-16kcmvk"><label class="svelte-16kcmvk"> <input type="number"></label> <label class="svelte-16kcmvk"> <input type="number"></label></div> <!> <br> <!> <div class="totals svelte-16kcmvk"><span class="svelte-16kcmvk"> </span> <span class="svelte-16kcmvk"> </span> <span class="svelte-16kcmvk"> </span> <span class="svelte-16kcmvk"> </span></div>`, 1);
  function IntervalPie($$anchor, $$props) {
    push($$props, false);
    const legend_left = mutable_state();
    const legend_right = mutable_state();
    const countDescriptor = mutable_state();
    const totalDescriptor = mutable_state();
    const spectrumFrom = mutable_state();
    const spectrumTo = mutable_state();
    const fillerColour = mutable_state();
    const min4 = mutable_state();
    const step = mutable_state();
    const realLast = mutable_state();
    const pie_values = mutable_state();
    var _a = mutable_state();
    let intervals = prop($$props, "intervals", 8);
    let steps = prop($$props, "steps", 12, 7);
    let last = prop($$props, "last", 12, 21);
    let pieInfo = prop($$props, "pieInfo", 24, () => ({}));
    const gradient = new import_rainbowvis.default();
    let pie_data = mutable_state();
    legacy_pre_effect(
      () => (get(legend_left), i18n, get(legend_right), get(countDescriptor), get(totalDescriptor), get(spectrumFrom), get(spectrumTo), get(fillerColour), deep_read_state(pieInfo())),
      () => {
        (($$value) => (set(legend_left, fallback($$value.legend_left, () => i18n("intervals"), true)), set(legend_right, fallback($$value.legend_right, () => i18n("cards"), true)), set(countDescriptor, fallback($$value.countDescriptor, () => i18n("last-day"), true)), set(totalDescriptor, fallback($$value.totalDescriptor, () => i18n("cards"), true)), set(spectrumFrom, fallback($$value.spectrumFrom, "#74C476")), set(spectrumTo, fallback($$value.spectrumTo, "#014720")), set(fillerColour, fallback($$value.fillerColour, "gold"))))(pieInfo());
      }
    );
    legacy_pre_effect(() => deep_read_state(steps()), () => {
      if (steps() < 1) {
        steps(1);
      }
    });
    legacy_pre_effect(() => deep_read_state(last()), () => {
      if (last() < 0) {
        last(0);
      }
    });
    legacy_pre_effect(
      () => (safe_get(_a), import_lodash9.default, deep_read_state(intervals())),
      () => {
        set(min4, set(_a, import_lodash9.default.min(Object.keys(intervals()).filter((k3) => k3 !== void 0).map(parseInt))) !== null && safe_get(_a) !== void 0 ? safe_get(_a) : 1);
      }
    );
    legacy_pre_effect(
      () => (deep_read_state(last()), get(min4), deep_read_state(steps())),
      () => {
        set(step, Math.floor((last() - get(min4) + 1) / steps()));
      }
    );
    legacy_pre_effect(
      () => (deep_read_state(steps()), get(step), get(min4)),
      () => {
        set(realLast, steps() * get(step) + get(min4) - 1);
      }
    );
    legacy_pre_effect(
      () => (deep_read_state(steps()), get(spectrumFrom), get(spectrumTo)),
      () => {
        gradient.setNumberRange(0, steps() + 1);
        gradient.setSpectrum(get(spectrumFrom), get(spectrumTo));
      }
    );
    legacy_pre_effect(
      () => (get(pie_data), import_lodash9.default, get(min4), get(realLast), get(step), deep_read_state(last()), deep_read_state(intervals()), PieDatumFactory, get(fillerColour), i18n),
      () => {
        set(pie_data, import_lodash9.default.range(get(min4), get(realLast) + 1, get(step)).map((start2, i) => {
          let end = start2 + get(step);
          if (end > last() && last() != get(realLast)) {
            end = get(realLast);
          }
          const count3 = import_lodash9.default.range(start2, end).reduce((n, j2) => n + (intervals()[j2] || 0), 0);
          return PieDatumFactory(start2, end - 1, count3, `#${gradient.colourAt(i)}`);
        }));
        if (get(realLast) < last()) {
          const filler_start = get(realLast) + 1;
          const filler_end = last();
          const filler_pie_slice = Object.entries(intervals()).filter(([i, _25]) => +i >= filler_start && +i <= filler_end).reduce((n, [_25, v3]) => n + v3, 0);
          get(pie_data).push(PieDatumFactory(filler_start, filler_end, filler_pie_slice, get(fillerColour) !== null && get(fillerColour) !== void 0 ? get(fillerColour) : "gold"));
        }
        const infinite_pie_start = last() + 1;
        const infinite_pie_slice = Object.entries(intervals()).filter(([i, _25]) => +i >= infinite_pie_start).reduce((n, [_25, v3]) => n + v3, 0);
        get(pie_data).push(PieDatumFactory(infinite_pie_start, i18n("infinity"), infinite_pie_slice, "grey"));
      }
    );
    legacy_pre_effect(() => get(pie_data), () => {
      set(pie_values, Object.values(get(pie_data)).map((d) => d.value));
    });
    legacy_pre_effect_reset();
    init();
    var fragment = root5();
    var div = first_child(fragment);
    var label = child(div);
    var text2 = child(label);
    var input = sibling(text2);
    remove_input_defaults(input);
    reset(label);
    var label_1 = sibling(label, 2);
    var text_1 = child(label_1);
    var input_1 = sibling(text_1);
    remove_input_defaults(input_1);
    reset(label_1);
    reset(div);
    var node = sibling(div, 2);
    slot(node, $$props, "default", {}, null);
    var node_1 = sibling(node, 4);
    Pie(node_1, {
      get data() {
        return get(pie_data);
      },
      get legend_left() {
        return get(legend_left);
      },
      get legend_right() {
        return get(legend_right);
      }
    });
    var div_1 = sibling(node_1, 2);
    var span = child(div_1);
    var text_2 = child(span);
    reset(span);
    var span_1 = sibling(span, 2);
    var text_3 = child(span_1, true);
    reset(span_1);
    var span_2 = sibling(span_1, 2);
    var text_4 = child(span_2);
    reset(span_2);
    var span_3 = sibling(span_2, 2);
    var text_5 = child(span_3, true);
    reset(span_3);
    reset(div_1);
    template_effect(
      ($0, $1, $2, $3) => {
        set_text(text2, `${get(countDescriptor) ?? ""} `);
        set_text(text_1, `${$0 ?? ""} `);
        set_text(text_2, `${$1 ?? ""} <= ${last() ?? ""}:`);
        set_text(text_3, $2);
        set_text(text_4, `${get(totalDescriptor) ?? ""}:`);
        set_text(text_5, $3);
      },
      [
        () => i18n("steps"),
        () => get(totalDescriptor) ?? i18n("total-cards"),
        () => import_lodash9.default.round(import_lodash9.default.sum(get(pie_values).slice(0, -1)), 2).toLocaleString(),
        () => import_lodash9.default.round(import_lodash9.default.sum(get(pie_values)), 2).toLocaleString()
      ],
      derived_safe_equal
    );
    bind_value(input, last);
    bind_value(input_1, steps);
    append($$anchor, fragment);
    pop();
  }

  // src/ts/GraphTypeSelector.svelte
  var root6 = template(`<div class="svelte-qwtrzw"><!></div>`);
  function GraphTypeSelector($$anchor, $$props) {
    "use strict";
    var div = root6();
    var node = child(div);
    slot(node, $$props, "default", {}, null);
    reset(div);
    append($$anchor, div);
  }

  // src/ts/IntervalGraph.svelte
  var root_13 = template(`<label><input type="radio"> </label> <label><input type="radio"> </label>`, 1);
  var root_23 = template(`<label class="checkbox svelte-es63bz"><input type="checkbox"> </label>`);
  var root_33 = template(`<label class="checkbox svelte-es63bz"><input type="checkbox"> </label>`);
  var root7 = template(`<!> <div><!> <!></div> <!>`, 1);
  function IntervalGraph($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $graph_mode = () => store_get(graph_mode, "$graph_mode", $$stores);
    const $zero_inclusive = () => store_get(zero_inclusive, "$zero_inclusive", $$stores);
    const $include_suspended = () => store_get(include_suspended, "$include_suspended", $$stores);
    const binding_group = [];
    let include_suspended_option = prop($$props, "include_suspended_option", 8, true);
    let zero_inclusive_option = prop($$props, "zero_inclusive_option", 8, false);
    let intervals = prop($$props, "intervals", 8);
    let pieInfo = prop($$props, "pieInfo", 24, () => ({}));
    let steps = prop($$props, "steps", 12, 7);
    let last = prop($$props, "last", 12, 21);
    let pieSteps2 = mutable_state(steps());
    let pieLast2 = mutable_state(last());
    let barScroll = mutable_state(zero_inclusive_option() ? 1 : 0);
    let barSize = mutable_state(1);
    const unsubscribe = graph_mode.subscribe((mode2) => {
      if (mode2 === "Bar") {
        steps(get(barScroll));
        last(get(barSize));
      } else {
        steps(get(pieSteps2));
        last(get(pieLast2));
      }
    });
    onDestroy(unsubscribe);
    legacy_pre_effect(
      () => ($graph_mode(), deep_read_state(last()), deep_read_state(steps())),
      () => {
        if ($graph_mode() === "Pie") {
          set(pieLast2, last());
          set(pieSteps2, steps());
        } else {
          set(barScroll, steps());
          set(barSize, last());
        }
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = root7();
    var node = first_child(fragment);
    GraphTypeSelector(node, {
      children: ($$anchor2, $$slotProps) => {
        var fragment_1 = root_13();
        var label = first_child(fragment_1);
        var input = child(label);
        remove_input_defaults(input);
        input.value = null == (input.__value = "Pie") ? "" : "Pie";
        var text2 = sibling(input);
        reset(label);
        var label_1 = sibling(label, 2);
        var input_1 = child(label_1);
        remove_input_defaults(input_1);
        input_1.value = null == (input_1.__value = "Bar") ? "" : "Bar";
        var text_1 = sibling(input_1);
        reset(label_1);
        template_effect(
          ($0, $1) => {
            set_text(text2, ` ${$0 ?? ""}`);
            set_text(text_1, ` ${$1 ?? ""}`);
          },
          [() => i18n("pie"), () => i18n("bar")],
          derived_safe_equal
        );
        bind_group(binding_group, [], input, $graph_mode, ($$value) => store_set(graph_mode, $$value));
        bind_group(binding_group, [], input_1, $graph_mode, ($$value) => store_set(graph_mode, $$value));
        append($$anchor2, fragment_1);
      },
      $$slots: { default: true }
    });
    var div = sibling(node, 2);
    var node_1 = child(div);
    {
      var consequent = ($$anchor2) => {
        var label_2 = root_23();
        var input_2 = child(label_2);
        remove_input_defaults(input_2);
        var text_2 = sibling(input_2);
        reset(label_2);
        template_effect(($0) => set_text(text_2, ` ${$0 ?? ""}`), [() => i18n("zero-inclusive")], derived_safe_equal);
        bind_checked(input_2, $zero_inclusive, ($$value) => store_set(zero_inclusive, $$value));
        append($$anchor2, label_2);
      };
      if_block(node_1, ($$render) => {
        if (zero_inclusive_option() && $graph_mode() == "Pie") $$render(consequent);
      });
    }
    var node_2 = sibling(node_1, 2);
    {
      var consequent_1 = ($$anchor2) => {
        var label_3 = root_33();
        var input_3 = child(label_3);
        remove_input_defaults(input_3);
        var text_3 = sibling(input_3);
        reset(label_3);
        template_effect(($0) => set_text(text_3, ` ${$0 ?? ""}`), [() => i18n("include-suspended")], derived_safe_equal);
        bind_checked(input_3, $include_suspended, ($$value) => store_set(include_suspended, $$value));
        append($$anchor2, label_3);
      };
      if_block(node_2, ($$render) => {
        if (include_suspended_option()) $$render(consequent_1);
      });
    }
    reset(div);
    var node_3 = sibling(div, 2);
    {
      var consequent_3 = ($$anchor2) => {
        var fragment_2 = comment();
        var node_4 = first_child(fragment_2);
        {
          var consequent_2 = ($$anchor3) => {
            IntervalPie($$anchor3, {
              get intervals() {
                return intervals();
              },
              get pieInfo() {
                return pieInfo();
              },
              get last() {
                return last();
              },
              set last($$value) {
                last($$value);
              },
              get steps() {
                return steps();
              },
              set steps($$value) {
                steps($$value);
              },
              $$legacy: true
            });
          };
          var alternate = ($$anchor3) => {
            IntervalBar($$anchor3, {
              get intervals() {
                return intervals();
              },
              get pieInfo() {
                return pieInfo();
              },
              get binSize() {
                return last();
              },
              set binSize($$value) {
                last($$value);
              },
              get offset() {
                return steps();
              },
              set offset($$value) {
                steps($$value);
              },
              $$legacy: true
            });
          };
          if_block(node_4, ($$render) => {
            if ($graph_mode() == "Pie") $$render(consequent_2);
            else $$render(alternate, false);
          });
        }
        append($$anchor2, fragment_2);
      };
      var alternate_1 = ($$anchor2) => {
        NoGraph($$anchor2, {});
      };
      if_block(node_3, ($$render) => {
        if (intervals()) $$render(consequent_3);
        else $$render(alternate_1, false);
      });
    }
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/BurdenPie.svelte
  function BurdenPie($$anchor, $$props) {
    push($$props, false);
    let intervals = prop($$props, "intervals", 8);
    let last = prop($$props, "last", 12, 21);
    let steps = prop($$props, "steps", 12, 7);
    let burdens = mutable_state();
    legacy_pre_effect(
      () => (get(burdens), deep_read_state(intervals())),
      () => {
        set(burdens, Object.assign({}, intervals()));
        Object.entries(get(burdens)).forEach(([key, val]) => {
          mutate(burdens, get(burdens)[+key] = val / +key);
        });
      }
    );
    legacy_pre_effect_reset();
    init();
    const expression = derived_safe_equal(() => ({
      totalDescriptor: i18n("total-load"),
      legend_left: i18n("intervals"),
      legend_right: i18n("load")
    }));
    IntervalGraph($$anchor, {
      get intervals() {
        return get(burdens);
      },
      get pieInfo() {
        return get(expression);
      },
      get last() {
        return last();
      },
      set last($$value) {
        last($$value);
      },
      get steps() {
        return steps();
      },
      set steps($$value) {
        steps($$value);
      },
      $$legacy: true
    });
    pop();
  }

  // src/ts/GraphContainer.svelte
  var root8 = template(`<dir class="container graph svelte-1i8v5na"><!></dir>`);
  function GraphContainer($$anchor, $$props) {
    "use strict";
    var dir = root8();
    var node = child(dir);
    slot(node, $$props, "default", {}, null);
    reset(dir);
    append($$anchor, dir);
  }

  // src/ts/OldRetentionPie.svelte
  var import_cancelable_promise = __toESM(require_CancelablePromise());
  var root_14 = template(`<!> <br> <p> </p> <small class="svelte-4398ac"><span> </span> <span><code> </code></span> <span> </span> <span><code> </code></span> <label class="svelte-4398ac"><span><input type="checkbox"> </span> <span><code> </code></span></label></small>`, 1);
  function OldRetentionPie($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $searchString = () => store_get(searchString, "$searchString", $$stores);
    const passed_search = mutable_state();
    const flunked_search = mutable_state();
    const learning_search = mutable_state();
    let do_learning = mutable_state(true);
    let data_fetcher = mutable_state(import_cancelable_promise.default.reject());
    async function dataGen(include_learning, search2) {
      const passed = await search(get(passed_search));
      const flunked = await search(get(flunked_search));
      const learning = await search(get(learning_search));
      const learning_data = include_learning ? [
        {
          label: i18n("learning"),
          value: learning.length,
          colour: LEARN_COLOUR
        }
      ] : [];
      return [
        {
          label: i18n("passed"),
          value: passed.length,
          colour: "#74c476"
        },
        {
          label: i18n("flunked"),
          value: flunked.length,
          colour: RELEARN_COLOUR
        },
        ...learning_data
      ];
    }
    legacy_pre_effect(() => (searchJoin, $searchString()), () => {
      set(passed_search, searchJoin($searchString(), "rated:1 -rated:1:1 is:review"));
    });
    legacy_pre_effect(() => (searchJoin, $searchString()), () => {
      set(flunked_search, searchJoin($searchString(), "rated:1 rated:1:1 is:review"));
    });
    legacy_pre_effect(() => (searchJoin, $searchString()), () => {
      set(learning_search, searchJoin($searchString(), "rated:1 -is:review is:learn"));
    });
    legacy_pre_effect(
      () => ($searchString(), get(data_fetcher), import_cancelable_promise.cancelable, get(do_learning)),
      () => {
        if ($searchString() !== null) {
          get(data_fetcher).cancel();
          set(data_fetcher, (0, import_cancelable_promise.cancelable)(dataGen(get(do_learning), $searchString())));
        }
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = comment();
    var node = first_child(fragment);
    await_block(
      node,
      () => get(data_fetcher),
      ($$anchor2) => {
        NoGraph($$anchor2, {
          children: ($$anchor3, $$slotProps) => {
            next();
            var text_7 = text();
            template_effect(($0) => set_text(text_7, $0), [() => i18n("loading")], derived_safe_equal);
            append($$anchor3, text_7);
          },
          $$slots: { default: true }
        });
      },
      ($$anchor2, data2) => {
        var fragment_1 = root_14();
        var node_1 = first_child(fragment_1);
        const expression = derived_safe_equal(() => i18n("amount"));
        Pie(node_1, {
          legend_left: "State",
          get legend_right() {
            return get(expression);
          },
          get data() {
            return get(data2);
          }
        });
        var p = sibling(node_1, 4);
        var text2 = child(p);
        reset(p);
        var small = sibling(p, 2);
        var span = child(small);
        var text_1 = child(span);
        reset(span);
        var span_1 = sibling(span, 2);
        var code = child(span_1);
        var text_2 = child(code, true);
        reset(code);
        reset(span_1);
        var span_2 = sibling(span_1, 2);
        var text_3 = child(span_2);
        reset(span_2);
        var span_3 = sibling(span_2, 2);
        var code_1 = child(span_3);
        var text_4 = child(code_1, true);
        reset(code_1);
        reset(span_3);
        var label = sibling(span_3, 2);
        var span_4 = child(label);
        var input = child(span_4);
        remove_input_defaults(input);
        var text_5 = sibling(input);
        reset(span_4);
        var span_5 = sibling(span_4, 2);
        var code_2 = child(span_5);
        var text_6 = child(code_2, true);
        reset(code_2);
        reset(span_5);
        reset(label);
        reset(small);
        template_effect(
          ($0, $1, $2, $3, $4) => {
            set_text(text2, `${$0 ?? ""} = ${get(data2)[0].value ?? ""} /
        ${get(data2)[0].value + get(data2)[1].value} =
        ${$1 ?? ""}%`);
            set_text(text_1, `${$2 ?? ""} =`);
            set_text(text_2, get(passed_search));
            set_text(text_3, `${$3 ?? ""} =`);
            set_text(text_4, get(flunked_search));
            set_text(text_5, ` ${$4 ?? ""}`);
            set_text(text_6, get(learning_search));
          },
          [
            () => i18n("todays-retention"),
            () => (100 * get(data2)[0].value / (get(data2)[0].value + get(data2)[1].value)).toFixed(2),
            () => i18n("passed"),
            () => i18n("flunked"),
            () => i18n("learning")
          ],
          derived_safe_equal
        );
        bind_checked(input, () => get(do_learning), ($$value) => set(do_learning, $$value));
        append($$anchor2, fragment_1);
      }
    );
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/CustomPie.svelte
  var import_lodash10 = __toESM(require_lodash());

  // src/ts/CustomPie.ts
  async function getQuery(query, mode2) {
    let cids2;
    if (!query) {
      query = "*";
    }
    try {
      cids2 = await search(query);
    } catch {
      return -1;
    }
    if (mode2 === "Count") {
      return cids2.length;
    }
    const cards = await getCardData(cids2);
    switch (mode2) {
      case "Load":
        return cards.reduce((p, n) => p += n.ivl ? 1 / n.ivl : 0, 0);
      case "Lapses":
        return cards.reduce((p, n) => p += n.lapses, 0);
      case "Repetitions":
        return cards.reduce((p, n) => p += n.reps, 0);
      default:
        mode2 = "Invalid Mode";
        return 0;
    }
  }

  // src/ts/CustomPieSearch.svelte
  var import_cancelable_promise2 = __toESM(require_CancelablePromise());
  var root9 = template(`<input type="text"> <input type="text">`, 1);
  function CustomPieSearch($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $data = () => store_get(data2(), "$data", $$stores);
    const $searchString = () => store_get(searchString, "$searchString", $$stores);
    const $custom_pie_mode = () => store_get(custom_pie_mode, "$custom_pie_mode", $$stores);
    let data2 = prop($$props, "data", 8);
    let promise = prop($$props, "promise", 28, () => import_cancelable_promise2.default.resolve(0));
    let last_search = mutable_state();
    let last_mode = mutable_state();
    legacy_pre_effect(() => ($data(), searchJoin, $searchString()), () => {
      store_mutate(data2(), untrack($data).label = searchJoin($searchString(), $data().search), untrack($data));
    });
    legacy_pre_effect(
      () => (get(last_search), $data(), get(last_mode), $custom_pie_mode(), deep_read_state(promise()), import_cancelable_promise2.cancelable, getQuery),
      () => {
        if (get(last_search) !== $data().label || get(last_mode) !== $custom_pie_mode()) {
          promise().cancel();
          promise((0, import_cancelable_promise2.cancelable)(getQuery($data().label, $custom_pie_mode())));
          promise().then((result) => {
            store_mutate(data2(), untrack($data).value = result, untrack($data));
          });
          set(last_search, $data().label);
          set(last_mode, $custom_pie_mode());
        }
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = root9();
    var input = first_child(fragment);
    remove_input_defaults(input);
    var input_1 = sibling(input, 2);
    remove_input_defaults(input_1);
    template_effect(
      ($0, $1) => {
        set_attribute(input, "placeholder", $0);
        set_attribute(input_1, "placeholder", $1);
      },
      [
        () => i18n("search-string"),
        () => i18n("css-colour")
      ],
      derived_safe_equal
    );
    bind_value(input, () => $data().search, ($$value) => store_mutate(data2(), untrack($data).search = $$value, untrack($data)));
    bind_value(input_1, () => $data().colour, ($$value) => store_mutate(data2(), untrack($data).colour = $$value, untrack($data)));
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/CustomPie.svelte
  var root10 = template(`<div class="options svelte-13i1ha2"><label><input type="radio"> </label> <label><input type="radio"> </label> <label><input type="radio"> </label> <label><input type="radio"> </label></div> <!> <div class="searches svelte-13i1ha2"><span> </span> <span> </span> <!> <input type="button"> <input type="button"></div>`, 1);
  function CustomPie($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $searchString = () => store_get(searchString, "$searchString", $$stores);
    const $custom_pie_mode = () => store_get(custom_pie_mode, "$custom_pie_mode", $$stores);
    const $pie_data_values = () => store_get(get(pie_data_values), "$pie_data_values", $$stores);
    const pie_data_values = mutable_state();
    const binding_group = [];
    const pickable_colours = ["blue", "red", "green", "orange"];
    let pickable_colours_i = 0;
    let pie_data = mutable_state([]);
    onMount(reset2);
    function newSearch() {
      set(pie_data, [
        ...get(pie_data),
        writable({
          label: $searchString() !== null && $searchString() !== void 0 ? $searchString() : "",
          search: "",
          colour: pickable_colours[pickable_colours_i++],
          value: 0
        })
      ]);
      pickable_colours_i %= pickable_colours.length;
    }
    function reset2() {
      set(pie_data, []);
      newSearch();
    }
    legacy_pre_effect(() => (derived2, get(pie_data)), () => {
      store_unsub(set(pie_data_values, derived2(get(pie_data), (a4) => a4)), "$pie_data_values", $$stores);
    });
    legacy_pre_effect_reset();
    init();
    var fragment = root10();
    var div = first_child(fragment);
    var label = child(div);
    var input = child(label);
    remove_input_defaults(input);
    input.value = null == (input.__value = "Count") ? "" : "Count";
    var text2 = sibling(input);
    reset(label);
    var label_1 = sibling(label, 2);
    var input_1 = child(label_1);
    remove_input_defaults(input_1);
    input_1.value = null == (input_1.__value = "Load") ? "" : "Load";
    var text_1 = sibling(input_1);
    reset(label_1);
    var label_2 = sibling(label_1, 2);
    var input_2 = child(label_2);
    remove_input_defaults(input_2);
    input_2.value = null == (input_2.__value = "Lapses") ? "" : "Lapses";
    var text_2 = sibling(input_2);
    reset(label_2);
    var label_3 = sibling(label_2, 2);
    var input_3 = child(label_3);
    remove_input_defaults(input_3);
    input_3.value = null == (input_3.__value = "Repetitions") ? "" : "Repetitions";
    var text_3 = sibling(input_3);
    reset(label_3);
    reset(div);
    var node = sibling(div, 2);
    {
      var consequent = ($$anchor2) => {
        const expression = derived_safe_equal(() => i18n("search"));
        const expression_1 = derived_safe_equal(() => i18n($custom_pie_mode().toLowerCase()));
        Pie($$anchor2, {
          get data() {
            return $pie_data_values();
          },
          get legend_left() {
            return get(expression);
          },
          get legend_right() {
            return get(expression_1);
          }
        });
      };
      var alternate = ($$anchor2) => {
        NoGraph($$anchor2, {});
      };
      if_block(node, ($$render) => {
        if (import_lodash10.default.sumBy($pie_data_values(), (d) => d.value)) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    var div_1 = sibling(node, 2);
    var span = child(div_1);
    var text_4 = child(span, true);
    reset(span);
    var span_1 = sibling(span, 2);
    var text_5 = child(span_1, true);
    reset(span_1);
    var node_1 = sibling(span_1, 2);
    each(node_1, 1, () => get(pie_data), index, ($$anchor2, data2) => {
      CustomPieSearch($$anchor2, {
        get data() {
          return get(data2);
        }
      });
    });
    var input_4 = sibling(node_1, 2);
    remove_input_defaults(input_4);
    var input_5 = sibling(input_4, 2);
    remove_input_defaults(input_5);
    reset(div_1);
    template_effect(
      ($0, $1, $2, $3, $4, $5, $6, $7) => {
        set_text(text2, ` ${$0 ?? ""}`);
        set_text(text_1, ` ${$1 ?? ""}`);
        set_text(text_2, ` ${$2 ?? ""}`);
        set_text(text_3, ` ${$3 ?? ""}`);
        set_text(text_4, $4);
        set_text(text_5, $5);
        set_value(input_4, $6);
        set_value(input_5, $7);
      },
      [
        () => i18n("count"),
        () => i18n("load"),
        () => i18n("lapses"),
        () => i18n("repetitions"),
        () => i18n("search"),
        () => i18n("colour"),
        () => i18n("new-search"),
        () => i18n("reset")
      ],
      derived_safe_equal
    );
    bind_group(binding_group, [], input, $custom_pie_mode, ($$value) => store_set(custom_pie_mode, $$value));
    bind_group(binding_group, [], input_1, $custom_pie_mode, ($$value) => store_set(custom_pie_mode, $$value));
    bind_group(binding_group, [], input_2, $custom_pie_mode, ($$value) => store_set(custom_pie_mode, $$value));
    bind_group(binding_group, [], input_3, $custom_pie_mode, ($$value) => store_set(custom_pie_mode, $$value));
    event("click", input_4, newSearch);
    event("click", input_5, reset2);
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/IntraDayDueBar.svelte
  var import_lodash11 = __toESM(require_lodash());
  var root_34 = template(`<h4> </h4>`);
  var root_24 = template(`<!> <!>`, 1);
  function IntraDayDueBar($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $other = () => store_get(other, "$other", $$stores);
    const $searchString = () => store_get(searchString, "$searchString", $$stores);
    const fetch2 = mutable_state();
    let next_card_time = mutable_state(null);
    let next_card_time_until = mutable_state("");
    async function fetchCards(parentSearch) {
      const due_today_learn = await search(searchJoin(parentSearch, "prop:due=0 is:learn -is:review"));
      const cards_learn = await getCardData(due_today_learn);
      const due_today_relearn = await search(searchJoin(parentSearch, "prop:due=0 is:learn is:review"));
      const cards_relearn = await getCardData(due_today_relearn);
      const { learn_ahead_secs, rollover: rollover2 } = $other();
      const data2 = [
        ...import_lodash11.default.range(rollover2, 24),
        ...import_lodash11.default.range(0, rollover2)
      ].map((hour) => ({
        label: hour.toString(),
        values: [0, 0]
      }));
      function graph(card_data2, offset) {
        for (const card of card_data2) {
          if (card.type == 1 || card.type == 3) {
            const time2 = new Date(card.due * 1e3);
            data2[(24 + time2.getHours() - rollover2) % 24].values[offset] += 1;
          }
        }
      }
      graph(cards_relearn, 0);
      graph(cards_learn, 1);
      const remaining = [...cards_learn, ...cards_relearn].map((card) => card.due - learn_ahead_secs).filter((due) => 1e3 * due > Date.now());
      const next_card = import_lodash11.default.min(remaining);
      if (next_card) {
        set(next_card_time, new Date(next_card * 1e3));
        const time_until = (get(next_card_time).getTime() - Date.now()) / (60 * 1e3);
        const hours = Math.floor(time_until / 60);
        const minutes = Math.ceil(time_until % 60);
        set(next_card_time_until, i18n("next-card-at", {
          hours,
          minutes,
          time: get(next_card_time).toLocaleTimeString()
        }));
      } else {
        set(next_card_time, null);
      }
      return data2;
    }
    function extraRender({ x: x5, y: y5, svg: svg2, maxValue }) {
      const now2 = new Date(Date.now());
      const lineX = x5(now2.getHours().toFixed(0)) + // Go to the label
      (x5.bandwidth() + x5.padding()) * now2.getMinutes() / 60 + // Intra hour
      x5.bandwidth() / 2;
      const bottom2 = y5(0);
      const top2 = y5(maxValue);
      const night_mode = document.body.closest(".night-mode") != null;
      const colour = night_mode ? "white" : "black";
      const line = svg2.append("g").attr("stroke", colour).attr("fill", colour);
      line.append("line").attr("x1", lineX).attr("x2", lineX).attr("y1", bottom2).attr("y2", top2).attr("stroke-width", 2).attr("stroke-opacity", "50%");
      line.append("circle").attr("r", 5).attr("cx", lineX).attr("cy", top2);
      line.append("text").text("Now").attr("stroke-width", 0.5).attr("x", lineX + 5).attr("y", top2);
    }
    legacy_pre_effect(() => $searchString(), () => {
      set(fetch2, $searchString() !== null ? fetchCards($searchString()) : Promise.resolve([]));
    });
    legacy_pre_effect_reset();
    init();
    var fragment = comment();
    var node = first_child(fragment);
    await_block(
      node,
      () => get(fetch2),
      ($$anchor2) => {
        NoGraph($$anchor2, {
          children: ($$anchor3, $$slotProps) => {
            next();
            var text_2 = text();
            template_effect(($0) => set_text(text_2, $0), [() => i18n("loading")], derived_safe_equal);
            append($$anchor3, text_2);
          },
          $$slots: { default: true }
        });
      },
      ($$anchor2, data2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent_1 = ($$anchor3) => {
            var fragment_2 = root_24();
            var node_2 = first_child(fragment_2);
            {
              var consequent = ($$anchor4) => {
                var h4 = root_34();
                var text2 = child(h4, true);
                reset(h4);
                template_effect(() => set_text(text2, get(next_card_time_until)));
                append($$anchor4, h4);
              };
              if_block(node_2, ($$render) => {
                if (get(next_card_time)) $$render(consequent);
              });
            }
            var node_3 = sibling(node_2, 2);
            const expression = derived_safe_equal(() => ({
              row_labels: [
                i18n("relearning-count"),
                i18n("learning-count")
              ],
              row_colours: [RELEARN_COLOUR, LEARN_COLOUR],
              data: get(data2),
              columnLabeler: barHourLabeler
            }));
            Bar(node_3, {
              get data() {
                return get(expression);
              },
              extraRender
            });
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            NoGraph($$anchor3, {
              children: ($$anchor4, $$slotProps) => {
                next();
                var text_1 = text("NO REVIEWS");
                append($$anchor4, text_1);
              },
              $$slots: { default: true }
            });
          };
          if_block(node_1, ($$render) => {
            if (get(data2).reduce((p, n) => p + import_lodash11.default.sum(n.values), 0) > 0) $$render(consequent_1);
            else $$render(alternate, false);
          });
        }
        append($$anchor2, fragment_1);
      }
    );
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/CardDataPies.svelte
  var import_lodash13 = __toESM(require_lodash());

  // src/ts/GraphCategory.svelte
  var root_35 = template(`<h3 class="svelte-uz0znv"> </h3>`);
  var root_25 = template(`<button class="btn svelte-uz0znv">&gt;</button> <!>`, 1);
  var root_15 = template(`<label class="svelte-uz0znv"><div><!> <hr class="svelte-uz0znv"></div></label> <div class="category svelte-uz0znv"><!></div>`, 1);
  function GraphCategory($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $shownCategories = () => store_get(shownCategories, "$shownCategories", $$stores);
    var _a;
    let hidden_title = prop($$props, "hidden_title", 8, "");
    let config_name = prop($$props, "config_name", 8, "");
    let hidden = mutable_state(!((_a = SSEconfig === null || SSEconfig === void 0 ? void 0 : SSEconfig.categories) === null || _a === void 0 ? void 0 : _a[config_name()]));
    init();
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent_3 = ($$anchor2) => {
        var fragment_1 = root_15();
        var label = first_child(fragment_1);
        var div = child(label);
        var node_1 = child(div);
        {
          var consequent_1 = ($$anchor3) => {
            var fragment_2 = root_25();
            var button = first_child(fragment_2);
            var node_2 = sibling(button, 2);
            {
              var consequent = ($$anchor4) => {
                var h3 = root_35();
                var text2 = child(h3);
                reset(h3);
                template_effect(() => set_text(text2, `${hidden_title() ?? ""}...`));
                append($$anchor4, h3);
              };
              if_block(node_2, ($$render) => {
                if (get(hidden)) $$render(consequent);
              });
            }
            event("click", button, () => {
              set(hidden, !get(hidden));
              store_mutate(shownCategories, untrack($shownCategories)[config_name()] = !get(hidden), untrack($shownCategories));
            });
            append($$anchor3, fragment_2);
          };
          if_block(node_1, ($$render) => {
            if (hidden_title()) $$render(consequent_1);
          });
        }
        next(2);
        reset(div);
        reset(label);
        var div_1 = sibling(label, 2);
        var node_3 = child(div_1);
        {
          var consequent_2 = ($$anchor3) => {
            var fragment_3 = comment();
            var node_4 = first_child(fragment_3);
            slot(node_4, $$props, "default", {}, null);
            append($$anchor3, fragment_3);
          };
          if_block(node_3, ($$render) => {
            if (!get(hidden) || !hidden_title()) $$render(consequent_2);
          });
        }
        reset(div_1);
        template_effect(() => set_class(div, 1, `separator ${get(hidden) ? "hidden" : ""}`, "svelte-uz0znv"));
        append($$anchor2, fragment_1);
      };
      if_block(node, ($$render) => {
        if (SSEconfig?.categories?.[config_name()] !== "removed") $$render(consequent_3);
      });
    }
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/revlogGraphs.ts
  var import_lodash12 = __toESM(require_lodash());
  var rollover = SSEother.rollover ?? 0;
  var rollover_ms = rollover * 60 * 60 * 1e3;
  var day_ms2 = 1e3 * 60 * 60 * 24;
  var timezone_offset_mins = (/* @__PURE__ */ new Date()).getTimezoneOffset();
  var timezone_offset_ms = timezone_offset_mins * 60 * 1e3;
  function dayFromMs(ms) {
    return Math.floor((ms - rollover_ms) / day_ms2);
  }
  var today = dayFromMs(Date.now());
  var no_rollover_today = Math.floor(Date.now() / day_ms2);
  function emptyBuckets(init3) {
    return {
      learn: init3(),
      not_learn: init3(),
      young: init3(),
      mature: init3(),
      all: init3()
    };
  }
  function IDify(array4) {
    let id_data = {};
    for (const e of array4) {
      id_data[e.id] = e;
    }
    return id_data;
  }
  function calculateRevlogStats(revlogData, cardData, end = today) {
    let id_card_data = IDify(cardData);
    function emptyArray(init3) {
      const empty_array = [];
      empty_array[end] = init3;
      return empty_array;
    }
    function initialEase() {
      return [0, 0, 0, 0];
    }
    function emptyRevlogBuckets() {
      return emptyBuckets(() => emptyArray(initialEase()));
    }
    const empty_2d_array = [];
    empty_2d_array[end] = [];
    let revlog_times = emptyArray(0);
    let introduced_day_count = emptyArray(0);
    let reintroduced_day_count = emptyArray(0);
    let day_forgotten = emptyArray(0);
    let intervals = [];
    let day_initial_ease = emptyArray(initialEase());
    let day_initial_reintroduced_ease = emptyArray(initialEase());
    let interval_ease = emptyArray(initialEase());
    let day_review_hours = emptyArray(Array(24).fill(0));
    let day_filtered_review_hours = emptyArray(Array(24).fill(0));
    let day_ease = emptyRevlogBuckets();
    let fatigue_ease = emptyRevlogBuckets();
    let time_ease_seconds = emptyRevlogBuckets();
    let forgotten = /* @__PURE__ */ new Set();
    let card_times = {};
    let introduced = /* @__PURE__ */ new Set();
    let reintroduced = /* @__PURE__ */ new Set();
    let last_cids = {};
    let burden_revlogs = [];
    let last_siblings = [];
    let sibling_time_ease = emptyArray(initialEase());
    let day_review_count = [];
    let learn_steps_per_card = {};
    function incrementEase(ease_array, day, ease) {
      ease_array[day] = ease_array[day] ? ease_array[day] : initialEase();
      ease_array[day][ease] += 1;
    }
    for (const revlog of revlogData) {
      const day = dayFromMs(revlog.id);
      const no_rollover_day = Math.floor(revlog.id / day_ms2);
      const hour = Math.floor((revlog.id - timezone_offset_ms) % day_ms2 / (60 * 60 * 1e3));
      const ease = revlog.ease - 1;
      const second2 = Math.round(revlog.time / 1e3);
      const card = id_card_data[revlog.cid];
      card_times[revlog.cid] = (card_times[revlog.cid] ?? 0) + revlog.time;
      if (revlog.time != 0) {
        if (revlog.type < 3) {
          day_review_hours[no_rollover_day] ??= Array(24).fill(0);
          day_review_hours[no_rollover_day][hour] = day_review_hours[no_rollover_day][hour] + 1;
          if (revlog.type == 0) {
            learn_steps_per_card[revlog.cid] = (learn_steps_per_card[revlog.cid] ?? 0) + 1;
          }
        }
        day_filtered_review_hours[no_rollover_day] ??= Array(24).fill(0);
        day_filtered_review_hours[no_rollover_day][hour] = day_filtered_review_hours[no_rollover_day][hour] + 1;
        day_review_count[day] = (day_review_count[day] ?? -1) + 1;
        incrementEase(fatigue_ease.all, day_review_count[day], ease);
        incrementEase(day_ease.all, day, ease);
        incrementEase(time_ease_seconds.all, second2, ease);
      }
      incrementEase(interval_ease, revlog.lastIvl < 0 ? 0 : revlog.lastIvl, ease);
      if (revlog.lastIvl > 0) {
        incrementEase(day_ease.not_learn, day, ease);
        incrementEase(fatigue_ease.not_learn, day_review_count[day], ease);
        incrementEase(time_ease_seconds.not_learn, second2, ease);
        if (revlog.lastIvl >= 21) {
          incrementEase(day_ease.mature, day, ease);
          incrementEase(fatigue_ease.mature, day_review_count[day], ease);
          incrementEase(time_ease_seconds.mature, second2, ease);
          if (card) {
            const last_sibling = last_siblings[card.nid];
            if (last_sibling !== void 0 && last_sibling.cid != revlog.cid) {
              incrementEase(sibling_time_ease, day - last_sibling.day, ease);
            }
            last_siblings[card.nid] = {
              cid: revlog.cid,
              day
            };
          }
        } else {
          incrementEase(day_ease.young, day, ease);
          incrementEase(fatigue_ease.young, day_review_count[day], ease);
          incrementEase(time_ease_seconds.young, second2, ease);
          if (card) {
            last_siblings[card.nid] = void 0;
          }
        }
      } else {
        incrementEase(day_ease.learn, day, ease);
        incrementEase(fatigue_ease.learn, day_review_count[day], ease);
        incrementEase(time_ease_seconds.learn, second2, ease);
      }
      if (revlog.ease == 0 && revlog.ivl == 0) {
        introduced.delete(revlog.cid);
        forgotten.add(revlog.cid);
        if (revlog.lastIvl != 0) {
          day_forgotten[day] = (day_forgotten[day] ?? 0) + 1;
          delete learn_steps_per_card[revlog.cid];
        }
      } else if (!introduced.has(revlog.cid) && revlog.ivl != 0) {
        introduced_day_count[day] = (introduced_day_count[day] ?? 0) + 1;
        incrementEase(day_initial_reintroduced_ease, day, ease);
        if (reintroduced.has(revlog.cid)) {
          reintroduced_day_count[day] = (reintroduced_day_count[day] ?? 0) + 1;
        } else {
          incrementEase(day_initial_ease, day, ease);
        }
        introduced.add(revlog.cid);
        reintroduced.add(revlog.cid);
        forgotten.delete(revlog.cid);
      }
    }
    revlogData.reduceRight((_p, revlog) => {
      const day = dayFromMs(revlog.id);
      const card = id_card_data[revlog.cid];
      const next_review = last_cids[revlog.cid];
      let ivl = next_review ? revlog.ivl : card.type != 3 && card.type != 1 ? card.ivl : 0;
      if (revlog.ivl == 0 || !next_review && card.queue == 0) {
        last_cids[revlog.cid] = revlog;
        return void 0;
      }
      ivl = ivl > 0 ? ivl : 0;
      if (!next_review && card.queue == -1) {
        ivl = -1;
      }
      let to = next_review ? dayFromMs(next_review.id) : end + 1;
      for (const intervalDay of import_lodash12.default.range(day, to)) {
        intervals[intervalDay] = intervals[intervalDay] ?? [];
        intervals[intervalDay][ivl] = (intervals[intervalDay][ivl] ?? 0) + 1;
        if (ivl == 0 && (revlog.type == 0 || !next_review && card.type == 1)) {
          intervals[intervalDay][-2] = (intervals[intervalDay][-2] ?? 0) + 1;
        }
      }
      last_cids[revlog.cid] = revlog;
      return void 0;
    }, void 0);
    const burden = Array.from(intervals).map((v3) => {
      if (!v3) {
        return 0;
      } else {
        return import_lodash12.default.sum(v3.map((val, ivl) => val / (ivl || 1))) ?? 0;
      }
    });
    for (const card_time of Object.values(card_times)) {
      const key = Math.floor(card_time / 1e3);
      revlog_times[key] = (revlog_times[key] ?? 0) + 1;
    }
    const remaining_forgotten = forgotten.size;
    return {
      day_initial_ease,
      day_initial_reintroduced_ease,
      day_ease,
      fatigue_ease,
      time_ease_seconds,
      sibling_time_ease,
      interval_ease,
      revlog_times,
      introduced_day_count,
      reintroduced_day_count,
      burden,
      day_forgotten,
      remaining_forgotten,
      intervals,
      day_review_hours,
      day_filtered_review_hours,
      learn_steps_per_card: Object.values(learn_steps_per_card)
    };
  }
  var EASE_COLOURS = ["#a50026", "#fdbe70", "#b6e076", "#006837"].reverse();
  var EASE_LABELS = [i18n("again"), i18n("hard"), i18n("good"), i18n("easy")].reverse();
  function retentionStats(data2) {
    return [import_lodash12.default.sum(data2.values) ? formatRetention(1 - data2.values[3]) : "No data"];
  }
  function formatRetention(value) {
    return i18n("percent-correct", { percentage: (100 * value).toFixed(2) });
  }
  function easeBarChart(eases, offset = today, normalize3 = false, columnLabeler = void 0) {
    return {
      row_colours: EASE_COLOURS,
      row_labels: EASE_LABELS,
      data: Array.from(eases).map((data2, label) => {
        const sum4 = import_lodash12.default.sum(data2);
        let values2 = [...data2 ?? [0, 0, 0, 0]].reverse();
        values2 = normalize3 ? values2.map((a4) => a4 / sum4) : values2;
        return {
          values: values2,
          label: (label - offset).toString()
        };
      }),
      tick_spacing: 5,
      reverse_legend: true,
      columnLabeler,
      extraStats: normalize3 ? retentionStats : totalCalc
    };
  }

  // src/ts/CardDataPies.ts
  function calculateCardDataPies(cardData, include_suspended2, zero_inclusive2) {
    let lapses = [];
    let repetitions = [];
    let lapses_burden = [];
    let repetitions_burden = [];
    let target_R_days2 = [];
    const days_elapsed = SSEother.days_elapsed;
    for (const card of cardData ?? []) {
      if (include_suspended2 || card.queue !== -1) {
        if (card.reps > 0) {
          lapses[card.lapses] = (lapses[card.lapses] ?? 0) + 1;
          repetitions[card.reps] = (repetitions[card.reps] ?? 0) + 1;
          const burden = card.ivl > 0 ? 1 / card.ivl : 1;
          lapses_burden[card.lapses] = (lapses_burden[card.lapses] ?? 0) + burden;
          repetitions_burden[card.reps] = (repetitions_burden[card.reps] ?? 0) + burden;
          const stability = JSON.parse(card.data).s;
          if (stability && card.ivl > 0 && card.type == 2 && card.queue > 0) {
            let due = card.due < 365e3 ? card.due - days_elapsed : card.due / day_ms2;
            const target_R = R(getCardDecay(card), card.ivl, stability);
            target_R_days2[due] = (target_R_days2[due] ?? 0) + target_R;
          }
        }
      }
    }
    if (!zero_inclusive2) {
      delete lapses[0];
      delete lapses_burden[0];
    }
    return { lapses, repetitions, lapses_burden, repetitions_burden, target_R_days: target_R_days2 };
  }

  // src/ts/CardDataPies.svelte
  var root_26 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_36 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_4 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_16 = template(`<!> <!> <!>`, 1);
  var root_6 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_7 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_8 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_5 = template(`<!> <!> <!>`, 1);
  var root11 = template(`<!> <!>`, 1);
  function CardDataPies($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $zero_inclusive = () => store_get(zero_inclusive, "$zero_inclusive", $$stores);
    const $graph_mode = () => store_get(graph_mode, "$graph_mode", $$stores);
    const $include_suspended = () => store_get(include_suspended, "$include_suspended", $$stores);
    const $target_R_days_values = () => store_get(target_R_days, "$target_R_days_values", $$stores);
    const $data = () => store_get(data, "$data", $$stores);
    const true_zero_inclusive = mutable_state();
    const lapses = mutable_state();
    const repetitions = mutable_state();
    const lapses_burden = mutable_state();
    const repetitions_burden = mutable_state();
    const target_R_days2 = mutable_state();
    let cardData = prop($$props, "cardData", 8);
    let lapse_last = mutable_state(7);
    let lapse_steps = mutable_state(7);
    let repetitions_last = mutable_state(21);
    let repetitions_steps = mutable_state(7);
    legacy_pre_effect(() => ($zero_inclusive(), $graph_mode()), () => {
      set(true_zero_inclusive, $zero_inclusive() || $graph_mode() == "Bar");
    });
    legacy_pre_effect(
      () => (get(lapses), get(repetitions), get(lapses_burden), get(repetitions_burden), get(target_R_days2), catchErrors, calculateCardDataPies, deep_read_state(cardData()), $include_suspended(), get(true_zero_inclusive)),
      () => {
        (($$value) => (set(lapses, $$value.lapses), set(repetitions, $$value.repetitions), set(lapses_burden, $$value.lapses_burden), set(repetitions_burden, $$value.repetitions_burden), set(target_R_days2, $$value.target_R_days)))(catchErrors(() => calculateCardDataPies(cardData() !== null && cardData() !== void 0 ? cardData() : [], $include_suspended(), get(true_zero_inclusive))));
      }
    );
    legacy_pre_effect(() => ($data(), get(target_R_days2)), () => {
      store_set(target_R_days, $data() ? get(target_R_days2) : []);
    });
    legacy_pre_effect_reset();
    init();
    var fragment = root11();
    var node = first_child(fragment);
    const expression = derived_safe_equal(() => i18n("lapse-distribution"));
    GraphCategory(node, {
      get hidden_title() {
        return get(expression);
      },
      config_name: "lapse",
      children: ($$anchor2, $$slotProps) => {
        var fragment_1 = root_16();
        var node_1 = first_child(fragment_1);
        GraphContainer(node_1, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_2 = root_26();
            var h1 = first_child(fragment_2);
            var text2 = child(h1, true);
            reset(h1);
            var node_2 = sibling(h1, 2);
            const expression_1 = derived_safe_equal(() => ({
              totalDescriptor: i18n("load"),
              countDescriptor: i18n("highest-lapse-count"),
              legend_left: i18n("lapse-count"),
              legend_right: i18n("card-load"),
              spectrumFrom: "#bd3f09",
              spectrumTo: "#612207"
            }));
            IntervalGraph(node_2, {
              get intervals() {
                return get(lapses_burden);
              },
              get pieInfo() {
                return get(expression_1);
              },
              zero_inclusive_option: true,
              get steps() {
                return get(lapse_steps);
              },
              set steps($$value) {
                set(lapse_steps, $$value);
              },
              get last() {
                return get(lapse_last);
              },
              set last($$value) {
                set(lapse_last, $$value);
              },
              $$legacy: true
            });
            var p = sibling(node_2, 2);
            var text_1 = child(p, true);
            reset(p);
            template_effect(
              ($0, $1) => {
                set_text(text2, $0);
                set_text(text_1, $1);
              },
              [
                () => i18n("lapse-load"),
                () => i18n("lapse-load-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_2);
          },
          $$slots: { default: true }
        });
        var node_3 = sibling(node_1, 2);
        GraphContainer(node_3, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_3 = root_36();
            var h1_1 = first_child(fragment_3);
            var text_2 = child(h1_1, true);
            reset(h1_1);
            var node_4 = sibling(h1_1, 2);
            const expression_2 = derived_safe_equal(() => ({
              countDescriptor: i18n("highest-lapse-count"),
              legend_left: i18n("lapse-count"),
              legend_right: i18n("card-count"),
              spectrumFrom: "#bd3f09",
              spectrumTo: "#612207"
            }));
            IntervalGraph(node_4, {
              get intervals() {
                return get(lapses);
              },
              get pieInfo() {
                return get(expression_2);
              },
              zero_inclusive_option: true,
              get steps() {
                return get(lapse_steps);
              },
              set steps($$value) {
                set(lapse_steps, $$value);
              },
              get last() {
                return get(lapse_last);
              },
              set last($$value) {
                set(lapse_last, $$value);
              },
              $$legacy: true
            });
            var p_1 = sibling(node_4, 2);
            var text_3 = child(p_1, true);
            reset(p_1);
            template_effect(
              ($0, $1) => {
                set_text(text_2, $0);
                set_text(text_3, $1);
              },
              [
                () => i18n("lapse-distribution"),
                () => i18n("lapse-distribution-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_3);
          },
          $$slots: { default: true }
        });
        var node_5 = sibling(node_3, 2);
        GraphContainer(node_5, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_4 = root_4();
            var h1_2 = first_child(fragment_4);
            var text_4 = child(h1_2, true);
            reset(h1_2);
            var node_6 = sibling(h1_2, 2);
            const expression_3 = derived_safe_equal(() => get(lapses).map((e, i) => e * i));
            const expression_4 = derived_safe_equal(() => ({
              totalDescriptor: i18n("lapses"),
              countDescriptor: i18n("highest-lapse-count"),
              legend_left: i18n("lapse-count"),
              legend_right: i18n("lapse-total"),
              spectrumFrom: "#bd3f09",
              spectrumTo: "#612207"
            }));
            IntervalGraph(node_6, {
              get intervals() {
                return get(expression_3);
              },
              get pieInfo() {
                return get(expression_4);
              },
              zero_inclusive_option: true,
              get steps() {
                return get(lapse_steps);
              },
              set steps($$value) {
                set(lapse_steps, $$value);
              },
              get last() {
                return get(lapse_last);
              },
              set last($$value) {
                set(lapse_last, $$value);
              },
              $$legacy: true
            });
            var p_2 = sibling(node_6, 2);
            var text_5 = child(p_2, true);
            reset(p_2);
            template_effect(
              ($0, $1) => {
                set_text(text_4, $0);
                set_text(text_5, $1);
              },
              [
                () => i18n("lapse-total"),
                () => i18n("lapse-total-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_4);
          },
          $$slots: { default: true }
        });
        append($$anchor2, fragment_1);
      },
      $$slots: { default: true }
    });
    var node_7 = sibling(node, 2);
    const expression_5 = derived_safe_equal(() => i18n("repetition-distribution"));
    GraphCategory(node_7, {
      get hidden_title() {
        return get(expression_5);
      },
      config_name: "repetition",
      children: ($$anchor2, $$slotProps) => {
        var fragment_5 = root_5();
        var node_8 = first_child(fragment_5);
        GraphContainer(node_8, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_6 = root_6();
            var h1_3 = first_child(fragment_6);
            var text_6 = child(h1_3, true);
            reset(h1_3);
            var node_9 = sibling(h1_3, 2);
            const expression_6 = derived_safe_equal(() => ({
              totalDescriptor: i18n("load"),
              countDescriptor: i18n("highest-repetition-count"),
              legend_left: i18n("repetition-count"),
              legend_right: i18n("card-load"),
              spectrumFrom: "#5ca7f7",
              spectrumTo: "#0b4f99"
            }));
            IntervalGraph(node_9, {
              get intervals() {
                return get(repetitions_burden);
              },
              get pieInfo() {
                return get(expression_6);
              },
              get steps() {
                return get(repetitions_steps);
              },
              set steps($$value) {
                set(repetitions_steps, $$value);
              },
              get last() {
                return get(repetitions_last);
              },
              set last($$value) {
                set(repetitions_last, $$value);
              },
              $$legacy: true
            });
            var p_3 = sibling(node_9, 2);
            var text_7 = child(p_3, true);
            reset(p_3);
            template_effect(
              ($0, $1) => {
                set_text(text_6, $0);
                set_text(text_7, $1);
              },
              [
                () => i18n("repetition-load"),
                () => i18n("repetition-load-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_6);
          },
          $$slots: { default: true }
        });
        var node_10 = sibling(node_8, 2);
        GraphContainer(node_10, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_7 = root_7();
            var h1_4 = first_child(fragment_7);
            var text_8 = child(h1_4, true);
            reset(h1_4);
            var node_11 = sibling(h1_4, 2);
            const expression_7 = derived_safe_equal(() => ({
              countDescriptor: i18n("highest-repetition-count"),
              legend_left: i18n("repetition-count"),
              legend_right: i18n("card-count"),
              spectrumFrom: "#5ca7f7",
              spectrumTo: "#0b4f99"
            }));
            IntervalGraph(node_11, {
              get intervals() {
                return get(repetitions);
              },
              get pieInfo() {
                return get(expression_7);
              },
              get steps() {
                return get(repetitions_steps);
              },
              set steps($$value) {
                set(repetitions_steps, $$value);
              },
              get last() {
                return get(repetitions_last);
              },
              set last($$value) {
                set(repetitions_last, $$value);
              },
              $$legacy: true
            });
            var p_4 = sibling(node_11, 2);
            var text_9 = child(p_4, true);
            reset(p_4);
            template_effect(
              ($0, $1) => {
                set_text(text_8, $0);
                set_text(text_9, $1);
              },
              [
                () => i18n("repetition-distribution"),
                () => i18n("repetition-distribution-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_7);
          },
          $$slots: { default: true }
        });
        var node_12 = sibling(node_10, 2);
        GraphContainer(node_12, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_8 = root_8();
            var h1_5 = first_child(fragment_8);
            var text_10 = child(h1_5, true);
            reset(h1_5);
            var node_13 = sibling(h1_5, 2);
            const expression_8 = derived_safe_equal(() => get(repetitions).map((e, i) => e * i));
            const expression_9 = derived_safe_equal(() => ({
              totalDescriptor: i18n("total-repetitions"),
              countDescriptor: i18n("highest-repetition-count"),
              legend_left: i18n("repetition-count"),
              legend_right: i18n("repetition-total"),
              spectrumFrom: "#5ca7f7",
              spectrumTo: "#0b4f99"
            }));
            IntervalGraph(node_13, {
              get intervals() {
                return get(expression_8);
              },
              get pieInfo() {
                return get(expression_9);
              },
              get steps() {
                return get(repetitions_steps);
              },
              set steps($$value) {
                set(repetitions_steps, $$value);
              },
              get last() {
                return get(repetitions_last);
              },
              set last($$value) {
                set(repetitions_last, $$value);
              },
              $$legacy: true
            });
            var p_5 = sibling(node_13, 2);
            var text_11 = child(p_5, true);
            reset(p_5);
            template_effect(
              ($0, $1) => {
                set_text(text_10, $0);
                set_text(text_11, $1);
              },
              [
                () => i18n("repetition-total"),
                () => i18n("repetition-total-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_8);
          },
          $$slots: { default: true }
        });
        append($$anchor2, fragment_5);
      },
      $$slots: { default: true }
    });
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/Root.svelte
  var import_lodash18 = __toESM(require_lodash());

  // src/ts/RevlogGraphs.svelte
  var import_lodash17 = __toESM(require_lodash());

  // src/ts/Warning.svelte
  var root_17 = template(`<span class="svelte-19m2ve4"><!></span>`);
  function Warning($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $config = () => store_get(config, "$config", $$stores);
    let always = prop($$props, "always", 8, false);
    init();
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var span = root_17();
        var node_1 = child(span);
        slot(node_1, $$props, "default", {}, null);
        reset(span);
        append($$anchor2, span);
      };
      if_block(node, ($$render) => {
        if (always() || $config().warnings) $$render(consequent);
      });
    }
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/MatureFilterSelector.svelte
  var root12 = template(`<div><label><input type="radio"> </label> <label><input type="radio"> </label> <label><input type="radio"> </label> <label><input type="radio"> </label> <label><input type="radio"> </label></div>`);
  function MatureFilterSelector($$anchor, $$props) {
    push($$props, false);
    const binding_group = [];
    let group2 = prop($$props, "group", 12);
    init();
    var div = root12();
    var label = child(div);
    var input = child(label);
    remove_input_defaults(input);
    input.value = null == (input.__value = "learn") ? "" : "learn";
    var text2 = sibling(input);
    reset(label);
    var label_1 = sibling(label, 2);
    var input_1 = child(label_1);
    remove_input_defaults(input_1);
    input_1.value = null == (input_1.__value = "young") ? "" : "young";
    var text_1 = sibling(input_1);
    reset(label_1);
    var label_2 = sibling(label_1, 2);
    var input_2 = child(label_2);
    remove_input_defaults(input_2);
    input_2.value = null == (input_2.__value = "mature") ? "" : "mature";
    var text_2 = sibling(input_2);
    reset(label_2);
    var label_3 = sibling(label_2, 2);
    var input_3 = child(label_3);
    remove_input_defaults(input_3);
    input_3.value = null == (input_3.__value = "not_learn") ? "" : "not_learn";
    var text_3 = sibling(input_3);
    reset(label_3);
    var label_4 = sibling(label_3, 2);
    var input_4 = child(label_4);
    remove_input_defaults(input_4);
    input_4.value = null == (input_4.__value = "all") ? "" : "all";
    var text_4 = sibling(input_4);
    reset(label_4);
    reset(div);
    template_effect(
      ($0, $1, $2, $3, $4) => {
        set_text(text2, ` ${$0 ?? ""}`);
        set_text(text_1, ` ${$1 ?? ""}`);
        set_text(text_2, ` ${$2 ?? ""}`);
        set_text(text_3, ` ${$3 ?? ""}`);
        set_text(text_4, ` ${$4 ?? ""}`);
      },
      [
        () => i18n("learn"),
        () => i18n("young"),
        () => i18n("mature"),
        () => i18n("young-and-mature"),
        () => i18n("all")
      ],
      derived_safe_equal
    );
    bind_group(binding_group, [], input, group2, group2);
    bind_group(binding_group, [], input_1, group2, group2);
    bind_group(binding_group, [], input_2, group2, group2);
    bind_group(binding_group, [], input_3, group2, group2);
    bind_group(binding_group, [], input_4, group2, group2);
    append($$anchor, div);
    pop();
  }

  // src/ts/MemorisedBar.svelte
  var _21 = __toESM(require_lodash());

  // src/ts/Candlestick.ts
  var import_lodash14 = __toESM(require_lodash());
  var CANDLESTICK_GREEN = "green";
  var CANDLESTICK_RED = "red";
  function plotCandlestick(graph, svg2) {
    let { start: total, up_colour = CANDLESTICK_GREEN, down_colour = CANDLESTICK_RED } = graph;
    const deltas = graph.data.map((datum2) => {
      let begin = total;
      total += datum2.delta;
      const positive = datum2.delta > 0;
      return {
        positive,
        begin: positive ? begin : total,
        end: positive ? total : begin,
        label: datum2.label
      };
    });
    const max5 = import_lodash14.default.maxBy(deltas, (datum2) => datum2.end)?.end ?? 0;
    const min4 = import_lodash14.default.minBy(deltas, (datum2) => datum2.begin)?.begin ?? 0;
    const x5 = defaultX3(deltas.map((datum2) => datum2.label));
    const y5 = defaultY3(min4, max5);
    const axis2 = createAxis(svg2, graph.tick_spacing, x5, y5);
    axis2.append("g").selectAll("g").data(deltas).join("rect").attr("fill", (d) => d.positive ? up_colour : down_colour).attr("x", (d) => x5(d.label)).attr("y", (d) => y5(d.end)).attr("height", (d) => y5(d.begin) - y5(d.end)).attr("width", x5.bandwidth());
    hoverBars(axis2, x5, deltas).on("mouseover", (e, d) => {
      const delta = (d.end - d.begin) * (d.positive ? 1 : -1);
      const final = d.positive ? d.end : d.begin;
      const date2 = tooltipDate(+d.label, graph.bar_width ?? 1);
      tooltipShown.set(true);
      tooltip.set({
        text: [
          `${date2}:`,
          i18n("x-change", { val: delta.toFixed(2) }),
          i18n("x-total", { val: final.toFixed(2) })
        ],
        x: tooltipX(e),
        y: e.pageY
      });
    }).on("mouseout", (e, v3) => {
      tooltipShown.set(false);
    });
    return { x: x5, y: y5, svg: axis2, maxValue: max5, chart: graph };
  }
  function DeltaIfy(arr) {
    return arr.map((v3, i) => v3 - (arr[i - 1] || 0));
  }

  // src/ts/Candlestick.svelte
  var import_lodash15 = __toESM(require_lodash());
  var root13 = template(`<div class="options svelte-1d6gow"><label class="svelte-1d6gow"> <input type="number" class="svelte-1d6gow"></label> <label class="svelte-1d6gow"> <input type="number" class="svelte-1d6gow"></label></div> <svg></svg>`, 1);
  function Candlestick($$anchor, $$props) {
    push($$props, false);
    const realOffset = mutable_state();
    const leftmost = mutable_state();
    const seperate_bars = mutable_state();
    let svg2 = mutable_state(null);
    let binSize2 = prop($$props, "binSize", 12, 1);
    let offset = prop($$props, "offset", 12, 0);
    let bins = prop($$props, "bins", 8, 30);
    let data2 = prop($$props, "data", 8);
    let limit = prop($$props, "limit", 8, 0);
    let trend = prop($$props, "trend", 8, true);
    let trend_data = prop($$props, "trend_data", 12, void 0);
    let bars = mutable_state();
    legacy_pre_effect(() => deep_read_state(offset()), () => {
      set(realOffset, -Math.abs(offset()));
    });
    legacy_pre_effect(() => deep_read_state(binSize2()), () => {
      binSize2(binSize2() > 0 ? binSize2() : 1);
    });
    legacy_pre_effect(
      () => (deep_read_state(bins()), deep_read_state(binSize2()), get(realOffset)),
      () => {
        set(leftmost, -(bins() * binSize2()) + get(realOffset));
      }
    );
    legacy_pre_effect(
      () => (deep_read_state(data2()), get(leftmost), get(realOffset)),
      () => {
        set(seperate_bars, data2().data.slice(get(leftmost), get(realOffset) == 0 ? void 0 : get(realOffset)));
      }
    );
    legacy_pre_effect(
      () => (get(bars), import_lodash15.default, get(leftmost), get(realOffset), deep_read_state(binSize2()), get(seperate_bars)),
      () => {
        set(bars, import_lodash15.default.range(get(leftmost), get(realOffset), binSize2()).map((i) => ({
          label: (i + 1).toString(),
          // I have no idea if +1 is right but at least its consistent with the other graphs
          delta: 0
        })));
        for (const [i, bar] of get(seperate_bars).entries()) {
          const newIndex = Math.floor(i / binSize2());
          mutate(bars, get(bars)[newIndex].delta += bar.delta || 0);
        }
      }
    );
    legacy_pre_effect(
      () => (get(svg2), deep_read_state(data2()), plotCandlestick, get(bars), deep_read_state(binSize2()), limitArea, limit_area_width, deep_read_state(limit()), deep_read_state(offset()), deep_read_state(trend()), trendLine),
      () => {
        if (get(svg2) && data2().data.length) {
          const chart = plotCandlestick(
            Object.assign(Object.assign({}, data2()), {
              data: get(bars),
              bar_width: binSize2()
            }),
            get(svg2)
          );
          limitArea(chart, limit_area_width(chart.x, limit(), offset(), binSize2(), 1));
          if (trend()) {
            let total = chart.chart.start;
            const trend_points = chart.chart.data.map((datum2) => {
              total += datum2.delta;
              return { x: +datum2.label, y: total };
            });
            trend_data(trendLine(chart, trend_points));
          }
        }
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = root13();
    var div = first_child(fragment);
    var label = child(div);
    var text2 = child(label);
    var input = sibling(text2);
    remove_input_defaults(input);
    reset(label);
    var label_1 = sibling(label, 2);
    var text_1 = child(label_1);
    var input_1 = sibling(text_1);
    remove_input_defaults(input_1);
    reset(label_1);
    reset(div);
    var svg_1 = sibling(div, 2);
    bind_this(svg_1, ($$value) => set(svg2, $$value), () => get(svg2));
    template_effect(
      ($0, $1) => {
        set_text(text2, `${$0 ?? ""} `);
        set_text(text_1, `${$1 ?? ""} `);
        set_attribute(input_1, "step", binSize2());
      },
      [
        () => i18n("bar-width"),
        () => i18n("scroll")
      ],
      derived_safe_equal
    );
    bind_value(input, binSize2);
    bind_value(input_1, offset);
    append($$anchor, fragment);
    pop();
  }

  // src/ts/LineGraph.ts
  function renderLineChart(svg2, values2, label = "Value") {
    const { width: width2, height: height2 } = defaultGraphBounds();
    const date_values = values2.map((v3, i) => ({ value: v3, date: new Date(i * day_ms2) })).filter((a4) => a4.value);
    const xMin = min(date_values.map((d) => d.date));
    const xMax = max(date_values.map((d) => d.date));
    const x5 = time().domain([xMin, xMax]).range([0, width2]);
    const yMax = max(values2) || 0;
    const y5 = linear3().domain([yMax, 0]).range([0, height2]).nice();
    const axis2 = select_default2(svg2).attr("viewBox", `-40 -10 ${width2 + 50} ${height2 + 50}`).append("g");
    axis2.append("g").call(axisLeft(y5)).attr("opacity", 0.5);
    axis2.append("g").attr("transform", `translate(0, ${height2})`).attr("opacity", 0.5).call(axisBottom(x5).ticks(7));
    select_default2(svg2).append("path").datum(date_values).attr("fill", "none").attr("stroke", "steelblue").attr("stroke-width", 1.5).style("pointer-events", "none").attr(
      "d",
      line_default2().x((d) => x5(d.date)).y((d) => y5(d.value))
    );
    const bar_width = width2 / date_values.length + 1;
    axis2.append("g").selectAll("g").data(date_values.filter((a4) => a4)).join("rect").attr("class", "hover-bar").attr("height", height2).attr("width", (_25, i) => i > 0 ? bar_width : bar_width / 2).attr("x", (d, i) => x5(d.date) - (i > 0 ? bar_width / 2 : 0)).attr("y", 0).on("mouseover", (e, d) => {
      const value_string = d.value > 10 ? d.value.toFixed(0) : d.value.toPrecision(2);
      tooltip.set({
        x: tooltipX(e),
        y: e.pageY,
        text: [`${d.date.toLocaleDateString()}:`, `${label}: ${value_string}`]
      });
    });
    axis2.on("mouseover", () => tooltipShown.set(true)).on(
      "mouseleave",
      () => tooltipShown.set(false)
    );
  }

  // src/ts/LineGraph.svelte
  var root14 = ns_template(`<svg></svg>`);
  function LineGraph($$anchor, $$props) {
    push($$props, false);
    let svg2 = mutable_state();
    let label = prop($$props, "label", 8);
    let data2 = prop($$props, "data", 8);
    legacy_pre_effect(
      () => (get(svg2), renderLineChart, deep_read_state(data2()), deep_read_state(label())),
      () => {
        if (get(svg2)) renderLineChart(get(svg2), data2(), label());
      }
    );
    legacy_pre_effect_reset();
    init();
    var svg_1 = root14();
    bind_this(svg_1, ($$value) => set(svg2, $$value), () => get(svg2));
    append($$anchor, svg_1);
    pop();
  }

  // src/ts/LineOrCandlestick.svelte
  var root_18 = template(`<label><input type="radio"> </label> <label><input type="radio"> </label>`, 1);
  var root15 = template(`<!> <!>`, 1);
  function LineOrCandlestick($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $searchLimit = () => store_get(searchLimit, "$searchLimit", $$stores);
    const $binSize = () => store_get(binSize, "$binSize", $$stores);
    const $scroll = () => store_get(scroll, "$scroll", $$stores);
    const limit = mutable_state();
    const binding_group = [];
    let type2 = mutable_state("total");
    let data2 = prop($$props, "data", 8);
    let label = prop($$props, "label", 8, "value");
    let up_colour = prop($$props, "up_colour", 8, CANDLESTICK_GREEN);
    let down_colour = prop($$props, "down_colour", 8, CANDLESTICK_RED);
    let bins = mutable_state(30);
    let candlestick_data = mutable_state();
    let trend_data = prop($$props, "trend_data", 12);
    legacy_pre_effect(() => $searchLimit(), () => {
      set(limit, -1 - $searchLimit());
    });
    legacy_pre_effect(
      () => (deep_read_state(data2()), get(bins), $binSize(), $scroll(), DeltaIfy, deep_read_state(up_colour()), deep_read_state(down_colour())),
      () => {
        if (data2()) set(candlestick_data, {
          start: data2()[data2().length - get(bins) * $binSize() - Math.abs($scroll()) - 1] || 0,
          data: Array.from(DeltaIfy(data2())).map((delta, i) => ({ label: i.toString(), delta })),
          tick_spacing: 5,
          up_colour: up_colour(),
          down_colour: down_colour()
        });
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = root15();
    var node = first_child(fragment);
    GraphTypeSelector(node, {
      children: ($$anchor2, $$slotProps) => {
        var fragment_1 = root_18();
        var label_1 = first_child(fragment_1);
        var input = child(label_1);
        remove_input_defaults(input);
        input.value = null == (input.__value = "total") ? "" : "total";
        var text2 = sibling(input);
        reset(label_1);
        var label_2 = sibling(label_1, 2);
        var input_1 = child(label_2);
        remove_input_defaults(input_1);
        input_1.value = null == (input_1.__value = "trend") ? "" : "trend";
        var text_1 = sibling(input_1);
        reset(label_2);
        template_effect(
          ($0, $1) => {
            set_text(text2, ` ${$0 ?? ""}`);
            set_text(text_1, ` ${$1 ?? ""}`);
          },
          [
            () => i18n("total"),
            () => i18n("trend")
          ],
          derived_safe_equal
        );
        bind_group(binding_group, [], input, () => get(type2), ($$value) => set(type2, $$value));
        bind_group(binding_group, [], input_1, () => get(type2), ($$value) => set(type2, $$value));
        append($$anchor2, fragment_1);
      },
      $$slots: { default: true }
    });
    var node_1 = sibling(node, 2);
    {
      var consequent = ($$anchor2) => {
        LineGraph($$anchor2, {
          get data() {
            return data2();
          },
          get label() {
            return label();
          }
        });
      };
      var alternate = ($$anchor2) => {
        Candlestick($$anchor2, {
          get data() {
            return get(candlestick_data);
          },
          get limit() {
            return get(limit);
          },
          get bins() {
            return get(bins);
          },
          set bins($$value) {
            set(bins, $$value);
          },
          get binSize() {
            mark_store_binding();
            return $binSize();
          },
          set binSize($$value) {
            store_set(binSize, $$value);
          },
          get trend_data() {
            return trend_data();
          },
          set trend_data($$value) {
            trend_data($$value);
          },
          get offset() {
            mark_store_binding();
            return $scroll();
          },
          set offset($$value) {
            store_set(scroll, $$value);
          },
          $$legacy: true
        });
      };
      if_block(node_1, ($$render) => {
        if (get(type2) == "total") $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/matrix.ts
  var _19 = __toESM(require_lodash());
  function matrix({ grid, hoverTooltip }, svg2) {
    let bounds = defaultGraphBounds();
    const rows = Object.entries(grid).sort((a4, b10) => +b10[0] - +a4[0]);
    const x_groups = _19.range(1, 11).map((a4) => a4.toString());
    const box_size = bounds.width / 10;
    bounds.height = rows.length * box_size;
    const x5 = band().range([0, bounds.width]).domain(x_groups).padding(0.01);
    const y5 = band().range([bounds.height, 0]).domain(rows.map((row) => row[0])).padding(0.01);
    const axis2 = createAxis(svg2, 1, x5, y5, bounds);
    const data2 = rows.flatMap(([row, cols]) => cols.map((val, col) => ({ row, col, val }))).filter((d) => d.val !== void 0);
    const color2 = linear3().domain([-0.2, 0, 0.2]).interpolate(rgb_default).range(["red", "white", "blue"]);
    const margin = 3;
    function onHover(e, d) {
      tooltip.set({
        x: tooltipX(e),
        y: e.pageY,
        text: hoverTooltip(+d.row, d.col)
      });
      tooltipShown.set(true);
    }
    axis2.append("g").selectAll("rect").data(data2).enter().append("rect").attr("xr", margin).attr("yr", margin).attr("x", (d) => x5(d.col.toString()) + margin).attr("y", (d) => y5(d.row.toString()) + margin).attr("width", x5.bandwidth() - margin * 2).attr("height", y5.bandwidth() - margin * 2).style("fill", (d) => d.val !== void 0 ? color2(d.val) : "purple").style("stroke", "black").on("mouseover", onHover).on("mouseleave", () => tooltipShown.set(false));
    axis2.append("g").selectAll("text").data(data2).join("text").attr("x", (d) => x5(d.col.toString()) + x5.bandwidth() / 2).attr("y", (d) => y5(d.row.toString()) + y5.bandwidth() / 2).attr("dy", "0.35em").attr("text-anchor", "middle").style("fill", "black").style("font-size", "12px").text((d) => d.val !== void 0 ? `${(d.val * 100).toFixed(1)}%` : "").on("mouseover", onHover);
  }

  // src/ts/MemorisedBar.ts
  var import_lodash16 = __toESM(require_lodash());
  function getMemorisedDays(revlogs2, cards, configs, config_mapping, leech_elapsed_threshold = 10, leech_min_reviews = 5) {
    console.log(`ts-fsrs ${dt}`);
    let deckFsrs = {};
    let fsrsCards = {};
    let cards_by_id = IDify(cards);
    function getFsrs(config2) {
      const id2 = config2.id;
      if (!deckFsrs[id2]) {
        const configParams = [
          config2.fsrsParams6,
          config2.fsrsParams5,
          config2.fsrsParams4,
          config2.fsrsWeights
        ];
        const params = configParams.find((arr) => Array.isArray(arr) && arr.length > 0) ?? N;
        deckFsrs[id2] = yt(
          $({
            w: ot(params),
            enable_fuzz: false,
            enable_short_term: true
          })
        );
      }
      return deckFsrs[id2];
    }
    let retrievabilityDays = [];
    let totalCards = [];
    let noteRetrievabilityDays = [];
    let stable_retrievability_days = [];
    let cardCounts = cards.reduce(
      (p, c6) => {
        p[c6.nid] = (p[c6.nid] ?? 0) + 1;
        return p;
      },
      []
    );
    function card_config(cid) {
      const card = cards_by_id[cid];
      if (!card) {
        return void 0;
      }
      return configs[config_mapping[card.did]];
    }
    let stability_day_bins = [];
    let difficulty_day_bins = [];
    function forgetting_curve(fsrs, s2, from, to, card, cid) {
      for (const day of import_lodash16.default.range(from, to)) {
        const retrievability = fsrs.forgetting_curve(day - from, s2);
        const card_count = cardCounts[cards_by_id[cid].nid];
        retrievabilityDays[day] = (retrievabilityDays[day] || 0) + retrievability;
        totalCards[day] = (totalCards[day] | 0) + 1;
        if (card_count) {
          noteRetrievabilityDays[day] = (noteRetrievabilityDays[day] || 0) + retrievability / card_count;
        }
        if (card.stability) {
          let stability_weight2 = function(s3) {
            return 1 - Math.exp(-(8 / 365 * s3));
          };
          var stability_weight = stability_weight2;
          const stability_bin = Math.round(s2);
          stability_day_bins[day] ??= [];
          stability_day_bins[day][stability_bin] = (stability_day_bins[day][stability_bin] || 0) + 1;
          const difficulty_bin = Math.round(card.difficulty * 10) - 1;
          difficulty_day_bins[day] ??= Array(100).fill(0);
          difficulty_day_bins[day][difficulty_bin] += 1;
          stable_retrievability_days[day] = (stable_retrievability_days[day] || 0) + retrievability * stability_weight2(card.stability);
        }
      }
    }
    let last_stability = [];
    const default_bin = { predicted: 0, real: 0, count: 0 };
    function incrementLoss(bin2, predicted, real) {
      bin2 ??= { ...default_bin };
      bin2.predicted = (bin2.predicted || 0) + predicted;
      bin2.real = (bin2.real || 0) + real;
      bin2.count = (bin2.count || 0) + 1;
      return bin2;
    }
    let fatigue_bins = emptyBuckets(() => []);
    let today_so_far = 0;
    let last_date = /* @__PURE__ */ new Date();
    let bw_matrix_count = {};
    let day_medians = [];
    let day_means = [];
    let last_day = dayFromMs(revlogs2[0].id);
    let probabilities = import_lodash16.default.mapValues(
      import_lodash16.default.groupBy(revlogs2, (r) => r.cid),
      (_25) => [1]
    );
    for (const revlog of revlogs2) {
      const config2 = card_config(revlog.cid);
      if (!config2) {
        continue;
      }
      const grade = revlog.ease;
      const new_card = !fsrsCards[revlog.cid];
      const now2 = new Date(revlog.id);
      const fsrs = getFsrs(config2);
      let card = fsrsCards[revlog.cid] ?? E2(new Date(revlog.cid));
      for (let day = last_day; day < dayFromMs(revlog.id); day++) {
        const stabilities = Object.values(last_stability);
        day_medians[day] = quantile(stabilities, 0.5) ?? 0;
        day_means[day] = mean(stabilities) ?? 0;
      }
      last_day = dayFromMs(revlog.id);
      if (revlog.ivl == 0 && !new_card) {
        card = fsrs.forget(card, now2).card;
        fsrsCards[revlog.cid] = card;
        probabilities[revlog.cid] = [1];
      }
      if (grade == 0) {
        continue;
      }
      if (revlog.type == 3 && revlog.factor == 0) {
        continue;
      }
      if (last_stability[revlog.cid]) {
        const previous = dayFromMs(card.last_review.getTime());
        const stability = last_stability[revlog.cid];
        forgetting_curve(fsrs, stability, previous, dayFromMs(revlog.id), card, revlog.cid);
      }
      let memoryState = null;
      let elapsed = 0;
      if (card.last_review) {
        memoryState = card.stability ? {
          difficulty: card.difficulty,
          stability: card.stability
        } : null;
        const oldDate = new Date(card.last_review.getTime() - rollover_ms);
        oldDate.setHours(0, 0, 0, 0);
        const newDate2 = new Date(now2.getTime() - rollover_ms);
        newDate2.setHours(0, 0, 0, 0);
        elapsed = k2(oldDate, newDate2);
        if (newDate2.getTime() != last_date.getTime()) {
          today_so_far = 0;
          last_date = newDate2;
        }
        const p = fsrs.forgetting_curve(elapsed, card.stability);
        const y5 = grade > 1 ? 1 : 0;
        let card_type;
        fatigue_bins.all[today_so_far] = incrementLoss(fatigue_bins.all[today_so_far], p, y5);
        if (elapsed >= 1) {
          if (elapsed >= leech_elapsed_threshold) {
            if (!new_card) {
              const leech_probabilities2 = probabilities[revlog.cid];
              for (let j2 = leech_probabilities2.length + y5 - 1; j2 >= 0; j2--) {
                leech_probabilities2[j2] = (leech_probabilities2[j2] ?? 0) * (1 - p) + (j2 > 0 ? leech_probabilities2[j2 - 1] * p : 0);
              }
            }
          }
          if (!new_card && card.stability > 1) {
            const r_bin_power = 1.4;
            const r_bin = import_lodash16.default.round(
              Math.pow(
                r_bin_power,
                Math.floor(Math.log(card.stability) / Math.log(r_bin_power))
              ),
              2
            );
            const d_bin = Math.round(card.difficulty);
            bw_matrix_count[r_bin] ??= [];
            let retention_row = bw_matrix_count[r_bin];
            retention_row[d_bin] = incrementLoss(retention_row[d_bin], p, y5);
          }
          fatigue_bins.not_learn[today_so_far] = incrementLoss(
            fatigue_bins.not_learn[today_so_far],
            p,
            y5
          );
          if (elapsed >= 21) {
            card_type = fatigue_bins.mature;
          } else {
            card_type = fatigue_bins.young;
          }
        } else {
          card_type = fatigue_bins.learn;
        }
        card_type[today_so_far] = incrementLoss(card_type[today_so_far], p, y5);
        today_so_far += 1;
      }
      const newState = fsrs.next_state(memoryState, elapsed, grade);
      card.last_review = now2;
      card.stability = newState.stability;
      card.difficulty = newState.difficulty;
      last_stability[revlog.cid] = card.stability;
      fsrsCards[revlog.cid] = card;
    }
    let inaccurate_cids = [];
    let accurate_cids = [];
    for (const [cid, card] of Object.entries(fsrsCards)) {
      const num_cid = +cid;
      const previous = dayFromMs(card.last_review.getTime());
      const fsrs = getFsrs(card_config(num_cid));
      forgetting_curve(fsrs, last_stability[num_cid], previous, today + 1, card, num_cid);
      if (cards_by_id[num_cid].data && JSON.parse(cards_by_id[num_cid].data).s) {
        const expected = last_stability[num_cid];
        const actual = JSON.parse(cards_by_id[num_cid].data).s;
        if (Math.abs(expected - actual) > 0.01) {
          inaccurate_cids.push({
            cid: num_cid,
            expected: expected.toFixed(2),
            actual: actual.toFixed(2)
          });
        } else {
          accurate_cids.push(num_cid);
        }
      }
    }
    if (inaccurate_cids.length) {
      const mean_error = import_lodash16.default.meanBy(
        inaccurate_cids,
        (a4) => Math.abs(a4.expected - a4.actual)
      ).toFixed(2);
      console.warn(
        `The stability of the following ${inaccurate_cids.length}/${inaccurate_cids.length + accurate_cids.length} cards differ between SSE and anki with a mean error of ${mean_error}:`,
        { inaccurate_cids, accurate_cids }
      );
    }
    const fatigueRMSE = import_lodash16.default.mapValues(
      fatigue_bins,
      (bins) => bins.map(
        ({ real, predicted, count: count3 }) => [((real - predicted) / count3) ** 2 * count3, count3]
      )
    );
    const leech_probabilities = import_lodash16.default.mapValues(
      probabilities,
      (p) => p.length > leech_min_reviews ? import_lodash16.default.sum(p) : 1
    );
    return {
      retrievabilityDays,
      totalCards,
      noteRetrievabilityDays,
      stable_retrievability_days,
      fatigueRMSE,
      bw_matrix: bw_matrix_count,
      stability_bins_days: stability_day_bins,
      day_medians,
      day_means,
      leech_probabilities,
      difficulty_days: difficulty_day_bins
    };
  }

  // src/ts/MemorisedCalculator.svelte
  var root_37 = template(`<button class="big svelte-1ir14zw"> </button>`);
  var root_42 = template(`<button class="big svelte-1ir14zw"> </button> <button> </button>`, 1);
  function MemorisedCalculator($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $searchLimit = () => store_get(searchLimit, "$searchLimit", $$stores);
    const $revlogs = () => store_get(revlogs, "$revlogs", $$stores);
    const $card_data = () => store_get(card_data, "$card_data", $$stores);
    const $memorised_stats = () => store_get(memorised_stats, "$memorised_stats", $$stores);
    const truncated = mutable_state();
    let show = mutable_state(false);
    legacy_pre_effect(() => $searchLimit(), () => {
      set(truncated, $searchLimit() !== 0);
    });
    legacy_pre_effect(
      () => ($revlogs(), $card_data(), get(show), catchErrors, getMemorisedDays),
      () => {
        if ($revlogs() && $card_data() && get(show)) {
          store_set(memorised_stats, catchErrors(() => getMemorisedDays($revlogs(), $card_data(), SSEother.deck_configs, SSEother.deck_config_ids, 2, 2)));
        }
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent_1 = ($$anchor2) => {
        NoGraph($$anchor2, {
          faded: false,
          children: ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            var node_1 = first_child(fragment_2);
            {
              var consequent = ($$anchor4) => {
                var button = root_37();
                var text2 = child(button, true);
                reset(button);
                template_effect(($0) => set_text(text2, $0), [() => i18n("show-question")], derived_safe_equal);
                event("click", button, () => set(show, true));
                append($$anchor4, button);
              };
              var alternate = ($$anchor4) => {
                var fragment_3 = root_42();
                var button_1 = first_child(fragment_3);
                var text_1 = child(button_1, true);
                reset(button_1);
                var button_2 = sibling(button_1, 2);
                var text_2 = child(button_2, true);
                reset(button_2);
                template_effect(
                  ($0, $1) => {
                    set_text(text_1, $0);
                    set_text(text_2, $1);
                  },
                  [
                    () => i18n("increase-date-range"),
                    () => i18n("show-question")
                  ],
                  derived_safe_equal
                );
                event("click", button_1, function(...$$args) {
                  SetDateInfinite?.apply(this, $$args);
                });
                event("click", button_2, () => set(show, true));
                append($$anchor4, fragment_3);
              };
              if_block(node_1, ($$render) => {
                if (!get(truncated)) $$render(consequent);
                else $$render(alternate, false);
              });
            }
            append($$anchor3, fragment_2);
          },
          $$slots: { default: true }
        });
      };
      var alternate_1 = ($$anchor2, $$elseif) => {
        {
          var consequent_2 = ($$anchor3) => {
            NoGraph($$anchor3, {
              children: ($$anchor4, $$slotProps) => {
                next();
                var text_3 = text();
                template_effect(($0) => set_text(text_3, $0), [() => i18n("loading")], derived_safe_equal);
                append($$anchor4, text_3);
              },
              $$slots: { default: true }
            });
          };
          if_block(
            $$anchor2,
            ($$render) => {
              if (!memorised_stats) $$render(consequent_2);
            },
            $$elseif
          );
        }
      };
      if_block(node, ($$render) => {
        if (!get(show)) $$render(consequent_1);
        else $$render(alternate_1, false);
      });
    }
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/MemorisedBar.svelte
  var root_19 = template(`<!> <!> <div><label><input type="radio"> </label> <label><input type="radio"> </label> <label><input type="radio"> </label> <label><input type="radio"> </label></div>`, 1);
  var root_10 = ns_template(`<svg></svg>`);
  var root_9 = template(`<details><summary> </summary> <!></details>`);
  var root16 = template(`<!> <!>`, 1);
  function MemorisedBar($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $memorised_stats = () => store_get(memorised_stats, "$memorised_stats", $$stores);
    const $binSize = () => store_get(binSize, "$binSize", $$stores);
    const pattern = mutable_state();
    const binding_group = [];
    let retrievabilityDays = mutable_state(void 0);
    let stable_retrievability_days = mutable_state(void 0);
    let bw_matrix = mutable_state(void 0);
    var MemorisedType = mutable_state();
    (function(MemorisedType2) {
      MemorisedType2[MemorisedType2["RETRIEVABILITY"] = 0] = "RETRIEVABILITY";
      MemorisedType2[MemorisedType2["NOTES"] = 1] = "NOTES";
      MemorisedType2[MemorisedType2["STABLE_RETRIEVABILITY"] = 2] = "STABLE_RETRIEVABILITY";
      MemorisedType2[MemorisedType2["AVERAGE"] = 3] = "AVERAGE";
    })(safe_get(MemorisedType) || set(MemorisedType, {}));
    let memorised_type = mutable_state(safe_get(MemorisedType).RETRIEVABILITY);
    let trend_info = mutable_state();
    let trend_data = mutable_state();
    let svg2 = mutable_state(void 0);
    function hoverTooltip(x5, y5) {
      const data2 = $memorised_stats().bw_matrix[x5][y5];
      const value = (100 * (data2.predicted - data2.real) / data2.count).toFixed(1);
      return [
        `${i18n("predicted")}: ${data2.predicted.toFixed(2)}`,
        `${i18n("actual")}: ${data2.real.toFixed(0)}`,
        `${i18n("total")}: ${data2.count.toFixed(0)}`,
        `(${data2.predicted.toFixed(2)}-${data2.real.toFixed(0)})/${data2.count.toFixed(0)}=${value}%`
      ];
    }
    let average_r = mutable_state([]);
    legacy_pre_effect(() => $memorised_stats(), () => {
      set(retrievabilityDays, Array.from(($memorised_stats() === null || $memorised_stats() === void 0 ? void 0 : $memorised_stats().retrievabilityDays) || []));
    });
    legacy_pre_effect(() => $memorised_stats(), () => {
      set(stable_retrievability_days, Array.from(($memorised_stats() === null || $memorised_stats() === void 0 ? void 0 : $memorised_stats().stable_retrievability_days) || []));
    });
    legacy_pre_effect(() => $memorised_stats(), () => {
      set(bw_matrix, Object.fromEntries(Object.entries(($memorised_stats() === null || $memorised_stats() === void 0 ? void 0 : $memorised_stats().bw_matrix) || {}).map(([r_bin, row]) => {
        const new_row = row.map((bin2) => bin2.count > 50 ? (bin2.real - bin2.predicted) / bin2.count : void 0);
        new_row.length = 10;
        return [r_bin, new_row];
      })));
    });
    legacy_pre_effect(() => (get(trend_data), i18n_pattern), () => {
      set(pattern, ((get(trend_data) === null || get(trend_data) === void 0 ? void 0 : get(trend_data).slope) || 0) > 0 ? i18n_pattern("remembered-per-day") : i18n_pattern("forgotten-per-day"));
    });
    legacy_pre_effect(() => get(pattern), () => {
      set(trend_info, { pattern: get(pattern), absolute: true });
    });
    legacy_pre_effect(() => (get(svg2), get(bw_matrix), matrix), () => {
      if (get(svg2) && get(bw_matrix)) {
        matrix({ grid: get(bw_matrix), hoverTooltip }, get(svg2));
      }
    });
    legacy_pre_effect(
      () => ($memorised_stats(), _21, get(retrievabilityDays)),
      () => {
        if ($memorised_stats() === null || $memorised_stats() === void 0 ? void 0 : $memorised_stats().totalCards) {
          set(average_r, _21.zip(get(retrievabilityDays), $memorised_stats().totalCards).map(([r, c6]) => {
            console.log({ r, c: c6 });
            return (r !== null && r !== void 0 ? r : 0) / (c6 !== null && c6 !== void 0 ? c6 : 1);
          }));
        }
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = root16();
    var node = first_child(fragment);
    {
      var consequent_3 = ($$anchor2) => {
        var fragment_1 = root_19();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            const expression = derived_safe_equal(() => i18n("cards-and-stability"));
            LineOrCandlestick($$anchor3, {
              get data() {
                return get(stable_retrievability_days);
              },
              get label() {
                return get(expression);
              },
              get trend_data() {
                return get(trend_data);
              },
              set trend_data($$value) {
                set(trend_data, $$value);
              },
              $$legacy: true
            });
          };
          var alternate = ($$anchor3, $$elseif) => {
            {
              var consequent_1 = ($$anchor4) => {
                const expression_1 = derived_safe_equal(() => Array.from($memorised_stats().noteRetrievabilityDays || []));
                const expression_2 = derived_safe_equal(() => i18n("notes"));
                LineOrCandlestick($$anchor4, {
                  get data() {
                    return get(expression_1);
                  },
                  get label() {
                    return get(expression_2);
                  },
                  get trend_data() {
                    return get(trend_data);
                  },
                  set trend_data($$value) {
                    set(trend_data, $$value);
                  },
                  $$legacy: true
                });
              };
              var alternate_1 = ($$anchor4, $$elseif2) => {
                {
                  var consequent_2 = ($$anchor5) => {
                    const expression_3 = derived_safe_equal(() => i18n("cards"));
                    LineOrCandlestick($$anchor5, {
                      get data() {
                        return get(retrievabilityDays);
                      },
                      get label() {
                        return get(expression_3);
                      },
                      get trend_data() {
                        return get(trend_data);
                      },
                      set trend_data($$value) {
                        set(trend_data, $$value);
                      },
                      $$legacy: true
                    });
                  };
                  var alternate_2 = ($$anchor5) => {
                    const expression_4 = derived_safe_equal(() => i18n("retrievability"));
                    LineOrCandlestick($$anchor5, {
                      get data() {
                        return get(average_r);
                      },
                      get label() {
                        return get(expression_4);
                      },
                      get trend_data() {
                        return get(trend_data);
                      },
                      set trend_data($$value) {
                        set(trend_data, $$value);
                      },
                      $$legacy: true
                    });
                  };
                  if_block(
                    $$anchor4,
                    ($$render) => {
                      if (get(memorised_type) == safe_get(MemorisedType).RETRIEVABILITY) $$render(consequent_2);
                      else $$render(alternate_2, false);
                    },
                    $$elseif2
                  );
                }
              };
              if_block(
                $$anchor3,
                ($$render) => {
                  if (get(memorised_type) == safe_get(MemorisedType).NOTES) $$render(consequent_1);
                  else $$render(alternate_1, false);
                },
                $$elseif
              );
            }
          };
          if_block(node_1, ($$render) => {
            if (get(memorised_type) === safe_get(MemorisedType).STABLE_RETRIEVABILITY) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        var node_2 = sibling(node_1, 2);
        TrendValue(node_2, {
          get info() {
            return get(trend_info);
          },
          get trend() {
            return get(trend_data);
          },
          get n() {
            return $binSize();
          }
        });
        var div = sibling(node_2, 2);
        var label = child(div);
        var input = child(label);
        remove_input_defaults(input);
        var input_value;
        var text2 = sibling(input);
        reset(label);
        var label_1 = sibling(label, 2);
        var input_1 = child(label_1);
        remove_input_defaults(input_1);
        var input_1_value;
        var text_1 = sibling(input_1);
        reset(label_1);
        var label_2 = sibling(label_1, 2);
        var input_2 = child(label_2);
        remove_input_defaults(input_2);
        var input_2_value;
        var text_2 = sibling(input_2);
        reset(label_2);
        var label_3 = sibling(label_2, 2);
        var input_3 = child(label_3);
        remove_input_defaults(input_3);
        var input_3_value;
        var text_3 = sibling(input_3);
        reset(label_3);
        reset(div);
        template_effect(
          ($0, $1, $2, $3) => {
            if (input_value !== (input_value = safe_get(MemorisedType).RETRIEVABILITY)) {
              input.value = null == (input.__value = safe_get(MemorisedType).RETRIEVABILITY) ? "" : safe_get(MemorisedType).RETRIEVABILITY;
            }
            set_text(text2, ` ${$0 ?? ""}`);
            if (input_1_value !== (input_1_value = safe_get(MemorisedType).NOTES)) {
              input_1.value = null == (input_1.__value = safe_get(MemorisedType).NOTES) ? "" : safe_get(MemorisedType).NOTES;
            }
            set_text(text_1, ` ${$1 ?? ""}`);
            if (input_2_value !== (input_2_value = safe_get(MemorisedType).AVERAGE)) {
              input_2.value = null == (input_2.__value = safe_get(MemorisedType).AVERAGE) ? "" : safe_get(MemorisedType).AVERAGE;
            }
            set_text(text_2, ` ${$2 ?? ""}`);
            if (input_3_value !== (input_3_value = safe_get(MemorisedType).STABLE_RETRIEVABILITY)) {
              input_3.value = null == (input_3.__value = safe_get(MemorisedType).STABLE_RETRIEVABILITY) ? "" : safe_get(MemorisedType).STABLE_RETRIEVABILITY;
            }
            set_text(text_3, ` ${$3 ?? ""}`);
          },
          [
            () => i18n("cards"),
            () => i18n("notes"),
            () => i18n("average-retrievability"),
            () => i18n("retrievability-and-stability")
          ],
          derived_safe_equal
        );
        bind_group(
          binding_group,
          [],
          input,
          () => {
            safe_get(MemorisedType).RETRIEVABILITY;
            return get(memorised_type);
          },
          ($$value) => set(memorised_type, $$value)
        );
        bind_group(
          binding_group,
          [],
          input_1,
          () => {
            safe_get(MemorisedType).NOTES;
            return get(memorised_type);
          },
          ($$value) => set(memorised_type, $$value)
        );
        bind_group(
          binding_group,
          [],
          input_2,
          () => {
            safe_get(MemorisedType).AVERAGE;
            return get(memorised_type);
          },
          ($$value) => set(memorised_type, $$value)
        );
        bind_group(
          binding_group,
          [],
          input_3,
          () => {
            safe_get(MemorisedType).STABLE_RETRIEVABILITY;
            return get(memorised_type);
          },
          ($$value) => set(memorised_type, $$value)
        );
        append($$anchor2, fragment_1);
      };
      var alternate_3 = ($$anchor2) => {
        MemorisedCalculator($$anchor2, {});
      };
      if_block(node, ($$render) => {
        if ($memorised_stats()) $$render(consequent_3);
        else $$render(alternate_3, false);
      });
    }
    var node_3 = sibling(node, 2);
    {
      var consequent_4 = ($$anchor2) => {
        var details = root_9();
        var summary = child(details);
        var text_4 = child(summary, true);
        reset(summary);
        var node_4 = sibling(summary, 2);
        GraphContainer(node_4, {
          children: ($$anchor3, $$slotProps) => {
            var svg_1 = root_10();
            bind_this(svg_1, ($$value) => set(svg2, $$value), () => get(svg2));
            append($$anchor3, svg_1);
          },
          $$slots: { default: true }
        });
        reset(details);
        template_effect(($0) => set_text(text_4, $0), [() => i18n("b-w-matrix")], derived_safe_equal);
        append($$anchor2, details);
      };
      if_block(node_3, ($$render) => {
        if (get(bw_matrix)) $$render(consequent_4);
      });
    }
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/TimeMachineScroll.svelte
  var root17 = template(`<label class="scroll svelte-s3d78x"><span> </span> <span class="scroll svelte-s3d78x"> <input type="range"> 0</span></label>`);
  function TimeMachineScroll($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $scroll = () => store_get(scroll, "$scroll", $$stores);
    let min4 = prop($$props, "min", 8, 0);
    init();
    var label = root17();
    var span = child(label);
    var text2 = child(span);
    reset(span);
    var span_1 = sibling(span, 2);
    var text_1 = child(span_1);
    var input = sibling(text_1);
    remove_input_defaults(input);
    set_attribute(input, "max", 0);
    next();
    reset(span_1);
    reset(label);
    template_effect(
      ($0) => {
        set_text(text2, `${$0 ?? ""}:`);
        set_text(text_1, `${min4() ?? ""} `);
        set_attribute(input, "min", min4());
      },
      [
        () => new Date(Date.now() + $scroll() * day_ms2).toLocaleDateString()
      ],
      derived_safe_equal
    );
    bind_value(input, $scroll, ($$value) => store_set(scroll, $$value));
    append($$anchor, label);
    pop();
    $$cleanup();
  }

  // src/ts/RevlogGraphs.svelte
  var root_27 = template(`<h1> </h1> <!> <p> </p> <p> </p>`, 1);
  var root_38 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_110 = template(`<!> <!>`, 1);
  var root_52 = template(`<h1> </h1> <!> <p> </p> <!>`, 1);
  var root_82 = template(`<h1> </h1> <!> <span> </span> <p> </p> <!>`, 1);
  var root_11 = template(`<h1> </h1> <!> <label><input type="checkbox"> </label> <label><input type="checkbox"> </label> <p> </p>`, 1);
  var root_43 = template(`<!> <!> <!>`, 1);
  var root_132 = template(`<h1> </h1> <!> <label><input type="checkbox"> </label> <!> <p> </p>`, 1);
  var root_142 = template(`<h1> </h1> <!> <label><input type="checkbox"> </label> <p> </p>`, 1);
  var root_152 = template(`<h1> </h1> <!> <label><input type="checkbox"> </label> <!> <p> </p>`, 1);
  var root_122 = template(`<!> <!> <!>`, 1);
  var root_172 = template(`<h1> </h1> <!> <p> </p> <!> <!>`, 1);
  var root_20 = template(`<h1> </h1> <!> <span> </span> <span> </span> <p> </p>`, 1);
  var root_162 = template(`<!> <!>`, 1);
  var root_222 = template(`<h1> </h1> <!> <!> <p> </p>`, 1);
  var root_262 = template(`<!> <!> <p> </p> <!>`, 1);
  var root_252 = template(`<h1> </h1> <!>`, 1);
  var root_31 = template(`<label class="scroll"> <input type="range"></label> <!> <label class="scroll"><span> </span> <!></label> <p> </p> <!>`, 1);
  var root_30 = template(`<h1> </h1> <!>`, 1);
  var root_362 = template(`<!> <p> </p> <div><label><input type="radio"> </label> <label><input type="radio"> </label></div>`, 1);
  var root_352 = template(`<h1> </h1> <!>`, 1);
  var root_21 = template(`<!> <!> <!> <!>`, 1);
  var root_40 = template(`<input type="number">`);
  var root_39 = template(`<h1> </h1> <!> <!> <div> <br> <label><input type="radio"> </label> <label><input type="radio"> </label> <label><input type="radio"> </label> <!></div> <span> </span> <p> </p> <!>`, 1);
  var root_432 = template(`<h1> </h1> <!> <!> <span> </span> <p> </p> <span> </span> <!>`, 1);
  var root_46 = template(`<h1> </h1> <div class="options svelte-6sqpe2"><label class="svelte-6sqpe2"> <input type="number"></label> <input type="button"></div> <!> <label><input type="checkbox"> </label> <!> <p> </p>`, 1);
  var root_382 = template(`<!> <!> <!>`, 1);
  var root_49 = template(`<label> <input type="range"></label> <!> <p> <a href="https://forums.ankiweb.net/t/automated-leech-detection/56887">Forum discussion link</a></p>`, 1);
  var root_48 = template(`<h1> </h1> <!>`, 1);
  var root_51 = template(`<h1> </h1> <!> <label><input type="checkbox"> </label> <p> </p>`, 1);
  var root_522 = template(`<h1> </h1> <!> <label><input type="checkbox"> </label> <!> <p> </p>`, 1);
  var root_54 = template(`<!> <!>`, 1);
  var root_53 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_47 = template(`<!> <!> <!> <!>`, 1);
  var root18 = template(`<!> <!> <!> <!> <!> <!> <!>`, 1);
  function RevlogGraphs($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $scroll = () => store_get(scroll, "$scroll", $$stores);
    const $binSize = () => store_get(binSize, "$binSize", $$stores);
    const $memorised_stats = () => store_get(memorised_stats, "$memorised_stats", $$stores);
    const $searchLimit = () => store_get(searchLimit, "$searchLimit", $$stores);
    const $pieLast = () => store_get(pieLast, "$pieLast", $$stores);
    const $pieSteps = () => store_get(pieSteps, "$pieSteps", $$stores);
    const day_initial_ease = mutable_state();
    const day_initial_reintroduced_ease = mutable_state();
    const day_ease = mutable_state();
    const fatigue_ease = mutable_state();
    const revlog_times = mutable_state();
    const time_ease_seconds = mutable_state();
    const sibling_time_ease = mutable_state();
    const introduced_day_count = mutable_state();
    const reintroduced_day_count = mutable_state();
    const burden = mutable_state();
    const day_forgotten = mutable_state();
    const remaining_forgotten = mutable_state();
    const intervals = mutable_state();
    const interval_ease = mutable_state();
    const day_review_hours = mutable_state();
    const day_filtered_review_hours = mutable_state();
    const learn_steps_per_card = mutable_state();
    const burden_change = mutable_state();
    const realScroll = mutable_state();
    const start2 = mutable_state();
    const burden_start = mutable_state();
    const introduced_bar = mutable_state();
    const forgotten_bar = mutable_state();
    const time_machine_intervals = mutable_state();
    const time_machine_intra_day = mutable_state();
    const time_machine_learn = mutable_state();
    const time_machine_young = mutable_state();
    const time_machine_mature = mutable_state();
    const time_machine_suspended = mutable_state();
    const time_machine_added = mutable_state();
    const total_intervals = mutable_state();
    const intervals_mean = mutable_state();
    const review_leftmost = mutable_state();
    const added_leftmost = mutable_state();
    const time_machine_min = mutable_state();
    const hours_begin = mutable_state();
    const hours_end = mutable_state();
    const day_range = mutable_state();
    const todays_hours = mutable_state();
    const difficulty_binner = mutable_state();
    const difficulty_bins = mutable_state();
    const learn_repetitions = mutable_state();
    const truncated = mutable_state();
    const introduced_ease = mutable_state();
    const limit = mutable_state();
    const leech_bins = mutable_state();
    const binding_group = [];
    const binding_group_1 = [];
    const binding_group_2 = [];
    var _a = mutable_state(), _b = mutable_state(), _c = mutable_state(), _d = mutable_state(), _e = mutable_state(), _f = mutable_state(), _g = mutable_state(), _h = mutable_state();
    let revlogData = prop($$props, "revlogData", 8);
    let cardData = prop($$props, "cardData", 8);
    let addedCards = prop($$props, "addedCards", 8);
    const bins = 30;
    function barLabel(i) {
      return (i - today).toString();
    }
    var Average = mutable_state();
    (function(Average2) {
      Average2[Average2["MEDIAN"] = 0] = "MEDIAN";
      Average2[Average2["MEAN"] = 1] = "MEAN";
    })(safe_get(Average) || set(Average, {}));
    let average_type = mutable_state(safe_get(Average).MEDIAN);
    let left_bound_at = mutable_state("Review");
    function minIndex2(vals) {
      var _a2;
      return (_a2 = import_lodash17.default.min(Object.keys(vals).map((k3) => parseInt(k3)))) !== null && _a2 !== void 0 ? _a2 : 0;
    }
    let custom_leftmost = mutable_state(0);
    let time_machine_pie = mutable_state();
    let time_machine_bar = mutable_state();
    let range6 = mutable_state(7);
    let filtered = mutable_state(false);
    let hours_time_machine = mutable_state();
    let stability_time_machine_bar = mutable_state();
    let granularity = mutable_state(20);
    let difficulty_time_machine_bar = mutable_state();
    let include_reintroduced = mutable_state(true);
    let normalize_ease = mutable_state(false);
    let mature_filter = mutable_state("not_learn");
    let fatigue_bin_size = mutable_state(10);
    let interval_scroll = mutable_state(1);
    let interval_bin_size = mutable_state(1);
    let retention_trend = (values2) => import_lodash17.default.sum(values2) == 0 ? 0 : 1 - values2[3];
    let burden_trend = mutable_state();
    let granularity_power = mutable_state(1);
    const domain = [0.05, 1];
    let leech_detection_bar = mutable_state();
    legacy_pre_effect(
      () => (get(day_initial_ease), get(day_initial_reintroduced_ease), get(day_ease), get(fatigue_ease), get(revlog_times), get(time_ease_seconds), get(sibling_time_ease), get(introduced_day_count), get(reintroduced_day_count), get(burden), get(day_forgotten), get(remaining_forgotten), get(intervals), get(interval_ease), get(day_review_hours), get(day_filtered_review_hours), get(learn_steps_per_card), catchErrors, calculateRevlogStats, deep_read_state(revlogData()), deep_read_state(cardData())),
      () => {
        (($$value) => (set(day_initial_ease, $$value.day_initial_ease), set(day_initial_reintroduced_ease, $$value.day_initial_reintroduced_ease), set(day_ease, $$value.day_ease), set(fatigue_ease, $$value.fatigue_ease), set(revlog_times, $$value.revlog_times), set(time_ease_seconds, $$value.time_ease_seconds), set(sibling_time_ease, $$value.sibling_time_ease), set(introduced_day_count, $$value.introduced_day_count), set(reintroduced_day_count, $$value.reintroduced_day_count), set(burden, $$value.burden), set(day_forgotten, $$value.day_forgotten), set(remaining_forgotten, $$value.remaining_forgotten), set(intervals, $$value.intervals), set(interval_ease, $$value.interval_ease), set(day_review_hours, $$value.day_review_hours), set(day_filtered_review_hours, $$value.day_filtered_review_hours), set(learn_steps_per_card, $$value.learn_steps_per_card)))(catchErrors(() => calculateRevlogStats(revlogData(), cardData())));
      }
    );
    legacy_pre_effect(() => (DeltaIfy, get(burden)), () => {
      set(burden_change, DeltaIfy(get(burden)));
    });
    legacy_pre_effect(() => $scroll(), () => {
      set(realScroll, -Math.abs($scroll()));
    });
    legacy_pre_effect(() => (today, $binSize(), get(realScroll)), () => {
      set(start2, today - bins * $binSize() + get(realScroll));
    });
    legacy_pre_effect(
      () => (safe_get(_a), get(burden), get(start2)),
      () => {
        set(burden_start, set(_a, get(burden)[get(start2)]) !== null && safe_get(_a) !== void 0 ? safe_get(_a) : 0);
      }
    );
    legacy_pre_effect(
      () => (i18n, get(introduced_day_count), get(reintroduced_day_count), barDateLabeler),
      () => {
        set(introduced_bar, {
          row_colours: ["#13e0eb", "#0c8b91"],
          row_labels: [
            i18n("introduced"),
            i18n("re-introduced")
          ],
          data: Array.from(get(introduced_day_count)).map((v3, i) => {
            var _a2;
            const introduced = v3 !== null && v3 !== void 0 ? v3 : 0;
            const reintroduced = (_a2 = get(reintroduced_day_count)[i]) !== null && _a2 !== void 0 ? _a2 : 0;
            return {
              values: [introduced - reintroduced, reintroduced],
              label: barLabel(i)
            };
          }).map((d, i) => d !== null && d !== void 0 ? d : { values: [0, 0], label: barLabel(i) }),
          tick_spacing: 5,
          columnLabeler: barDateLabeler
        });
      }
    );
    legacy_pre_effect(
      () => (i18n, get(day_forgotten), barDateLabeler),
      () => {
        set(forgotten_bar, {
          row_colours: ["#330900"],
          row_labels: [i18n("forgotten")],
          data: Array.from(get(day_forgotten)).map((v3, i) => ({
            values: [v3 !== null && v3 !== void 0 ? v3 : 0],
            label: barLabel(i)
          })),
          tick_spacing: 5,
          columnLabeler: barDateLabeler
        });
      }
    );
    legacy_pre_effect(
      () => (safe_get(_b), get(intervals), today, get(realScroll)),
      () => {
        set(time_machine_intervals, set(_b, get(intervals)[today + get(realScroll)]) !== null && safe_get(_b) !== void 0 ? safe_get(_b) : []);
      }
    );
    legacy_pre_effect(() => get(time_machine_intervals), () => {
      set(time_machine_intra_day, get(time_machine_intervals)[0] || 0);
    });
    legacy_pre_effect(() => get(time_machine_intervals), () => {
      set(time_machine_learn, get(time_machine_intervals)[-2] || 0);
    });
    legacy_pre_effect(() => (import_lodash17.default, get(time_machine_intervals)), () => {
      set(time_machine_young, import_lodash17.default.sum(get(time_machine_intervals).slice(1, 21)) || 0);
    });
    legacy_pre_effect(() => (import_lodash17.default, get(time_machine_intervals)), () => {
      set(time_machine_mature, import_lodash17.default.sum(get(time_machine_intervals).slice(21)) || 0);
    });
    legacy_pre_effect(
      () => (safe_get(_c), get(time_machine_intervals)),
      () => {
        set(time_machine_suspended, set(_c, get(time_machine_intervals)[-1]) !== null && safe_get(_c) !== void 0 ? safe_get(_c) : 0);
      }
    );
    legacy_pre_effect(
      () => (deep_read_state(addedCards()), get(realScroll)),
      () => {
        set(time_machine_added, Object.entries(addedCards()).reduce((p, [i, v3]) => p + (+i <= get(realScroll) ? v3 : 0), 0));
      }
    );
    legacy_pre_effect(
      () => (get(time_machine_mature), get(time_machine_young), get(time_machine_intra_day)),
      () => {
        set(total_intervals, get(time_machine_mature) + get(time_machine_young) + get(time_machine_intra_day));
      }
    );
    legacy_pre_effect(
      () => (get(intervals), today, get(realScroll), get(total_intervals)),
      () => {
        set(intervals_mean, get(intervals)[today + get(realScroll)].reduce((p, c6, i) => p + c6 * i) / get(total_intervals));
      }
    );
    legacy_pre_effect(() => (get(intervals), today), () => {
      set(review_leftmost, minIndex2(get(intervals)) - today);
    });
    legacy_pre_effect(() => deep_read_state(addedCards()), () => {
      set(added_leftmost, minIndex2(addedCards()));
    });
    legacy_pre_effect(
      () => (get(review_leftmost), get(added_leftmost), get(custom_leftmost), get(left_bound_at)),
      () => {
        set(time_machine_min, {
          Review: get(review_leftmost),
          Added: get(added_leftmost),
          Custom: -Math.abs(get(custom_leftmost))
        }[get(left_bound_at)]);
      }
    );
    legacy_pre_effect(
      () => (i18n, get(time_machine_mature), MATURE_COLOUR, get(time_machine_young), YOUNG_COLOUR, get(time_machine_learn), LEARN_COLOUR, get(time_machine_intra_day), RELEARN_COLOUR, get(time_machine_suspended), get(time_machine_added)),
      () => {
        set(time_machine_pie, [
          {
            label: i18n("mature-count"),
            value: get(time_machine_mature),
            colour: MATURE_COLOUR
          },
          {
            label: i18n("young-count"),
            value: get(time_machine_young),
            colour: YOUNG_COLOUR
          },
          {
            label: i18n("learning-count"),
            value: get(time_machine_learn),
            colour: LEARN_COLOUR
          },
          {
            label: i18n("relearning-count"),
            value: get(time_machine_intra_day) - get(time_machine_learn),
            colour: RELEARN_COLOUR
          },
          {
            label: i18n("suspended"),
            value: get(time_machine_suspended),
            colour: "yellow"
          },
          {
            label: i18n("new-count"),
            value: get(time_machine_added) - get(time_machine_young) - get(time_machine_mature) - get(time_machine_intra_day) - get(time_machine_suspended),
            colour: "#6baed6"
          }
        ]);
      }
    );
    legacy_pre_effect(
      () => (i18n, get(time_machine_intervals), barStringLabeler, safe_get(_d), i18n_bundle),
      () => {
        set(time_machine_bar, {
          row_colours: ["#70AFD6"],
          row_labels: [i18n("cards")],
          data: Array.from(get(time_machine_intervals)).map((v3, i) => ({
            values: [v3 !== null && v3 !== void 0 ? v3 : 0],
            label: i.toString()
          })),
          tick_spacing: 5,
          columnLabeler: barStringLabeler(set(_d, i18n_bundle.getMessage("interval-of")) === null || safe_get(_d) === void 0 ? void 0 : safe_get(_d).value)
        });
      }
    );
    legacy_pre_effect(
      () => (no_rollover_today, get(realScroll), get(range6)),
      () => {
        set(hours_begin, no_rollover_today + get(realScroll) - get(range6) + 1);
      }
    );
    legacy_pre_effect(() => (no_rollover_today, get(realScroll)), () => {
      set(hours_end, no_rollover_today + get(realScroll) + 2);
    });
    legacy_pre_effect(
      () => (get(filtered), get(day_filtered_review_hours), get(hours_begin), get(hours_end), get(day_review_hours)),
      () => {
        set(day_range, get(filtered) ? get(day_filtered_review_hours).slice(get(hours_begin), get(hours_end)) : get(day_review_hours).slice(get(hours_begin), get(hours_end)));
      }
    );
    legacy_pre_effect(() => (import_lodash17.default, get(day_range)), () => {
      set(todays_hours, import_lodash17.default.zip(...get(day_range)).map(import_lodash17.default.sum));
    });
    legacy_pre_effect(
      () => (i18n, get(todays_hours), barHourLabeler),
      () => {
        set(hours_time_machine, {
          row_colours: ["#70AFD6"],
          row_labels: [i18n("cards")],
          data: Array.from(get(todays_hours) !== null && get(todays_hours) !== void 0 ? get(todays_hours) : []).map((v3, i) => ({
            values: [v3 !== null && v3 !== void 0 ? v3 : 0],
            label: i.toString()
          })),
          tick_spacing: 6,
          columnLabeler: barHourLabeler
        });
      }
    );
    legacy_pre_effect(
      () => (i18n, safe_get(_e), $memorised_stats(), today, get(realScroll), barStringLabeler, safe_get(_f), i18n_bundle),
      () => {
        set(stability_time_machine_bar, {
          row_colours: ["#70AFD6"],
          row_labels: [i18n("cards")],
          data: Array.from(set(_e, $memorised_stats() === null || $memorised_stats() === void 0 ? void 0 : $memorised_stats().stability_bins_days[today + get(realScroll)]) !== null && safe_get(_e) !== void 0 ? safe_get(_e) : []).map((v3, i) => ({
            values: [v3 !== null && v3 !== void 0 ? v3 : 0],
            label: i.toString()
          })),
          tick_spacing: 5,
          columnLabeler: barStringLabeler(set(_f, i18n_bundle.getMessage("stability-of")) === null || safe_get(_f) === void 0 ? void 0 : safe_get(_f).value)
        });
      }
    );
    legacy_pre_effect(() => get(granularity_power), () => {
      set(granularity, 20 * Math.pow(2, get(granularity_power) - 1));
    });
    legacy_pre_effect(() => (src_exports, get(granularity)), () => {
      set(difficulty_binner, bin().thresholds(get(granularity)).domain([0, 100]).value((a4) => a4[0]));
    });
    legacy_pre_effect(
      () => (get(difficulty_binner), safe_get(_g), $memorised_stats(), today, get(realScroll)),
      () => {
        set(difficulty_bins, get(difficulty_binner)([
          ...(set(_g, $memorised_stats() === null || $memorised_stats() === void 0 ? void 0 : $memorised_stats().difficulty_days[today + get(realScroll)]) !== null && safe_get(_g) !== void 0 ? safe_get(_g) : []).entries()
        ]));
      }
    );
    legacy_pre_effect(
      () => (i18n, get(difficulty_bins), import_lodash17.default, barStringLabeler, i18n_pattern),
      () => {
        set(difficulty_time_machine_bar, {
          row_colours: ["red"],
          row_labels: [i18n("card-count")],
          data: Array.from(get(difficulty_bins)).map((v3, i) => {
            var _a2;
            return {
              values: [import_lodash17.default.sumBy(v3, (v4) => v4[1])],
              label: `${((_a2 = v3 === null || v3 === void 0 ? void 0 : v3[0]) === null || _a2 === void 0 ? void 0 : _a2[0]) / 10}`
            };
          }),
          tick_spacing: get(difficulty_bins).length / 5,
          barWidth: 10 / get(difficulty_bins).length + 1,
          columnLabeler: barStringLabeler(i18n_pattern("difficulty-of"))
        });
      }
    );
    legacy_pre_effect(() => get(learn_steps_per_card), () => {
      set(learn_repetitions, get(learn_steps_per_card).reduce(
        (learn_repetitions2, count3) => {
          var _a2;
          learn_repetitions2[count3] = ((_a2 = learn_repetitions2[count3]) !== null && _a2 !== void 0 ? _a2 : 0) + 1;
          return learn_repetitions2;
        },
        {}
      ));
    });
    legacy_pre_effect(() => $searchLimit(), () => {
      set(truncated, $searchLimit() !== 0);
    });
    legacy_pre_effect(
      () => (get(include_reintroduced), get(day_initial_reintroduced_ease), get(day_initial_ease)),
      () => {
        set(introduced_ease, get(include_reintroduced) ? get(day_initial_reintroduced_ease) : get(day_initial_ease));
      }
    );
    legacy_pre_effect(() => $searchLimit(), () => {
      set(limit, -1 - $searchLimit());
    });
    legacy_pre_effect(
      () => (src_exports, get(granularity), safe_get(_h), $memorised_stats()),
      () => {
        set(leech_bins, bin().domain(domain).thresholds(get(granularity)).value((a4) => 1 - a4[1])(Object.entries(set(_h, $memorised_stats() === null || $memorised_stats() === void 0 ? void 0 : $memorised_stats().leech_probabilities) !== null && safe_get(_h) !== void 0 ? safe_get(_h) : [])));
      }
    );
    legacy_pre_effect(
      () => (i18n, get(leech_bins), browserSearchCids, get(granularity)),
      () => {
        set(leech_detection_bar, {
          row_colours: ["red"],
          row_labels: [i18n("cards")],
          data: get(leech_bins).map((bin2) => {
            var _a2, _b2;
            return {
              label: `${(_b2 = ((_a2 = bin2.x1) !== null && _a2 !== void 0 ? _a2 : 0) * 100) === null || _b2 === void 0 ? void 0 : _b2.toPrecision(3)}%`,
              values: [bin2.length],
              onClick: () => {
                browserSearchCids(bin2.map((e) => e[0]));
              }
            };
          }),
          tick_spacing: Math.floor(get(granularity) / 5),
          barWidth: (domain[1] - domain[0]) * 100 / get(leech_bins).length,
          columnLabeler: (v3, w) => `${(parseFloat(v3) - w).toPrecision(3)}%-${v3}`
        });
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = root18();
    var node = first_child(fragment);
    const expression = derived_safe_equal(() => i18n("time-distribution"));
    GraphCategory(node, {
      get hidden_title() {
        return get(expression);
      },
      config_name: "time",
      children: ($$anchor2, $$slotProps) => {
        var fragment_1 = root_110();
        var node_1 = first_child(fragment_1);
        GraphContainer(node_1, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_2 = root_27();
            var h1 = first_child(fragment_2);
            var text2 = child(h1, true);
            reset(h1);
            var node_2 = sibling(h1, 2);
            const expression_1 = derived_safe_equal(() => ({
              countDescriptor: i18n("most-seconds"),
              spectrumFrom: "#fcba03",
              spectrumTo: "#543e00",
              fillerColour: "blue",
              legend_left: i18n("time-in-seconds")
            }));
            IntervalGraph(node_2, {
              get intervals() {
                return get(revlog_times);
              },
              include_suspended_option: false,
              get pieInfo() {
                return get(expression_1);
              },
              get last() {
                mark_store_binding();
                return $pieLast();
              },
              set last($$value) {
                store_set(pieLast, $$value);
              },
              get steps() {
                mark_store_binding();
                return $pieSteps();
              },
              set steps($$value) {
                store_set(pieSteps, $$value);
              },
              $$legacy: true
            });
            var p_1 = sibling(node_2, 2);
            var text_1 = child(p_1, true);
            reset(p_1);
            var p_2 = sibling(p_1, 2);
            var text_2 = child(p_2, true);
            reset(p_2);
            template_effect(
              ($0, $1, $2) => {
                set_text(text2, $0);
                set_text(text_1, $1);
                set_text(text_2, $2);
              },
              [
                () => i18n("time-distribution"),
                () => i18n("time-distribution-help"),
                () => i18n("suspended-cards-warning")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_2);
          },
          $$slots: { default: true }
        });
        var node_3 = sibling(node_1, 2);
        GraphContainer(node_3, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_3 = root_38();
            var h1_1 = first_child(fragment_3);
            var text_3 = child(h1_1, true);
            reset(h1_1);
            var node_4 = sibling(h1_1, 2);
            const expression_2 = derived_safe_equal(() => get(revlog_times).map((i, a4) => i * a4));
            const expression_3 = derived_safe_equal(() => ({
              countDescriptor: i18n("most-seconds"),
              spectrumFrom: "#fcba03",
              spectrumTo: "#543e00",
              fillerColour: "blue",
              legend_left: i18n("seconds-per-card"),
              legend_right: i18n("total-seconds"),
              totalDescriptor: i18n("seconds")
            }));
            IntervalGraph(node_4, {
              get intervals() {
                return get(expression_2);
              },
              include_suspended_option: false,
              get pieInfo() {
                return get(expression_3);
              },
              get last() {
                mark_store_binding();
                return $pieLast();
              },
              set last($$value) {
                store_set(pieLast, $$value);
              },
              get steps() {
                mark_store_binding();
                return $pieSteps();
              },
              set steps($$value) {
                store_set(pieSteps, $$value);
              },
              $$legacy: true
            });
            var p_3 = sibling(node_4, 2);
            var text_4 = child(p_3, true);
            reset(p_3);
            template_effect(
              ($0, $1) => {
                set_text(text_3, $0);
                set_text(text_4, $1);
              },
              [
                () => i18n("time-totals"),
                () => i18n("time-totals-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_3);
          },
          $$slots: { default: true }
        });
        append($$anchor2, fragment_1);
      },
      $$slots: { default: true }
    });
    var node_5 = sibling(node, 2);
    const expression_4 = derived_safe_equal(() => i18n("introduced"));
    GraphCategory(node_5, {
      get hidden_title() {
        return get(expression_4);
      },
      config_name: "introduced",
      children: ($$anchor2, $$slotProps) => {
        var fragment_4 = root_43();
        var node_6 = first_child(fragment_4);
        GraphContainer(node_6, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_5 = root_52();
            var h1_2 = first_child(fragment_5);
            var text_5 = child(h1_2, true);
            reset(h1_2);
            var node_7 = sibling(h1_2, 2);
            BarScrollable(node_7, {
              get data() {
                return get(introduced_bar);
              },
              bins,
              get limit() {
                return get(limit);
              },
              get binSize() {
                mark_store_binding();
                return $binSize();
              },
              set binSize($$value) {
                store_set(binSize, $$value);
              },
              get offset() {
                mark_store_binding();
                return $scroll();
              },
              set offset($$value) {
                store_set(scroll, $$value);
              },
              $$legacy: true
            });
            var p_4 = sibling(node_7, 2);
            var text_6 = child(p_4, true);
            reset(p_4);
            var node_8 = sibling(p_4, 2);
            {
              var consequent = ($$anchor4) => {
                Warning($$anchor4, {
                  children: ($$anchor5, $$slotProps3) => {
                    next();
                    var text_7 = text();
                    template_effect(($0) => set_text(text_7, $0), [() => i18n("introduced-truncated-warning")], derived_safe_equal);
                    append($$anchor5, text_7);
                  },
                  $$slots: { default: true }
                });
              };
              if_block(node_8, ($$render) => {
                if (get(truncated)) $$render(consequent);
              });
            }
            template_effect(
              ($0, $1) => {
                set_text(text_5, $0);
                set_text(text_6, $1);
              },
              [
                () => i18n("introduced"),
                () => i18n("introduced-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_5);
          },
          $$slots: { default: true }
        });
        var node_9 = sibling(node_6, 2);
        GraphContainer(node_9, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_8 = root_82();
            var h1_3 = first_child(fragment_8);
            var text_8 = child(h1_3, true);
            reset(h1_3);
            var node_10 = sibling(h1_3, 2);
            BarScrollable(node_10, {
              get data() {
                return get(forgotten_bar);
              },
              bins,
              get limit() {
                return get(limit);
              },
              get binSize() {
                mark_store_binding();
                return $binSize();
              },
              set binSize($$value) {
                store_set(binSize, $$value);
              },
              get offset() {
                mark_store_binding();
                return $scroll();
              },
              set offset($$value) {
                store_set(scroll, $$value);
              },
              $$legacy: true
            });
            var span = sibling(node_10, 2);
            var text_9 = child(span, true);
            reset(span);
            var p_5 = sibling(span, 2);
            var text_10 = child(p_5, true);
            reset(p_5);
            var node_11 = sibling(p_5, 2);
            {
              var consequent_1 = ($$anchor4) => {
                Warning($$anchor4, {
                  children: ($$anchor5, $$slotProps3) => {
                    next();
                    var text_11 = text();
                    template_effect(($0) => set_text(text_11, $0), [() => i18n("forgotten-truncated-warning")], derived_safe_equal);
                    append($$anchor5, text_11);
                  },
                  $$slots: { default: true }
                });
              };
              if_block(node_11, ($$render) => {
                if (get(truncated)) $$render(consequent_1);
              });
            }
            template_effect(
              ($0, $1, $2) => {
                set_text(text_8, $0);
                set_text(text_9, $1);
                set_text(text_10, $2);
              },
              [
                () => i18n("forgotten"),
                () => i18n("forgotten-cards-not-yet-reintroduced", {
                  number: get(remaining_forgotten).toLocaleString()
                }),
                () => i18n("forgotten-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_8);
          },
          $$slots: { default: true }
        });
        var node_12 = sibling(node_9, 2);
        GraphContainer(node_12, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_11 = root_11();
            var h1_4 = first_child(fragment_11);
            var text_12 = child(h1_4, true);
            reset(h1_4);
            var node_13 = sibling(h1_4, 2);
            const expression_5 = derived_safe_equal(() => easeBarChart(get(introduced_ease), today, get(normalize_ease), barDateLabeler));
            const expression_6 = derived_safe_equal(() => ({
              pattern: i18n_pattern("retention-per-day"),
              percentage: true
            }));
            BarScrollable(node_13, {
              get data() {
                return get(expression_5);
              },
              get average() {
                return get(normalize_ease);
              },
              get trend() {
                return get(normalize_ease);
              },
              trend_by: retention_trend,
              get trend_info() {
                return get(expression_6);
              },
              get limit() {
                return get(limit);
              },
              get binSize() {
                mark_store_binding();
                return $binSize();
              },
              set binSize($$value) {
                store_set(binSize, $$value);
              },
              get offset() {
                mark_store_binding();
                return $scroll();
              },
              set offset($$value) {
                store_set(scroll, $$value);
              },
              $$legacy: true
            });
            var label = sibling(node_13, 2);
            var input = child(label);
            remove_input_defaults(input);
            var text_13 = sibling(input);
            reset(label);
            var label_1 = sibling(label, 2);
            var input_1 = child(label_1);
            remove_input_defaults(input_1);
            var text_14 = sibling(input_1);
            reset(label_1);
            var p_6 = sibling(label_1, 2);
            var text_15 = child(p_6, true);
            reset(p_6);
            template_effect(
              ($0, $1, $2, $3) => {
                set_text(text_12, $0);
                set_text(text_13, ` ${$1 ?? ""}`);
                set_text(text_14, ` ${$2 ?? ""}`);
                set_text(text_15, $3);
              },
              [
                () => i18n("introductory-rating"),
                () => i18n("include-re-introduced"),
                () => i18n("as-ratio"),
                () => i18n("introductory-rating-help")
              ],
              derived_safe_equal
            );
            bind_checked(input, () => get(include_reintroduced), ($$value) => set(include_reintroduced, $$value));
            bind_checked(input_1, () => get(normalize_ease), ($$value) => set(normalize_ease, $$value));
            append($$anchor3, fragment_11);
          },
          $$slots: { default: true }
        });
        append($$anchor2, fragment_4);
      },
      $$slots: { default: true }
    });
    var node_14 = sibling(node_5, 2);
    const expression_7 = derived_safe_equal(() => i18n("ratings"));
    GraphCategory(node_14, {
      get hidden_title() {
        return get(expression_7);
      },
      config_name: "rating",
      children: ($$anchor2, $$slotProps) => {
        var fragment_12 = root_122();
        var node_15 = first_child(fragment_12);
        GraphContainer(node_15, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_13 = root_132();
            var h1_5 = first_child(fragment_13);
            var text_16 = child(h1_5, true);
            reset(h1_5);
            var node_16 = sibling(h1_5, 2);
            const expression_8 = derived_safe_equal(() => easeBarChart(get(day_ease)[get(mature_filter)], today, get(normalize_ease), barDateLabeler));
            const expression_9 = derived_safe_equal(() => ({
              pattern: i18n_pattern("retention-per-day"),
              percentage: true
            }));
            BarScrollable(node_16, {
              get data() {
                return get(expression_8);
              },
              get average() {
                return get(normalize_ease);
              },
              get trend() {
                return get(normalize_ease);
              },
              trend_by: retention_trend,
              get trend_info() {
                return get(expression_9);
              },
              get limit() {
                return get(limit);
              },
              get binSize() {
                mark_store_binding();
                return $binSize();
              },
              set binSize($$value) {
                store_set(binSize, $$value);
              },
              get offset() {
                mark_store_binding();
                return $scroll();
              },
              set offset($$value) {
                store_set(scroll, $$value);
              },
              $$legacy: true
            });
            var label_2 = sibling(node_16, 2);
            var input_2 = child(label_2);
            remove_input_defaults(input_2);
            var text_17 = sibling(input_2);
            reset(label_2);
            var node_17 = sibling(label_2, 2);
            MatureFilterSelector(node_17, {
              get group() {
                return get(mature_filter);
              },
              set group($$value) {
                set(mature_filter, $$value);
              },
              $$legacy: true
            });
            var p_7 = sibling(node_17, 2);
            var text_18 = child(p_7, true);
            reset(p_7);
            template_effect(
              ($0, $1, $2) => {
                set_text(text_16, $0);
                set_text(text_17, ` ${$1 ?? ""}`);
                set_text(text_18, $2);
              },
              [
                () => i18n("ratings"),
                () => i18n("as-ratio"),
                () => i18n("ratings-help")
              ],
              derived_safe_equal
            );
            bind_checked(input_2, () => get(normalize_ease), ($$value) => set(normalize_ease, $$value));
            append($$anchor3, fragment_13);
          },
          $$slots: { default: true }
        });
        var node_18 = sibling(node_15, 2);
        GraphContainer(node_18, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_14 = root_142();
            var h1_6 = first_child(fragment_14);
            var text_19 = child(h1_6, true);
            reset(h1_6);
            var node_19 = sibling(h1_6, 2);
            const expression_10 = derived_safe_equal(() => easeBarChart(get(interval_ease), 1, get(normalize_ease), barStringLabeler(i18n_bundle.getMessage("interval-of")?.value)));
            const expression_11 = derived_safe_equal(() => ({
              pattern: i18n_pattern("retention-per-day-greater-interval"),
              percentage: true
            }));
            BarScrollable(node_19, {
              get data() {
                return get(expression_10);
              },
              get average() {
                return get(normalize_ease);
              },
              left_aligned: true,
              get trend() {
                return get(normalize_ease);
              },
              trend_by: retention_trend,
              get trend_info() {
                return get(expression_11);
              },
              get binSize() {
                return get(interval_bin_size);
              },
              set binSize($$value) {
                set(interval_bin_size, $$value);
              },
              get offset() {
                return get(interval_scroll);
              },
              set offset($$value) {
                set(interval_scroll, $$value);
              },
              $$legacy: true
            });
            var label_3 = sibling(node_19, 2);
            var input_3 = child(label_3);
            remove_input_defaults(input_3);
            var text_20 = sibling(input_3);
            reset(label_3);
            var p_8 = sibling(label_3, 2);
            var text_21 = child(p_8, true);
            reset(p_8);
            template_effect(
              ($0, $1, $2) => {
                set_text(text_19, $0);
                set_text(text_20, ` ${$1 ?? ""}`);
                set_text(text_21, $2);
              },
              [
                () => i18n("interval-ratings"),
                () => i18n("as-ratio"),
                () => i18n("interval-ratings-help")
              ],
              derived_safe_equal
            );
            bind_checked(input_3, () => get(normalize_ease), ($$value) => set(normalize_ease, $$value));
            append($$anchor3, fragment_14);
          },
          $$slots: { default: true }
        });
        var node_20 = sibling(node_18, 2);
        GraphContainer(node_20, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_15 = root_152();
            var h1_7 = first_child(fragment_15);
            var text_22 = child(h1_7, true);
            reset(h1_7);
            var node_21 = sibling(h1_7, 2);
            const expression_12 = derived_safe_equal(() => easeBarChart(get(time_ease_seconds)[get(mature_filter)], 0, get(normalize_ease), barStringLabeler(i18n_bundle.getMessage("x-seconds")?.value)));
            const expression_13 = derived_safe_equal(() => ({
              pattern: i18n_pattern("retention-per-second-spent"),
              percentage: true
            }));
            BarScrollable(node_21, {
              get data() {
                return get(expression_12);
              },
              get average() {
                return get(normalize_ease);
              },
              left_aligned: true,
              get trend() {
                return get(normalize_ease);
              },
              trend_by: retention_trend,
              get trend_info() {
                return get(expression_13);
              }
            });
            var label_4 = sibling(node_21, 2);
            var input_4 = child(label_4);
            remove_input_defaults(input_4);
            var text_23 = sibling(input_4);
            reset(label_4);
            var node_22 = sibling(label_4, 2);
            MatureFilterSelector(node_22, {
              get group() {
                return get(mature_filter);
              },
              set group($$value) {
                set(mature_filter, $$value);
              },
              $$legacy: true
            });
            var p_9 = sibling(node_22, 2);
            var text_24 = child(p_9, true);
            reset(p_9);
            template_effect(
              ($0, $1, $2) => {
                set_text(text_22, $0);
                set_text(text_23, ` ${$1 ?? ""}`);
                set_text(text_24, $2);
              },
              [
                () => i18n("time-ratings"),
                () => i18n("as-ratio"),
                () => i18n("time-ratings-help")
              ],
              derived_safe_equal
            );
            bind_checked(input_4, () => get(normalize_ease), ($$value) => set(normalize_ease, $$value));
            append($$anchor3, fragment_15);
          },
          $$slots: { default: true }
        });
        append($$anchor2, fragment_12);
      },
      $$slots: { default: true }
    });
    var node_23 = sibling(node_14, 2);
    const expression_14 = derived_safe_equal(() => i18n("load-trend"));
    GraphCategory(node_23, {
      get hidden_title() {
        return get(expression_14);
      },
      config_name: "load",
      children: ($$anchor2, $$slotProps) => {
        var fragment_16 = root_162();
        var node_24 = first_child(fragment_16);
        GraphContainer(node_24, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_17 = root_172();
            var h1_8 = first_child(fragment_17);
            var text_25 = child(h1_8, true);
            reset(h1_8);
            var node_25 = sibling(h1_8, 2);
            const expression_15 = derived_safe_equal(() => i18n("load"));
            LineOrCandlestick(node_25, {
              get data() {
                return get(burden);
              },
              get label() {
                return get(expression_15);
              },
              up_colour: CANDLESTICK_RED,
              down_colour: CANDLESTICK_GREEN,
              get trend_data() {
                return get(burden_trend);
              },
              set trend_data($$value) {
                set(burden_trend, $$value);
              },
              $$legacy: true
            });
            var p_10 = sibling(node_25, 2);
            var text_26 = child(p_10, true);
            reset(p_10);
            var node_26 = sibling(p_10, 2);
            const expression_16 = derived_safe_equal(() => ({ pattern: i18n_pattern("burden-per-day") }));
            TrendValue(node_26, {
              get trend() {
                return get(burden_trend);
              },
              get n() {
                return $binSize();
              },
              get info() {
                return get(expression_16);
              }
            });
            var node_27 = sibling(node_26, 2);
            {
              var consequent_2 = ($$anchor4) => {
                Warning($$anchor4, {
                  children: ($$anchor5, $$slotProps3) => {
                    next();
                    var text_27 = text();
                    template_effect(($0) => set_text(text_27, $0), [() => i18n("generic-truncated-warning")], derived_safe_equal);
                    append($$anchor5, text_27);
                  },
                  $$slots: { default: true }
                });
              };
              if_block(node_27, ($$render) => {
                if (get(truncated)) $$render(consequent_2);
              });
            }
            template_effect(
              ($0, $1) => {
                set_text(text_25, $0);
                set_text(text_26, $1);
              },
              [
                () => i18n("load-trend"),
                () => i18n("load-trend-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_17);
          },
          $$slots: { default: true }
        });
        var node_28 = sibling(node_24, 2);
        GraphContainer(node_28, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_20 = root_20();
            var h1_9 = first_child(fragment_20);
            var text_28 = child(h1_9, true);
            reset(h1_9);
            var node_29 = sibling(h1_9, 2);
            const expression_17 = derived_safe_equal(() => ({
              countDescriptor: i18n("highest-repetition-count"),
              legend_left: i18n("repetition-count"),
              legend_right: i18n("card-count"),
              spectrumFrom: "#5ca7f7",
              spectrumTo: "#0b4f99"
            }));
            IntervalGraph(node_29, {
              get intervals() {
                return get(learn_repetitions);
              },
              get pieInfo() {
                return get(expression_17);
              }
            });
            var span_1 = sibling(node_29, 2);
            var text_29 = child(span_1);
            reset(span_1);
            var span_2 = sibling(span_1, 2);
            var text_30 = child(span_2);
            reset(span_2);
            var p_11 = sibling(span_2, 2);
            var text_31 = child(p_11, true);
            reset(p_11);
            template_effect(
              ($0, $1, $2, $3, $4, $5) => {
                set_text(text_28, $0);
                set_text(text_29, `${$1 ?? ""} = ${$2 ?? ""}`);
                set_text(text_30, `${$3 ?? ""} = ${$4 ?? ""}`);
                set_text(text_31, $5);
              },
              [
                () => i18n("learn-reviews-per-card"),
                () => i18n("mean"),
                () => mean(get(learn_steps_per_card))?.toFixed(2),
                () => i18n("median"),
                () => quantile(get(learn_steps_per_card), 0.5),
                () => i18n("learn-reviews-per-card-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_20);
          },
          $$slots: { default: true }
        });
        append($$anchor2, fragment_16);
      },
      $$slots: { default: true }
    });
    var node_30 = sibling(node_23, 2);
    GraphCategory(node_30, {
      hidden_title: "FSRS",
      config_name: "fsrs",
      children: ($$anchor2, $$slotProps) => {
        var fragment_21 = root_21();
        var node_31 = first_child(fragment_21);
        GraphContainer(node_31, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_22 = root_222();
            var h1_10 = first_child(fragment_22);
            var text_32 = child(h1_10, true);
            reset(h1_10);
            var node_32 = sibling(h1_10, 2);
            MemorisedBar(node_32, {});
            var node_33 = sibling(node_32, 2);
            {
              var consequent_3 = ($$anchor4) => {
                Warning($$anchor4, {
                  children: ($$anchor5, $$slotProps3) => {
                    next();
                    var text_33 = text();
                    template_effect(($0) => set_text(text_33, $0), [() => i18n("memorised-truncated-warning")], derived_safe_equal);
                    append($$anchor5, text_33);
                  },
                  $$slots: { default: true }
                });
              };
              if_block(node_33, ($$render) => {
                if (get(truncated)) $$render(consequent_3);
              });
            }
            var p_12 = sibling(node_33, 2);
            var text_34 = child(p_12, true);
            reset(p_12);
            template_effect(
              ($0, $1) => {
                set_text(text_32, $0);
                set_text(text_34, $1);
              },
              [
                () => i18n("memorised"),
                () => i18n("memorised-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_22);
          },
          $$slots: { default: true }
        });
        var node_34 = sibling(node_31, 2);
        GraphContainer(node_34, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_25 = root_252();
            var h1_11 = first_child(fragment_25);
            var text_35 = child(h1_11, true);
            reset(h1_11);
            var node_35 = sibling(h1_11, 2);
            {
              var consequent_5 = ($$anchor4) => {
                var fragment_26 = root_262();
                var node_36 = first_child(fragment_26);
                BarScrollable(node_36, {
                  get data() {
                    return get(stability_time_machine_bar);
                  },
                  left_aligned: true
                });
                var node_37 = sibling(node_36, 2);
                TimeMachineScroll(node_37, {
                  get min() {
                    return get(time_machine_min);
                  }
                });
                var p_13 = sibling(node_37, 2);
                var text_36 = child(p_13, true);
                reset(p_13);
                var node_38 = sibling(p_13, 2);
                {
                  var consequent_4 = ($$anchor5) => {
                    Warning($$anchor5, {
                      children: ($$anchor6, $$slotProps3) => {
                        next();
                        var text_37 = text();
                        template_effect(($0) => set_text(text_37, $0), [() => i18n("generic-truncated-warning")], derived_safe_equal);
                        append($$anchor6, text_37);
                      },
                      $$slots: { default: true }
                    });
                  };
                  if_block(node_38, ($$render) => {
                    if (get(truncated)) $$render(consequent_4);
                  });
                }
                template_effect(($0) => set_text(text_36, $0), [() => i18n("stability-time-machine-help")], derived_safe_equal);
                append($$anchor4, fragment_26);
              };
              var alternate = ($$anchor4) => {
                MemorisedCalculator($$anchor4, {});
              };
              if_block(node_35, ($$render) => {
                if ($memorised_stats()) $$render(consequent_5);
                else $$render(alternate, false);
              });
            }
            template_effect(($0) => set_text(text_35, $0), [() => i18n("stability-time-machine")], derived_safe_equal);
            append($$anchor3, fragment_25);
          },
          $$slots: { default: true }
        });
        var node_39 = sibling(node_34, 2);
        GraphContainer(node_39, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_30 = root_30();
            var h1_12 = first_child(fragment_30);
            var text_38 = child(h1_12, true);
            reset(h1_12);
            var node_40 = sibling(h1_12, 2);
            {
              var consequent_7 = ($$anchor4) => {
                var fragment_31 = root_31();
                var label_5 = first_child(fragment_31);
                var text_39 = child(label_5);
                var input_5 = sibling(text_39);
                remove_input_defaults(input_5);
                set_attribute(input_5, "min", 1);
                set_attribute(input_5, "max", 100);
                reset(label_5);
                var node_41 = sibling(label_5, 2);
                Bar(node_41, {
                  get data() {
                    return get(difficulty_time_machine_bar);
                  }
                });
                var label_6 = sibling(node_41, 2);
                var span_3 = child(label_6);
                var text_40 = child(span_3);
                reset(span_3);
                var node_42 = sibling(span_3, 2);
                TimeMachineScroll(node_42, {
                  get min() {
                    return get(time_machine_min);
                  }
                });
                reset(label_6);
                var p_14 = sibling(label_6, 2);
                var text_41 = child(p_14, true);
                reset(p_14);
                var node_43 = sibling(p_14, 2);
                {
                  var consequent_6 = ($$anchor5) => {
                    Warning($$anchor5, {
                      children: ($$anchor6, $$slotProps3) => {
                        next();
                        var text_42 = text();
                        template_effect(($0) => set_text(text_42, $0), [() => i18n("generic-truncated-warning")], derived_safe_equal);
                        append($$anchor6, text_42);
                      },
                      $$slots: { default: true }
                    });
                  };
                  if_block(node_43, ($$render) => {
                    if (get(truncated)) $$render(consequent_6);
                  });
                }
                template_effect(
                  ($0, $1, $2) => {
                    set_text(text_39, `${$0 ?? ""} `);
                    set_text(text_40, `${$1 ?? ""}:`);
                    set_text(text_41, $2);
                  },
                  [
                    () => i18n("zoom"),
                    () => new Date(Date.now() + $scroll() * day_ms2).toLocaleDateString(),
                    () => i18n("difficulty-time-machine-help")
                  ],
                  derived_safe_equal
                );
                bind_value(input_5, () => get(granularity), ($$value) => set(granularity, $$value));
                append($$anchor4, fragment_31);
              };
              var alternate_1 = ($$anchor4) => {
                MemorisedCalculator($$anchor4, {});
              };
              if_block(node_40, ($$render) => {
                if ($memorised_stats()) $$render(consequent_7);
                else $$render(alternate_1, false);
              });
            }
            template_effect(($0) => set_text(text_38, $0), [() => i18n("difficulty-time-machine")], derived_safe_equal);
            append($$anchor3, fragment_30);
          },
          $$slots: { default: true }
        });
        var node_44 = sibling(node_39, 2);
        GraphContainer(node_44, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_35 = root_352();
            var h1_13 = first_child(fragment_35);
            var text_43 = child(h1_13, true);
            reset(h1_13);
            var node_45 = sibling(h1_13, 2);
            {
              var consequent_8 = ($$anchor4) => {
                var fragment_36 = root_362();
                var node_46 = first_child(fragment_36);
                const expression_18 = derived_safe_equal(() => ({
                  row_colours: [YOUNG_COLOUR, MATURE_COLOUR],
                  row_labels: [i18n("young"), i18n("mature")],
                  data: (get(average_type) == safe_get(Average).MEAN ? $memorised_stats().day_means : $memorised_stats().day_medians).map((day, i) => {
                    const young_ratio = import_lodash17.default.sum($memorised_stats().stability_bins_days[i].slice(0, 21)) / import_lodash17.default.sum($memorised_stats().stability_bins_days[i]);
                    return {
                      values: [day * young_ratio, day * (1 - young_ratio)],
                      //* young_ratio, day * (1 - young_ratio)],
                      label: barLabel(i)
                    };
                  }),
                  columnLabeler: barDateLabeler
                }));
                const expression_19 = derived_safe_equal(() => ({ pattern: i18n_pattern("stability-per-day") }));
                BarScrollable(node_46, {
                  get data() {
                    return get(expression_18);
                  },
                  average: true,
                  trend: true,
                  get trend_info() {
                    return get(expression_19);
                  },
                  get binSize() {
                    return get(interval_bin_size);
                  },
                  set binSize($$value) {
                    set(interval_bin_size, $$value);
                  },
                  $$legacy: true
                });
                var p_15 = sibling(node_46, 2);
                var text_44 = child(p_15, true);
                reset(p_15);
                var div = sibling(p_15, 2);
                var label_7 = child(div);
                var input_6 = child(label_7);
                remove_input_defaults(input_6);
                var input_6_value;
                var text_45 = sibling(input_6);
                reset(label_7);
                var label_8 = sibling(label_7, 2);
                var input_7 = child(label_8);
                remove_input_defaults(input_7);
                var input_7_value;
                var text_46 = sibling(input_7);
                reset(label_8);
                reset(div);
                template_effect(
                  ($0, $1, $2) => {
                    set_text(text_44, $0);
                    if (input_6_value !== (input_6_value = safe_get(Average).MEDIAN)) {
                      input_6.value = null == (input_6.__value = safe_get(Average).MEDIAN) ? "" : safe_get(Average).MEDIAN;
                    }
                    set_text(text_45, ` ${$1 ?? ""}`);
                    if (input_7_value !== (input_7_value = safe_get(Average).MEAN)) {
                      input_7.value = null == (input_7.__value = safe_get(Average).MEAN) ? "" : safe_get(Average).MEAN;
                    }
                    set_text(text_46, ` ${$2 ?? ""}`);
                  },
                  [
                    () => i18n("average-stability-over-time-help"),
                    () => i18n("median"),
                    () => i18n("mean")
                  ],
                  derived_safe_equal
                );
                bind_group(
                  binding_group_1,
                  [],
                  input_6,
                  () => {
                    safe_get(Average).MEDIAN;
                    return get(average_type);
                  },
                  ($$value) => set(average_type, $$value)
                );
                bind_group(
                  binding_group_1,
                  [],
                  input_7,
                  () => {
                    safe_get(Average).MEAN;
                    return get(average_type);
                  },
                  ($$value) => set(average_type, $$value)
                );
                append($$anchor4, fragment_36);
              };
              var alternate_2 = ($$anchor4) => {
                MemorisedCalculator($$anchor4, {});
              };
              if_block(node_45, ($$render) => {
                if ($memorised_stats()) $$render(consequent_8);
                else $$render(alternate_2, false);
              });
            }
            template_effect(($0) => set_text(text_43, $0), [() => i18n("average-stability-over-time")], derived_safe_equal);
            append($$anchor3, fragment_35);
          },
          $$slots: { default: true }
        });
        append($$anchor2, fragment_21);
      },
      $$slots: { default: true }
    });
    var node_47 = sibling(node_30, 2);
    const expression_20 = derived_safe_equal(() => i18n("card-count-time-machine"));
    GraphCategory(node_47, {
      get hidden_title() {
        return get(expression_20);
      },
      config_name: "timeMachine",
      children: ($$anchor2, $$slotProps) => {
        var fragment_38 = root_382();
        var node_48 = first_child(fragment_38);
        GraphContainer(node_48, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_39 = root_39();
            var h1_14 = first_child(fragment_39);
            var text_47 = child(h1_14, true);
            reset(h1_14);
            var node_49 = sibling(h1_14, 2);
            const expression_21 = derived_safe_equal(() => i18n("card-type"));
            const expression_22 = derived_safe_equal(() => i18n("amount"));
            Pie(node_49, {
              get data() {
                return get(time_machine_pie);
              },
              get legend_left() {
                return get(expression_21);
              },
              get legend_right() {
                return get(expression_22);
              },
              percentage: true
            });
            var node_50 = sibling(node_49, 2);
            TimeMachineScroll(node_50, {
              get min() {
                return get(time_machine_min);
              }
            });
            var div_1 = sibling(node_50, 2);
            var text_48 = child(div_1);
            var label_9 = sibling(text_48, 3);
            var input_8 = child(label_9);
            remove_input_defaults(input_8);
            input_8.value = null == (input_8.__value = "Added") ? "" : "Added";
            var text_49 = sibling(input_8);
            reset(label_9);
            var label_10 = sibling(label_9, 2);
            var input_9 = child(label_10);
            remove_input_defaults(input_9);
            input_9.value = null == (input_9.__value = "Review") ? "" : "Review";
            var text_50 = sibling(input_9);
            reset(label_10);
            var label_11 = sibling(label_10, 2);
            var input_10 = child(label_11);
            remove_input_defaults(input_10);
            input_10.value = null == (input_10.__value = "Custom") ? "" : "Custom";
            var text_51 = sibling(input_10);
            reset(label_11);
            var node_51 = sibling(label_11, 2);
            {
              var consequent_9 = ($$anchor4) => {
                var input_11 = root_40();
                remove_input_defaults(input_11);
                bind_value(input_11, () => get(custom_leftmost), ($$value) => set(custom_leftmost, $$value));
                append($$anchor4, input_11);
              };
              if_block(node_51, ($$render) => {
                if (get(left_bound_at) == "Custom") $$render(consequent_9);
              });
            }
            reset(div_1);
            var span_4 = sibling(div_1, 2);
            var text_52 = child(span_4, true);
            reset(span_4);
            var p_16 = sibling(span_4, 2);
            var text_53 = child(p_16, true);
            reset(p_16);
            var node_52 = sibling(p_16, 2);
            {
              var consequent_10 = ($$anchor4) => {
                Warning($$anchor4, {
                  children: ($$anchor5, $$slotProps3) => {
                    next();
                    var text_54 = text();
                    template_effect(($0) => set_text(text_54, $0), [() => i18n("generic-truncated-warning")], derived_safe_equal);
                    append($$anchor5, text_54);
                  },
                  $$slots: { default: true }
                });
              };
              if_block(node_52, ($$render) => {
                if (get(truncated)) $$render(consequent_10);
              });
            }
            template_effect(
              ($0, $1, $2, $3, $4, $5, $6) => {
                set_text(text_47, $0);
                set_text(text_48, `${$1 ?? ""} `);
                set_text(text_49, ` ${$2 ?? ""}`);
                set_text(text_50, ` ${$3 ?? ""}`);
                set_text(text_51, ` ${$4 ?? ""}`);
                set_text(text_52, $5);
                set_text(text_53, $6);
              },
              [
                () => i18n("card-count-time-machine"),
                () => i18n("starts-at"),
                () => i18n("first-added"),
                () => i18n("first-review"),
                () => i18n("custom"),
                () => i18n("x-total-cards", { val: get(time_machine_added) }),
                () => i18n("card-count-time-machine-help")
              ],
              derived_safe_equal
            );
            bind_group(binding_group_2, [], input_8, () => get(left_bound_at), ($$value) => set(left_bound_at, $$value));
            bind_group(binding_group_2, [], input_9, () => get(left_bound_at), ($$value) => set(left_bound_at, $$value));
            bind_group(binding_group_2, [], input_10, () => get(left_bound_at), ($$value) => set(left_bound_at, $$value));
            event("click", input_10, () => {
              if (get(time_machine_min)) {
                set(custom_leftmost, get(time_machine_min));
              }
            });
            append($$anchor3, fragment_39);
          },
          $$slots: { default: true }
        });
        var node_53 = sibling(node_48, 2);
        GraphContainer(node_53, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_42 = root_432();
            var h1_15 = first_child(fragment_42);
            var text_55 = child(h1_15, true);
            reset(h1_15);
            var node_54 = sibling(h1_15, 2);
            BarScrollable(node_54, {
              get data() {
                return get(time_machine_bar);
              },
              left_aligned: true
            });
            var node_55 = sibling(node_54, 2);
            TimeMachineScroll(node_55, {
              get min() {
                return get(time_machine_min);
              }
            });
            var span_5 = sibling(node_55, 2);
            var text_56 = child(span_5, true);
            reset(span_5);
            var p_17 = sibling(span_5, 2);
            var text_57 = child(p_17, true);
            reset(p_17);
            var span_6 = sibling(p_17, 2);
            var text_58 = child(span_6);
            reset(span_6);
            var node_56 = sibling(span_6, 2);
            {
              var consequent_11 = ($$anchor4) => {
                Warning($$anchor4, {
                  children: ($$anchor5, $$slotProps3) => {
                    next();
                    var text_59 = text();
                    template_effect(($0) => set_text(text_59, $0), [() => i18n("generic-truncated-warning")], derived_safe_equal);
                    append($$anchor5, text_59);
                  },
                  $$slots: { default: true }
                });
              };
              if_block(node_56, ($$render) => {
                if (get(truncated)) $$render(consequent_11);
              });
            }
            template_effect(
              ($0, $1, $2, $3, $4) => {
                set_text(text_55, $0);
                set_text(text_56, $1);
                set_text(text_57, $2);
                set_text(text_58, `${$3 ?? ""} = ${$4 ?? ""}`);
              },
              [
                () => i18n("review-interval-time-machine"),
                () => i18n("x-total-cards", { val: get(total_intervals) }),
                () => i18n("review-interval-time-machine-help"),
                () => i18n("mean"),
                () => get(intervals_mean).toFixed(2)
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_42);
          },
          $$slots: { default: true }
        });
        var node_57 = sibling(node_53, 2);
        GraphContainer(node_57, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_45 = root_46();
            var h1_16 = first_child(fragment_45);
            var text_60 = child(h1_16, true);
            reset(h1_16);
            var div_2 = sibling(h1_16, 2);
            var label_12 = child(div_2);
            var text_61 = child(label_12);
            var input_12 = sibling(text_61);
            remove_input_defaults(input_12);
            set_attribute(input_12, "min", 1);
            reset(label_12);
            var input_13 = sibling(label_12, 2);
            remove_input_defaults(input_13);
            reset(div_2);
            var node_58 = sibling(div_2, 2);
            Bar(node_58, {
              get data() {
                return get(hours_time_machine);
              }
            });
            var label_13 = sibling(node_58, 2);
            var input_14 = child(label_13);
            remove_input_defaults(input_14);
            var text_62 = sibling(input_14);
            reset(label_13);
            var node_59 = sibling(label_13, 2);
            TimeMachineScroll(node_59, {
              get min() {
                return get(time_machine_min);
              }
            });
            var p_18 = sibling(node_59, 2);
            var text_63 = child(p_18, true);
            reset(p_18);
            template_effect(
              ($0, $1, $2, $3, $4) => {
                set_text(text_60, $0);
                set_text(text_61, `${$1 ?? ""} `);
                set_attribute(input_12, "max", 1 - (get(time_machine_min) ?? 0));
                set_value(input_13, $2);
                set_text(text_62, ` ${$3 ?? ""}`);
                set_text(text_63, $4);
              },
              [
                () => i18n("daily-hourly-breakdown"),
                () => i18n("days"),
                () => i18n("today"),
                () => i18n("include-filtered"),
                () => i18n("daily-hourly-breakdown-help")
              ],
              derived_safe_equal
            );
            bind_value(input_12, () => get(range6), ($$value) => set(range6, $$value));
            event("click", input_13, () => {
              store_set(scroll, 0);
              set(range6, 1);
            });
            bind_checked(input_14, () => get(filtered), ($$value) => set(filtered, $$value));
            append($$anchor3, fragment_45);
          },
          $$slots: { default: true }
        });
        append($$anchor2, fragment_38);
      },
      $$slots: { default: true }
    });
    var node_60 = sibling(node_47, 2);
    const expression_23 = derived_safe_equal(() => i18n("bad-graph"));
    GraphCategory(node_60, {
      get hidden_title() {
        return get(expression_23);
      },
      config_name: "bad",
      children: ($$anchor2, $$slotProps) => {
        var fragment_46 = root_47();
        var node_61 = first_child(fragment_46);
        GraphContainer(node_61, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_47 = root_48();
            var h1_17 = first_child(fragment_47);
            var text_64 = child(h1_17, true);
            reset(h1_17);
            var node_62 = sibling(h1_17, 2);
            {
              var consequent_12 = ($$anchor4) => {
                var fragment_48 = root_49();
                var label_14 = first_child(fragment_48);
                var text_65 = child(label_14);
                var input_15 = sibling(text_65);
                remove_input_defaults(input_15);
                set_attribute(input_15, "min", 1);
                set_attribute(input_15, "max", 6);
                reset(label_14);
                var node_63 = sibling(label_14, 2);
                Bar(node_63, {
                  get data() {
                    return get(leech_detection_bar);
                  }
                });
                var p_19 = sibling(node_63, 2);
                var text_66 = child(p_19);
                next();
                reset(p_19);
                template_effect(
                  ($0, $1) => {
                    set_text(text_65, `${$0 ?? ""} `);
                    set_text(text_66, `${$1 ?? ""} `);
                  },
                  [
                    () => i18n("zoom"),
                    () => i18n("leech-detector-help")
                  ],
                  derived_safe_equal
                );
                bind_value(input_15, () => get(granularity_power), ($$value) => set(granularity_power, $$value));
                append($$anchor4, fragment_48);
              };
              var alternate_3 = ($$anchor4) => {
                MemorisedCalculator($$anchor4, {});
              };
              if_block(node_62, ($$render) => {
                if ($memorised_stats()) $$render(consequent_12);
                else $$render(alternate_3, false);
              });
            }
            template_effect(($0) => set_text(text_64, $0), [() => i18n("leech-detector")], derived_safe_equal);
            append($$anchor3, fragment_47);
          },
          $$slots: { default: true }
        });
        var node_64 = sibling(node_61, 2);
        GraphContainer(node_64, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_50 = root_51();
            var h1_18 = first_child(fragment_50);
            var text_67 = child(h1_18, true);
            reset(h1_18);
            var node_65 = sibling(h1_18, 2);
            const expression_24 = derived_safe_equal(() => easeBarChart(get(sibling_time_ease), 1, get(normalize_ease), barStringLabeler(i18n_bundle.getMessage("days-since-sibling-review")?.value)));
            const expression_25 = derived_safe_equal(() => ({
              pattern: i18n_pattern("retention-per-day-since-last-sibling-review"),
              percentage: true
            }));
            BarScrollable(node_65, {
              get data() {
                return get(expression_24);
              },
              get average() {
                return get(normalize_ease);
              },
              left_aligned: true,
              get trend() {
                return get(normalize_ease);
              },
              trend_by: retention_trend,
              get trend_info() {
                return get(expression_25);
              },
              get binSize() {
                return get(interval_bin_size);
              },
              set binSize($$value) {
                set(interval_bin_size, $$value);
              },
              get offset() {
                return get(interval_scroll);
              },
              set offset($$value) {
                set(interval_scroll, $$value);
              },
              $$legacy: true
            });
            var label_15 = sibling(node_65, 2);
            var input_16 = child(label_15);
            remove_input_defaults(input_16);
            var text_68 = sibling(input_16);
            reset(label_15);
            var p_20 = sibling(label_15, 2);
            var text_69 = child(p_20, true);
            reset(p_20);
            template_effect(
              ($0, $1, $2) => {
                set_text(text_67, $0);
                set_text(text_68, ` ${$1 ?? ""}`);
                set_text(text_69, $2);
              },
              [
                () => i18n("naive-sibling-similarity"),
                () => i18n("as-ratio"),
                () => i18n("naive-sibling-similarity-help")
              ],
              derived_safe_equal
            );
            bind_checked(input_16, () => get(normalize_ease), ($$value) => set(normalize_ease, $$value));
            append($$anchor3, fragment_50);
          },
          $$slots: { default: true }
        });
        var node_66 = sibling(node_64, 2);
        GraphContainer(node_66, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_51 = root_522();
            var h1_19 = first_child(fragment_51);
            var text_70 = child(h1_19, true);
            reset(h1_19);
            var node_67 = sibling(h1_19, 2);
            const expression_26 = derived_safe_equal(() => easeBarChart(get(fatigue_ease)[get(mature_filter)], 0, get(normalize_ease), barStringLabeler(i18n_bundle.getMessage("x-previous-reviews")?.value)));
            const expression_27 = derived_safe_equal(() => ({
              pattern: i18n_pattern("retention-per-prior-review-that-day"),
              percentage: true
            }));
            BarScrollable(node_67, {
              get data() {
                return get(expression_26);
              },
              get average() {
                return get(normalize_ease);
              },
              left_aligned: true,
              get trend() {
                return get(normalize_ease);
              },
              trend_by: retention_trend,
              get trend_info() {
                return get(expression_27);
              },
              get binSize() {
                return get(fatigue_bin_size);
              },
              set binSize($$value) {
                set(fatigue_bin_size, $$value);
              },
              $$legacy: true
            });
            var label_16 = sibling(node_67, 2);
            var input_17 = child(label_16);
            remove_input_defaults(input_17);
            var text_71 = sibling(input_17);
            reset(label_16);
            var node_68 = sibling(label_16, 2);
            MatureFilterSelector(node_68, {
              get group() {
                return get(mature_filter);
              },
              set group($$value) {
                set(mature_filter, $$value);
              },
              $$legacy: true
            });
            var p_21 = sibling(node_68, 2);
            var text_72 = child(p_21, true);
            reset(p_21);
            template_effect(
              ($0, $1, $2) => {
                set_text(text_70, $0);
                set_text(text_71, ` ${$1 ?? ""}`);
                set_text(text_72, $2);
              },
              [
                () => i18n("rating-fatigue"),
                () => i18n("as-ratio"),
                () => i18n("rating-fatigue-help")
              ],
              derived_safe_equal
            );
            bind_checked(input_17, () => get(normalize_ease), ($$value) => set(normalize_ease, $$value));
            append($$anchor3, fragment_51);
          },
          $$slots: { default: true }
        });
        var node_69 = sibling(node_66, 2);
        GraphContainer(node_69, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_52 = root_53();
            var h1_20 = first_child(fragment_52);
            var text_73 = child(h1_20, true);
            reset(h1_20);
            var node_70 = sibling(h1_20, 2);
            {
              var consequent_13 = ($$anchor4) => {
                var fragment_53 = root_54();
                var node_71 = first_child(fragment_53);
                const expression_28 = derived_safe_equal(() => ({
                  row_colours: ["red"],
                  row_labels: ["RMSE"],
                  data: $memorised_stats().fatigueRMSE[get(mature_filter)].map((v3, i) => ({ label: i.toString(), values: v3 }))
                }));
                const expression_29 = derived_safe_equal(() => ({
                  pattern: i18n_pattern("loss-per-prior-review-that-day")
                }));
                BarScrollable(node_71, {
                  get data() {
                    return get(expression_28);
                  },
                  left_aligned: true,
                  average: true,
                  loss: true,
                  trend: true,
                  get trend_info() {
                    return get(expression_29);
                  },
                  get binSize() {
                    return get(fatigue_bin_size);
                  },
                  set binSize($$value) {
                    set(fatigue_bin_size, $$value);
                  },
                  $$legacy: true
                });
                var node_72 = sibling(node_71, 2);
                MatureFilterSelector(node_72, {
                  get group() {
                    return get(mature_filter);
                  },
                  set group($$value) {
                    set(mature_filter, $$value);
                  },
                  $$legacy: true
                });
                append($$anchor4, fragment_53);
              };
              var alternate_4 = ($$anchor4) => {
                MemorisedCalculator($$anchor4, {});
              };
              if_block(node_70, ($$render) => {
                if ($memorised_stats()) $$render(consequent_13);
                else $$render(alternate_4, false);
              });
            }
            var p_22 = sibling(node_70, 2);
            var text_74 = child(p_22, true);
            reset(p_22);
            template_effect(
              ($0, $1) => {
                set_text(text_73, $0);
                set_text(text_74, $1);
              },
              [
                () => i18n("fsrs-loss-by-fatigue"),
                () => i18n("fsrs-loss-by-fatigue-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_52);
          },
          $$slots: { default: true }
        });
        append($$anchor2, fragment_46);
      },
      $$slots: { default: true }
    });
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/dayTimings.ts
  function countOrTimeSum(countOrTime) {
    return countOrTime.filtered + countOrTime.learn + countOrTime.mature + countOrTime.relearn + countOrTime.young;
  }
  function calcTimePerReview(data2) {
    let days = [];
    for (const i in data2.count) {
      days[+i + today] = countOrTimeSum(data2.time[i]) / (countOrTimeSum(data2.count[i]) * 1e3);
    }
    return days;
  }

  // src/ts/DayTimings.svelte
  function DayTimings($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $searchLimit = () => store_get(searchLimit, "$searchLimit", $$stores);
    const time_spent = mutable_state();
    const bar = mutable_state();
    const limit = mutable_state();
    let data2 = prop($$props, "data", 8);
    let offset = mutable_state(0);
    legacy_pre_effect(
      () => (deep_read_state(data2()), calcTimePerReview),
      () => {
        set(time_spent, data2() ? calcTimePerReview(data2()) : []);
      }
    );
    legacy_pre_effect(
      () => (i18n, get(time_spent), today, barDateLabeler),
      () => {
        set(bar, {
          row_colours: ["#fcba03"],
          row_labels: [i18n("seconds-per-review")],
          data: Array.from(get(time_spent)).map((data3, i) => ({
            label: (i - today).toString(),
            values: [data3]
          })),
          tick_spacing: 5,
          columnLabeler: barDateLabeler
        });
      }
    );
    legacy_pre_effect(() => $searchLimit(), () => {
      set(limit, -1 - $searchLimit());
    });
    legacy_pre_effect_reset();
    init();
    const expression = derived_safe_equal(() => ({
      pattern: i18n_pattern("average-second-per-day")
    }));
    BarScrollable($$anchor, {
      get data() {
        return get(bar);
      },
      average: true,
      get limit() {
        return get(limit);
      },
      trend: true,
      get trend_info() {
        return get(expression);
      },
      get offset() {
        return get(offset);
      },
      set offset($$value) {
        set(offset, $$value);
      },
      $$legacy: true
    });
    pop();
    $$cleanup();
  }

  // src/ts/heatmap.ts
  function create_scale(dim, range6) {
    if (dim.is_logarithmic) {
      return log2([max([dim.start_value, Number.EPSILON]), dim.end_value], range6);
    } else {
      return linear3([dim.start_value, dim.end_value], range6);
    }
  }

  // src/ts/utils.svelte.ts
  var ConstrainedIntState = class {
    #min = 0;
    #max = 0;
    #value = state(0);
    /**
     * Creates a new instance of the ConstrainedIntState class.
     *
     * @param min - The minimum value for the state, inclusive. Must be less than max.
     * @param max - The maximum value for the state, inclusive. Must be greater than min.
     * @param defaultValue - The initial value for the state. Will be clamped between min and max.
     */
    constructor(min4, max5, defaultValue) {
      if (min4 > max5) {
        throw new Error("min must be less than max");
      }
      this.#min = Math.ceil(min4);
      this.#max = Math.floor(max5);
      this.value = defaultValue;
    }
    get value() {
      return get(this.#value);
    }
    set value(value) {
      set(this.#value, proxy(Math.max(this.#min, Math.min(this.#max, Math.floor(value)))));
    }
  };
  function* range5(start2, end) {
    for (let i = start2; i < end; i++) {
      yield i;
    }
  }

  // src/ts/Heatmap.svelte
  function on_click(_25, $$props, hover_data) {
    if ($$props.onSelect !== void 0 && get(hover_data) !== null) {
      $$props.onSelect(get(hover_data));
    }
  }
  var root_111 = ns_template(`<text text-anchor="middle" fill="currentColor"> </text>`);
  var root_28 = ns_template(`<text text-anchor="middle" fill="currentColor"> </text>`);
  var root_55 = ns_template(`<g role="cell"><rect class="bin svelte-f00ajz" role="button" tabindex="0"></rect></g>`);
  var root_310 = ns_template(`<g role="row"></g>`);
  var root_62 = ns_template(`<rect class="bin-highlight svelte-f00ajz" fill="none"></rect>`);
  var root19 = ns_template(`<svg preserveAspectRatio="meet"><g font-family="sans-serif"><g><g></g><!></g><g><g></g><!></g></g><g role="grid" stroke="transparent" stroke-width="1px"></g><g stroke="currentColor" stroke-width="4px"><!></g></svg>`);
  function Heatmap($$anchor, $$props) {
    push($$props, true);
    const [$$stores, $$cleanup] = setup_stores();
    const $tooltip = () => store_get(tooltip, "$tooltip", $$stores);
    const $tooltipShown = () => store_get(tooltipShown, "$tooltipShown", $$stores);
    const DEFAULT_TOOLTIP_FORMAT = new Intl.NumberFormat(navigator.language, { maximumFractionDigits: 2 });
    const AXIS_OPACITY = 0.5;
    const MARGIN_TOP = 20;
    const MARGIN_RIGHT = 20;
    const MARGIN_BOTTOM = 50;
    const MARGIN_LEFT = 50;
    const canvasWidth = prop($$props, "canvasWidth", 3, 640), canvasHeight = prop($$props, "canvasHeight", 3, 640), xTooltipFormat = prop($$props, "xTooltipFormat", 3, DEFAULT_TOOLTIP_FORMAT), yTooltipFormat = prop($$props, "yTooltipFormat", 3, DEFAULT_TOOLTIP_FORMAT), valueTooltipFormat = prop($$props, "valueTooltipFormat", 3, DEFAULT_TOOLTIP_FORMAT);
    let gx = state(void 0);
    let gy = state(void 0);
    const trueHeight = derived(() => canvasHeight() + MARGIN_TOP + MARGIN_BOTTOM);
    const x_scale = derived(() => create_scale($$props.data.x_dim, [MARGIN_LEFT, canvasWidth() - MARGIN_RIGHT]));
    const y_scale = derived(() => create_scale($$props.data.y_dim, [
      get(trueHeight) - MARGIN_BOTTOM,
      MARGIN_TOP
    ]));
    const color2 = derived(() => {
      const non_null_data = $$props.data.raw_data.filter((x5) => x5 !== void 0);
      let min4 = Math.min(...non_null_data);
      let max5 = Math.max(...non_null_data);
      if (min4 === Infinity) {
        min4 = Number.MIN_VALUE;
      }
      if (max5 === -Infinity) {
        max5 = Number.MAX_VALUE;
      }
      return linear3(
        [
          Math.min(...non_null_data),
          Math.max(...non_null_data)
        ],
        ["cornflowerblue", "red"]
      );
    });
    user_effect(() => {
      let xAxisGenerator = axisBottom(get(x_scale));
      let yAxisGenerator = axisLeft(get(y_scale));
      if ($$props.xAxisTickFormat) {
        xAxisGenerator = xAxisGenerator.tickFormat(format($$props.xAxisTickFormat));
      }
      if ($$props.yAxisTickFormat) {
        yAxisGenerator = yAxisGenerator.tickFormat(format($$props.yAxisTickFormat));
      }
      if (get(gx) && get(gy)) {
        select_default2(get(gx)).call(xAxisGenerator);
        select_default2(get(gy)).call(yAxisGenerator);
      }
    });
    const CELL_MARGIN = 0.5;
    function get_dim_pos(dim, idx) {
      const normal_pos = idx / dim.bin_count;
      if (dim.is_logarithmic) {
        const log_start = Math.log10(dim.start_value);
        const log_end = Math.log10(dim.end_value);
        const scale_factor = log_end - log_start;
        const relative_pos = normal_pos * scale_factor;
        const absolute_pos = log_start + relative_pos;
        return Math.pow(10, absolute_pos);
      } else {
        const scale_factor = dim.end_value - dim.start_value;
        const relative_pos = normal_pos * scale_factor;
        return dim.start_value + relative_pos;
      }
    }
    function cell_x_pos(x_idx) {
      return get(x_scale)(get_dim_pos($$props.data.x_dim, x_idx)) - CELL_MARGIN;
    }
    function cell_y_pos(y_idx) {
      return get(y_scale)(get_dim_pos($$props.data.y_dim, y_idx + 1)) - CELL_MARGIN;
    }
    function cell_width(x_idx) {
      return cell_x_pos(x_idx + 1) - cell_x_pos(x_idx) - CELL_MARGIN;
    }
    function cell_height(y_idx) {
      return cell_y_pos(y_idx) - cell_y_pos(y_idx + 1) - CELL_MARGIN;
    }
    let hover_data = state(null);
    function on_focus(x_idx, y_idx) {
      return (e) => {
        const value = $$props.data.raw_data[x_idx + y_idx * $$props.data.x_dim.bin_count];
        if (value != void 0) {
          const x_from = get_dim_pos($$props.data.x_dim, x_idx);
          const x_to = get_dim_pos($$props.data.x_dim, x_idx + 1);
          const y_from = get_dim_pos($$props.data.y_dim, y_idx);
          const y_to = get_dim_pos($$props.data.y_dim, y_idx + 1);
          set(hover_data, proxy({
            x_idx,
            y_idx,
            x_from,
            x_to,
            y_from,
            y_to,
            value
          }));
          const target_rect = e.target.getBoundingClientRect();
          store_set(tooltip, {
            x: window.scrollX + target_rect.x,
            y: window.scrollY + target_rect.y + target_rect.height + 16,
            text: [
              // N.B. en dashes not hyphens
              `${$$props.yTooltipLabel}: ${yTooltipFormat().format(y_from)} \u2013 ${yTooltipFormat().format(y_to)}`,
              `${$$props.xTooltipLabel}: ${xTooltipFormat().format(x_from)} \u2013 ${xTooltipFormat().format(x_to)}`,
              `${$$props.valueTooltipLabel}: ${valueTooltipFormat().format(value)}`
            ]
          });
          store_set(tooltipShown, true);
        }
      };
    }
    function on_blur() {
      store_set(tooltipShown, false);
      set(hover_data, null);
    }
    var svg2 = root19();
    var g = child(svg2);
    var g_1 = child(g);
    var g_2 = child(g_1);
    set_attribute(g_2, "opacity", AXIS_OPACITY);
    bind_this(g_2, ($$value) => set(gx, $$value), () => get(gx));
    var node = sibling(g_2);
    {
      var consequent = ($$anchor2) => {
        var text2 = root_111();
        var text_1 = child(text2, true);
        reset(text2);
        template_effect(() => {
          set_attribute(text2, "transform", `translate(${MARGIN_LEFT + (canvasWidth() - (MARGIN_LEFT + MARGIN_RIGHT)) / 2},${get(trueHeight) - 12})`);
          set_text(text_1, $$props.xAxisLabel);
        });
        append($$anchor2, text2);
      };
      if_block(node, ($$render) => {
        if ($$props.xAxisLabel) $$render(consequent);
      });
    }
    reset(g_1);
    var g_3 = sibling(g_1);
    var g_4 = child(g_3);
    set_attribute(g_4, "transform", `translate(${MARGIN_LEFT ?? ""},0)`);
    set_attribute(g_4, "opacity", AXIS_OPACITY);
    bind_this(g_4, ($$value) => set(gy, $$value), () => get(gy));
    var node_1 = sibling(g_4);
    {
      var consequent_1 = ($$anchor2) => {
        var text_2 = root_28();
        var text_3 = child(text_2, true);
        reset(text_2);
        template_effect(() => {
          set_attribute(text_2, "transform", `translate(12, ${MARGIN_TOP + (get(trueHeight) - (MARGIN_TOP + MARGIN_BOTTOM)) / 2}) rotate(-90)`);
          set_text(text_3, $$props.yAxisLabel);
        });
        append($$anchor2, text_2);
      };
      if_block(node_1, ($$render) => {
        if ($$props.yAxisLabel) $$render(consequent_1);
      });
    }
    reset(g_3);
    reset(g);
    var g_5 = sibling(g);
    each(g_5, 20, () => range5(0, $$props.data.y_dim.bin_count), (y_idx) => y_idx, ($$anchor2, y_idx) => {
      var g_6 = root_310();
      each(g_6, 20, () => range5(0, $$props.data.x_dim.bin_count), (x_idx) => x_idx, ($$anchor3, x_idx) => {
        var fragment = comment();
        const value = derived(() => $$props.data.raw_data[x_idx + y_idx * $$props.data.x_dim.bin_count]);
        var node_2 = first_child(fragment);
        {
          var consequent_2 = ($$anchor4) => {
            var g_7 = root_55();
            var rect = child(g_7);
            var event_handler = derived(() => on_focus(x_idx, y_idx));
            var event_handler_1 = derived(() => on_focus(x_idx, y_idx));
            rect.__click = [on_click, $$props, hover_data];
            reset(g_7);
            template_effect(
              ($0, $1, $2, $3, $4) => {
                set_attribute(g_7, "aria-rowindex", y_idx);
                set_attribute(g_7, "aria-colindex", x_idx);
                set_attribute(rect, "x", $0);
                set_attribute(rect, "y", $1);
                set_attribute(rect, "width", $2);
                set_attribute(rect, "height", $3);
                set_attribute(rect, "fill", $4);
                set_attribute(rect, "aria-label", `value: ${get(value) ?? ""}`);
              },
              [
                () => cell_x_pos(x_idx),
                () => cell_y_pos(y_idx),
                () => cell_width(x_idx),
                () => cell_height(y_idx),
                () => get(color2)(get(value))
              ]
            );
            event("focus", rect, function(...$$args) {
              get(event_handler)?.apply(this, $$args);
            });
            event("blur", rect, on_blur);
            event("mouseenter", rect, function(...$$args) {
              get(event_handler_1)?.apply(this, $$args);
            });
            event("mouseleave", rect, on_blur);
            append($$anchor4, g_7);
          };
          if_block(node_2, ($$render) => {
            if (get(value) !== void 0) $$render(consequent_2);
          });
        }
        append($$anchor3, fragment);
      });
      reset(g_6);
      append($$anchor2, g_6);
    });
    reset(g_5);
    var g_8 = sibling(g_5);
    var node_3 = child(g_8);
    {
      var consequent_3 = ($$anchor2) => {
        var rect_1 = root_62();
        template_effect(
          ($0, $1, $2, $3) => {
            set_attribute(rect_1, "x", $0);
            set_attribute(rect_1, "y", $1);
            set_attribute(rect_1, "width", $2);
            set_attribute(rect_1, "height", $3);
          },
          [
            () => cell_x_pos(get(hover_data).x_idx),
            () => cell_y_pos(get(hover_data).y_idx),
            () => cell_width(get(hover_data).x_idx),
            () => cell_height(get(hover_data).y_idx)
          ]
        );
        append($$anchor2, rect_1);
      };
      if_block(node_3, ($$render) => {
        if (get(hover_data) !== null) $$render(consequent_3);
      });
    }
    reset(g_8);
    reset(svg2);
    template_effect(() => {
      set_attribute(svg2, "viewBox", `0, 0, ${canvasWidth() ?? ""}, ${get(trueHeight) ?? ""}`);
      set_attribute(g_2, "transform", `translate(0,${get(trueHeight) - MARGIN_BOTTOM})`);
    });
    append($$anchor, svg2);
    pop();
    $$cleanup();
  }
  delegate(["click"]);

  // src/ts/srHeatmap.ts
  function create_card_sr_dataset(card_data2, collection_today_timestamp) {
    if (card_data2 === null) {
      return null;
    }
    let dataset = null;
    for (const card_data_entry of card_data2) {
      if (card_data_entry.type !== 2 /* Review */) {
        continue;
      }
      const extra_data = JSON.parse(card_data_entry.data);
      if (extra_data.s === void 0) {
        continue;
      }
      const last_review_timestamp = card_data_entry.due - card_data_entry.ivl;
      const elapsed_days = collection_today_timestamp - last_review_timestamp;
      const s2 = extra_data.s;
      const r = R(getDecay(extra_data), elapsed_days, s2);
      const card_sr_data = {
        s: s2,
        r
      };
      if (dataset === null) {
        dataset = {
          min_r: r,
          max_r: r,
          min_s: s2,
          max_s: s2,
          card_sr_data: [card_sr_data]
        };
      } else {
        dataset.min_r = Math.min(dataset.min_r, r);
        dataset.max_r = Math.max(dataset.max_r, r);
        dataset.min_s = Math.min(dataset.min_s, s2);
        dataset.max_s = Math.max(dataset.max_s, s2);
        dataset.card_sr_data.push(card_sr_data);
      }
    }
    return dataset;
  }
  function create_dimension(min4, max5, bin_width, is_logarithmic) {
    let raw_min = min4;
    let raw_max = max5;
    if (is_logarithmic) {
      raw_min = Math.log10(min4);
      raw_max = Math.log10(max5);
    }
    let nice_min = Math.floor(raw_min / bin_width) * bin_width;
    let nice_max = Math.ceil(raw_max / bin_width) * bin_width;
    const bin_count = Math.round((nice_max - nice_min) / bin_width);
    if (is_logarithmic) {
      nice_min = Math.pow(10, nice_min);
      nice_max = Math.pow(10, nice_max);
    }
    return {
      start_value: nice_min,
      end_value: nice_max,
      bin_count,
      is_logarithmic
    };
  }
  function calculate_sr_heatmap_data(dataset, r_bin_width, s_bin_width, s_is_logarithmic) {
    if (dataset === null) {
      return null;
    }
    const r_dim = create_dimension(dataset.min_r, dataset.max_r, r_bin_width, false);
    const s_dim = create_dimension(dataset.min_s, dataset.max_s, s_bin_width, s_is_logarithmic);
    const total_bins = r_dim.bin_count * s_dim.bin_count;
    const raw_data = new Array(total_bins);
    for (const card of dataset.card_sr_data) {
      const raw_r_idx = (card.r - r_dim.start_value) / r_bin_width;
      let raw_s_idx;
      if (s_is_logarithmic) {
        raw_s_idx = (Math.log10(card.s) - Math.log10(s_dim.start_value)) / s_bin_width;
      } else {
        raw_s_idx = (card.s - s_dim.start_value) / s_bin_width;
      }
      const clean_r_idx = Math.min(r_dim.bin_count - 1, Math.max(0, Math.floor(raw_r_idx)));
      const clean_s_idx = Math.min(s_dim.bin_count - 1, Math.max(0, Math.floor(raw_s_idx)));
      const raw_data_idx = clean_r_idx + clean_s_idx * r_dim.bin_count;
      if (raw_data[raw_data_idx] === void 0) {
        raw_data[raw_data_idx] = 1;
      } else {
        raw_data[raw_data_idx] += 1;
      }
    }
    return {
      x_dim: r_dim,
      y_dim: s_dim,
      raw_data
    };
  }

  // src/ts/SRHeatmap.svelte
  var root_29 = template(`<option> </option>`);
  var root_44 = template(`<option> </option>`);
  var root_311 = template(`<select></select>`);
  var root_56 = template(`<input type="number" step="1" class="svelte-159ax3b">`);
  var root_112 = template(`<div class="options svelte-159ax3b"><label class="svelte-159ax3b"> <div><input type="checkbox" class="svelte-159ax3b"></div></label> <label class="svelte-159ax3b"> <div><input type="checkbox" class="svelte-159ax3b"></div></label> <label class="svelte-159ax3b"> <select></select></label> <label class="svelte-159ax3b"> <!></label></div> <!>`, 1);
  function SRHeatmap($$anchor, $$props) {
    push($$props, true);
    const [$$stores, $$cleanup] = setup_stores();
    const $other = () => store_get(other, "$other", $$stores);
    const R_FORMAT = new Intl.NumberFormat(navigator.language, { style: "percent", maximumFractionDigits: 1 });
    const S_FORMAT = new Intl.NumberFormat(navigator.language, { maximumFractionDigits: 1 });
    const S_BIN_LOG_FORMAT = new Intl.NumberFormat(navigator.language, { maximumFractionDigits: 2 });
    const R_BIN_WIDTHS = [
      1e-3,
      2e-3,
      5e-3,
      0.01,
      0.02,
      0.05,
      0.1
    ];
    const DEFAULT_R_BIN_WIDTH = 0.05;
    const S_BIN_WIDTHS_LOG = [0.02, 0.05, 0.1, 0.2, 0.5, 1, 2];
    const DEFAULT_S_BIN_WIDTH_LOG = 0.1;
    let enlarged = state(false);
    const { width: width2, height: default_height } = defaultGraphBounds();
    let height2 = derived(() => get(enlarged) ? default_height * 2 : default_height);
    let s_is_logarithmic = state(false);
    let r_bin_width = state(DEFAULT_R_BIN_WIDTH);
    let s_bin_width_linear = new ConstrainedIntState(1, 3650, 7);
    let s_bin_width_log = state(DEFAULT_S_BIN_WIDTH_LOG);
    const sr_dataset = derived(() => create_card_sr_dataset($$props.cardData, $other().days_elapsed));
    user_effect(() => {
      if (get(sr_dataset) !== null) {
        s_bin_width_linear.value = (get(sr_dataset).max_s - get(sr_dataset).min_r) / 20;
      }
    });
    const heatmap_data = derived(() => calculate_sr_heatmap_data(get(sr_dataset), get(r_bin_width), get(s_is_logarithmic) ? get(s_bin_width_log) : s_bin_width_linear.value, get(s_is_logarithmic)));
    function open_browser_search(selection2) {
      if ($$props.searchString !== void 0 && $$props.searchString !== null) {
        browserSearch(`(${$$props.searchString}) prop:r>=${selection2.x_from} prop:r<=${selection2.x_to} prop:s>=${selection2.y_from} prop:s<=${selection2.y_to}`);
      }
    }
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent_1 = ($$anchor2) => {
        var fragment_1 = root_112();
        var div = first_child(fragment_1);
        var label = child(div);
        var text2 = child(label);
        var div_1 = sibling(text2);
        var input = child(div_1);
        remove_input_defaults(input);
        reset(div_1);
        reset(label);
        var label_1 = sibling(label, 2);
        var text_1 = child(label_1);
        var div_2 = sibling(text_1);
        var input_1 = child(div_2);
        remove_input_defaults(input_1);
        reset(div_2);
        reset(label_1);
        var label_2 = sibling(label_1, 2);
        var text_2 = child(label_2);
        var select = sibling(text_2);
        each(select, 21, () => R_BIN_WIDTHS, index, ($$anchor3, bin_width) => {
          var option = root_29();
          var option_value = {};
          var text_3 = child(option, true);
          reset(option);
          template_effect(
            ($0) => {
              if (option_value !== (option_value = get(bin_width))) {
                option.value = null == (option.__value = get(bin_width)) ? "" : get(bin_width);
              }
              set_text(text_3, $0);
            },
            [
              () => R_FORMAT.format(get(bin_width))
            ]
          );
          append($$anchor3, option);
        });
        reset(select);
        reset(label_2);
        var label_3 = sibling(label_2, 2);
        var text_4 = child(label_3);
        var node_1 = sibling(text_4);
        {
          var consequent = ($$anchor3) => {
            var select_1 = root_311();
            each(select_1, 21, () => S_BIN_WIDTHS_LOG, index, ($$anchor4, bin_width) => {
              var option_1 = root_44();
              var option_1_value = {};
              var text_5 = child(option_1, true);
              reset(option_1);
              template_effect(
                ($0) => {
                  if (option_1_value !== (option_1_value = get(bin_width))) {
                    option_1.value = null == (option_1.__value = get(bin_width)) ? "" : get(bin_width);
                  }
                  set_text(text_5, $0);
                },
                [
                  () => S_BIN_LOG_FORMAT.format(get(bin_width))
                ]
              );
              append($$anchor4, option_1);
            });
            reset(select_1);
            bind_select_value(select_1, () => get(s_bin_width_log), ($$value) => set(s_bin_width_log, $$value));
            append($$anchor3, select_1);
          };
          var alternate = ($$anchor3) => {
            var input_2 = root_56();
            remove_input_defaults(input_2);
            set_attribute(input_2, "min", 1);
            set_attribute(input_2, "max", 3650);
            bind_value(input_2, () => s_bin_width_linear.value, ($$value) => s_bin_width_linear.value = $$value);
            append($$anchor3, input_2);
          };
          if_block(node_1, ($$render) => {
            if (get(s_is_logarithmic)) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        reset(label_3);
        reset(div);
        var node_2 = sibling(div, 2);
        const expression = derived(() => i18n("retrievability"));
        const expression_1 = derived(() => i18n("stability"));
        const expression_2 = derived(() => i18n("retrievability-short"));
        const expression_3 = derived(() => i18n("stability-short"));
        const expression_4 = derived(() => i18n("cards"));
        Heatmap(node_2, {
          canvasWidth: width2,
          get canvasHeight() {
            return get(height2);
          },
          get xAxisLabel() {
            return get(expression);
          },
          xAxisTickFormat: ".0%",
          get yAxisLabel() {
            return get(expression_1);
          },
          get xTooltipLabel() {
            return get(expression_2);
          },
          get yTooltipLabel() {
            return get(expression_3);
          },
          get valueTooltipLabel() {
            return get(expression_4);
          },
          xTooltipFormat: R_FORMAT,
          yTooltipFormat: S_FORMAT,
          onSelect: open_browser_search,
          get data() {
            return get(heatmap_data);
          }
        });
        template_effect(
          ($0, $1, $2, $3) => {
            set_text(text2, `${$0 ?? ""} `);
            set_text(text_1, `${$1 ?? ""} `);
            set_text(text_2, `${$2 ?? ""}: `);
            set_text(text_4, `${$3 ?? ""}: `);
          },
          [
            () => i18n("enlarged"),
            () => i18n("logarithmic-s"),
            () => i18n("r-bin-size"),
            () => i18n("s-bin-size")
          ]
        );
        bind_checked(input, () => get(enlarged), ($$value) => set(enlarged, $$value));
        bind_checked(input_1, () => get(s_is_logarithmic), ($$value) => set(s_is_logarithmic, $$value));
        bind_select_value(select, () => get(r_bin_width), ($$value) => set(r_bin_width, $$value));
        append($$anchor2, fragment_1);
      };
      var alternate_1 = ($$anchor2) => {
        NoGraph($$anchor2, {});
      };
      if_block(node, ($$render) => {
        if (get(heatmap_data) !== null) $$render(consequent_1);
        else $$render(alternate_1, false);
      });
    }
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/Root.svelte
  var root_210 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_83 = template(` <small> </small>`, 1);
  var root_57 = template(`<h1> </h1> <!> <label><input type="checkbox"> </label> <p> </p>`, 1);
  var root_92 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_113 = template(`<!> <!> <!>`, 1);
  var root_114 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_153 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_163 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_173 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_102 = template(`<!> <!> <!> <!>`, 1);
  var root_192 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_202 = template(`<h1> </h1> <!> <p> </p>`, 1);
  var root_182 = template(`<!> <!>`, 1);
  var root_232 = template(`<h1 class="header svelte-1gkabcm"> </h1>`);
  var root_272 = template(`<h1> </h1> `, 1);
  var root_263 = template(`<div class="loadOption svelte-1gkabcm"><!> <button class="svelte-1gkabcm"> </button> <span> </span></div>`);
  var root_253 = template(`<div><!></div>`);
  var root_282 = template(`<span> </span> <br>`, 1);
  var root20 = template(`<div><hr> <h1 class="header svelte-1gkabcm"> </h1> <!> <!> <!> <!> <!></div> <div class="tooltip svelte-1gkabcm"></div>`, 1);
  function Root($$anchor, $$props) {
    push($$props, false);
    const [$$stores, $$cleanup] = setup_stores();
    const $include_suspended = () => store_get(include_suspended, "$include_suspended", $$stores);
    const $data = () => store_get(data, "$data", $$stores);
    const $not_suspended_data = () => store_get(not_suspended_data, "$not_suspended_data", $$stores);
    const $target_R_days = () => store_get(target_R_days, "$target_R_days", $$stores);
    const $learn_data = () => store_get(learn_data, "$learn_data", $$stores);
    const $mature_data = () => store_get(mature_data, "$mature_data", $$stores);
    const $relearn_data = () => store_get(relearn_data, "$relearn_data", $$stores);
    const $card_data = () => store_get(card_data, "$card_data", $$stores);
    const $searchString = () => store_get(searchString, "$searchString", $$stores);
    const $showRevlogStats = () => store_get(showRevlogStats, "$showRevlogStats", $$stores);
    const $revlogs = () => store_get(revlogs, "$revlogs", $$stores);
    const $tooltipShown = () => store_get(tooltipShown, "$tooltipShown", $$stores);
    const $tooltip = () => store_get(tooltip, "$tooltip", $$stores);
    const intervals = mutable_state();
    const target_R_day_values = mutable_state();
    const target_R_days_bar = mutable_state();
    const { width: width2, height: height2 } = defaultGraphBounds();
    let interval_last = mutable_state(21);
    let interval_steps = mutable_state(7);
    let normalize3 = mutable_state(true);
    legacy_pre_effect(
      () => ($include_suspended(), $data(), $not_suspended_data()),
      () => {
        set(intervals, ($include_suspended() ? $data() === null || $data() === void 0 ? void 0 : $data().intervals.intervals : $not_suspended_data() === null || $not_suspended_data() === void 0 ? void 0 : $not_suspended_data().intervals.intervals) || {});
      }
    );
    legacy_pre_effect(
      () => ($target_R_days(), $data(), $learn_data()),
      () => {
        set(target_R_day_values, $target_R_days().map((v3, i) => {
          var _a, _b;
          return [
            v3,
            (((_a = $data() === null || $data() === void 0 ? void 0 : $data().futureDue) === null || _a === void 0 ? void 0 : _a.futureDue[i]) || 0) - (((_b = $learn_data() === null || $learn_data() === void 0 ? void 0 : $learn_data().futureDue) === null || _b === void 0 ? void 0 : _b.futureDue[i]) || 0) - v3
          ];
        }));
      }
    );
    legacy_pre_effect(
      () => (EASE_COLOURS, i18n, get(target_R_day_values), get(normalize3), import_lodash18.default, formatRetention, totalCalc, barDateLabeler),
      () => {
        set(target_R_days_bar, {
          row_colours: [EASE_COLOURS[1], EASE_COLOURS[3]],
          // The EASE_COLOURS are in reverse order
          row_labels: [i18n("pass"), i18n("fail")],
          reverse_legend: true,
          data: get(target_R_day_values).map((values2, label) => ({
            values: get(normalize3) ? values2.map((a4) => a4 / import_lodash18.default.sum(values2)) : values2,
            label: label.toString()
          })),
          extraStats: get(normalize3) ? (bar) => [
            bar.values[0] ? formatRetention(bar.values[0]) : "No data"
          ] : totalCalc,
          columnLabeler: barDateLabeler,
          column_counts: !get(normalize3),
          precision: get(normalize3) ? 2 : 0
        });
      }
    );
    legacy_pre_effect_reset();
    init();
    var fragment = root20();
    var div = first_child(fragment);
    set_style(div, "--graph-width", `${width2}px`);
    set_style(div, "--graph-height", `${height2}px`);
    var h1 = sibling(child(div), 2);
    var text_1 = child(h1, true);
    reset(h1);
    var node = sibling(h1, 2);
    const expression = derived_safe_equal(() => i18n("future-due-types"));
    GraphCategory(node, {
      get hidden_title() {
        return get(expression);
      },
      config_name: "due",
      children: ($$anchor2, $$slotProps) => {
        var fragment_1 = root_113();
        var node_1 = first_child(fragment_1);
        GraphContainer(node_1, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_2 = root_210();
            var h1_1 = first_child(fragment_2);
            var text_2 = child(h1_1, true);
            reset(h1_1);
            var node_2 = sibling(h1_1, 2);
            {
              var consequent = ($$anchor4) => {
                const expression_1 = derived_safe_equal(() => $relearn_data()?.futureDue);
                DueBar($$anchor4, {
                  get all() {
                    return $data().futureDue;
                  },
                  get learn() {
                    return $learn_data().futureDue;
                  },
                  get mature() {
                    return $mature_data().futureDue;
                  },
                  get relearn() {
                    return get(expression_1);
                  }
                });
              };
              var alternate = ($$anchor4) => {
                NoGraph($$anchor4, {});
              };
              if_block(node_2, ($$render) => {
                if ($data()?.futureDue && $learn_data()?.futureDue && $mature_data()?.futureDue && $relearn_data()?.futureDue) $$render(consequent);
                else $$render(alternate, false);
              });
            }
            var p = sibling(node_2, 2);
            var text_3 = child(p, true);
            reset(p);
            template_effect(
              ($0, $1) => {
                set_text(text_2, $0);
                set_text(text_3, $1);
              },
              [
                () => i18n("future-due-types"),
                () => i18n("future-due-types-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_2);
          },
          $$slots: { default: true }
        });
        var node_3 = sibling(node_1, 2);
        GraphContainer(node_3, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_5 = root_57();
            var h1_2 = first_child(fragment_5);
            var text_4 = child(h1_2, true);
            reset(h1_2);
            var node_4 = sibling(h1_2, 2);
            {
              var consequent_1 = ($$anchor4) => {
                BarScrollable($$anchor4, {
                  get data() {
                    return get(target_R_days_bar);
                  },
                  left_aligned: true,
                  get average() {
                    return get(normalize3);
                  }
                });
              };
              var alternate_1 = ($$anchor4) => {
                NoGraph($$anchor4, {
                  children: ($$anchor5, $$slotProps3) => {
                    next();
                    var fragment_8 = root_83();
                    var text_5 = first_child(fragment_8);
                    var small = sibling(text_5);
                    var text_6 = child(small, true);
                    reset(small);
                    template_effect(
                      ($0, $1) => {
                        set_text(text_5, `${$0 ?? ""} `);
                        set_text(text_6, $1);
                      },
                      [
                        () => i18n("no-data"),
                        () => i18n("fsrs-only")
                      ],
                      derived_safe_equal
                    );
                    append($$anchor5, fragment_8);
                  },
                  $$slots: { default: true }
                });
              };
              if_block(node_4, ($$render) => {
                if (import_lodash18.default.sum($target_R_days()) > 0) $$render(consequent_1);
                else $$render(alternate_1, false);
              });
            }
            var label_1 = sibling(node_4, 2);
            var input = child(label_1);
            remove_input_defaults(input);
            var text_7 = sibling(input);
            reset(label_1);
            var p_1 = sibling(label_1, 2);
            var text_8 = child(p_1, true);
            reset(p_1);
            template_effect(
              ($0, $1, $2) => {
                set_text(text_4, $0);
                set_text(text_7, ` ${$1 ?? ""}`);
                set_text(text_8, $2);
              },
              [
                () => i18n("future-due-retention"),
                () => i18n("as-ratio"),
                () => i18n("future-due-retention-help")
              ],
              derived_safe_equal
            );
            bind_checked(input, () => get(normalize3), ($$value) => set(normalize3, $$value));
            append($$anchor3, fragment_5);
          },
          $$slots: { default: true }
        });
        var node_5 = sibling(node_3, 2);
        GraphContainer(node_5, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_9 = root_92();
            var h1_3 = first_child(fragment_9);
            var text_9 = child(h1_3, true);
            reset(h1_3);
            var node_6 = sibling(h1_3, 2);
            IntraDayDueBar(node_6, {});
            var p_2 = sibling(node_6, 2);
            var text_10 = child(p_2, true);
            reset(p_2);
            template_effect(
              ($0, $1) => {
                set_text(text_9, $0);
                set_text(text_10, $1);
              },
              [
                () => i18n("intra-day-due"),
                () => i18n("intra-day-due-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_9);
          },
          $$slots: { default: true }
        });
        append($$anchor2, fragment_1);
      },
      $$slots: { default: true }
    });
    var node_7 = sibling(node, 2);
    const expression_2 = derived_safe_equal(() => i18n("todays-retention"));
    GraphCategory(node_7, {
      get hidden_title() {
        return get(expression_2);
      },
      config_name: "misc",
      children: ($$anchor2, $$slotProps) => {
        var fragment_10 = root_102();
        var node_8 = first_child(fragment_10);
        GraphContainer(node_8, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_11 = root_114();
            var h1_4 = first_child(fragment_11);
            var text_11 = child(h1_4, true);
            reset(h1_4);
            var node_9 = sibling(h1_4, 2);
            {
              var consequent_2 = ($$anchor4) => {
                NoGraph($$anchor4, {
                  children: ($$anchor5, $$slotProps3) => {
                    next();
                    var text_12 = text("Placeholder");
                    append($$anchor5, text_12);
                  },
                  $$slots: { default: true }
                });
              };
              var alternate_2 = ($$anchor4) => {
                OldRetentionPie($$anchor4, {});
              };
              if_block(node_9, ($$render) => {
                if (false) $$render(consequent_2);
                else $$render(alternate_2, false);
              });
            }
            var p_3 = sibling(node_9, 2);
            var text_13 = child(p_3, true);
            reset(p_3);
            template_effect(
              ($0, $1) => {
                set_text(text_11, $0);
                set_text(text_13, $1);
              },
              [
                () => i18n("todays-retention"),
                () => i18n("todays-retention-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_11);
          },
          $$slots: { default: true }
        });
        var node_10 = sibling(node_8, 2);
        GraphContainer(node_10, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_14 = root_153();
            var h1_5 = first_child(fragment_14);
            var text_14 = child(h1_5, true);
            reset(h1_5);
            var node_11 = sibling(h1_5, 2);
            CustomPie(node_11, {});
            var p_4 = sibling(node_11, 2);
            var text_15 = child(p_4, true);
            reset(p_4);
            template_effect(
              ($0, $1) => {
                set_text(text_14, $0);
                set_text(text_15, $1);
              },
              [
                () => i18n("custom-pie"),
                () => i18n("custom-pie-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_14);
          },
          $$slots: { default: true }
        });
        var node_12 = sibling(node_10, 2);
        GraphContainer(node_12, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_15 = root_163();
            var h1_6 = first_child(fragment_15);
            var text_16 = child(h1_6, true);
            reset(h1_6);
            var node_13 = sibling(h1_6, 2);
            const expression_3 = derived_safe_equal(() => $data()?.reviews);
            DayTimings(node_13, {
              get data() {
                return get(expression_3);
              }
            });
            var p_5 = sibling(node_13, 2);
            var text_17 = child(p_5, true);
            reset(p_5);
            template_effect(
              ($0, $1) => {
                set_text(text_16, $0);
                set_text(text_17, $1);
              },
              [
                () => i18n("review-speed-trend"),
                () => i18n("review-speed-trend-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_15);
          },
          $$slots: { default: true }
        });
        var node_14 = sibling(node_12, 2);
        GraphContainer(node_14, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_16 = root_173();
            var h1_7 = first_child(fragment_16);
            var text_18 = child(h1_7, true);
            reset(h1_7);
            var node_15 = sibling(h1_7, 2);
            SRHeatmap(node_15, {
              get cardData() {
                return $card_data();
              },
              get searchString() {
                return $searchString();
              }
            });
            var p_6 = sibling(node_15, 2);
            var text_19 = child(p_6, true);
            reset(p_6);
            template_effect(
              ($0, $1) => {
                set_text(text_18, $0);
                set_text(text_19, $1);
              },
              [
                () => i18n("sxr-heatmap"),
                () => i18n("sxr-heatmap-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_16);
          },
          $$slots: { default: true }
        });
        append($$anchor2, fragment_10);
      },
      $$slots: { default: true }
    });
    var node_16 = sibling(node_7, 2);
    const expression_4 = derived_safe_equal(() => i18n("interval-distribution"));
    GraphCategory(node_16, {
      get hidden_title() {
        return get(expression_4);
      },
      config_name: "interval",
      children: ($$anchor2, $$slotProps) => {
        var fragment_17 = root_182();
        var node_17 = first_child(fragment_17);
        GraphContainer(node_17, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_18 = root_192();
            var h1_8 = first_child(fragment_18);
            var text_20 = child(h1_8, true);
            reset(h1_8);
            var node_18 = sibling(h1_8, 2);
            IntervalGraph(node_18, {
              get intervals() {
                return get(intervals);
              },
              get last() {
                return get(interval_last);
              },
              set last($$value) {
                set(interval_last, $$value);
              },
              get steps() {
                return get(interval_steps);
              },
              set steps($$value) {
                set(interval_steps, $$value);
              },
              $$legacy: true
            });
            var p_7 = sibling(node_18, 2);
            var text_21 = child(p_7, true);
            reset(p_7);
            template_effect(
              ($0, $1) => {
                set_text(text_20, $0);
                set_text(text_21, $1);
              },
              [
                () => i18n("interval-distribution"),
                () => i18n("interval-distribution-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_18);
          },
          $$slots: { default: true }
        });
        var node_19 = sibling(node_17, 2);
        GraphContainer(node_19, {
          children: ($$anchor3, $$slotProps2) => {
            var fragment_19 = root_202();
            var h1_9 = first_child(fragment_19);
            var text_22 = child(h1_9, true);
            reset(h1_9);
            var node_20 = sibling(h1_9, 2);
            BurdenPie(node_20, {
              get intervals() {
                return get(intervals);
              },
              get last() {
                return get(interval_last);
              },
              set last($$value) {
                set(interval_last, $$value);
              },
              get steps() {
                return get(interval_steps);
              },
              set steps($$value) {
                set(interval_steps, $$value);
              },
              $$legacy: true
            });
            var p_8 = sibling(node_20, 2);
            var text_23 = child(p_8, true);
            reset(p_8);
            template_effect(
              ($0, $1) => {
                set_text(text_22, $0);
                set_text(text_23, $1);
              },
              [
                () => i18n("interval-load"),
                () => i18n("interval-load-help")
              ],
              derived_safe_equal
            );
            append($$anchor3, fragment_19);
          },
          $$slots: { default: true }
        });
        append($$anchor2, fragment_17);
      },
      $$slots: { default: true }
    });
    var node_21 = sibling(node_16, 2);
    CardDataPies(node_21, {
      get cardData() {
        return $card_data();
      }
    });
    var node_22 = sibling(node_21, 2);
    {
      var consequent_4 = ($$anchor2) => {
        var fragment_20 = comment();
        var node_23 = first_child(fragment_20);
        {
          var consequent_3 = ($$anchor3) => {
            RevlogGraphs($$anchor3, {
              get revlogData() {
                return $revlogs();
              },
              get cardData() {
                return $card_data();
              },
              get addedCards() {
                return $data().added.added;
              }
            });
          };
          var alternate_3 = ($$anchor3) => {
            var h1_10 = root_232();
            var text_24 = child(h1_10, true);
            reset(h1_10);
            template_effect(($0) => set_text(text_24, $0), [() => i18n("preparing-review-stats")], derived_safe_equal);
            append($$anchor3, h1_10);
          };
          if_block(node_23, ($$render) => {
            if ($revlogs() && $card_data() && $data()?.added) $$render(consequent_3);
            else $$render(alternate_3, false);
          });
        }
        append($$anchor2, fragment_20);
      };
      var alternate_4 = ($$anchor2) => {
        GraphCategory($$anchor2, {
          children: ($$anchor3, $$slotProps) => {
            var div_1 = root_253();
            set_style(div_1, "grid-column", "1/-1");
            var node_24 = child(div_1);
            GraphContainer(node_24, {
              children: ($$anchor4, $$slotProps2) => {
                var div_2 = root_263();
                var node_25 = child(div_2);
                Warning(node_25, {
                  always: true,
                  children: ($$anchor5, $$slotProps3) => {
                    var fragment_23 = root_272();
                    var h1_11 = first_child(fragment_23);
                    var text_25 = child(h1_11, true);
                    reset(h1_11);
                    var text_26 = sibling(h1_11);
                    template_effect(
                      ($0, $1) => {
                        set_text(text_25, $0);
                        set_text(text_26, ` ${$1 ?? ""}`);
                      },
                      [
                        () => i18n("review-graphs-warning-title"),
                        () => i18n("review-graphs-warning")
                      ],
                      derived_safe_equal
                    );
                    append($$anchor5, fragment_23);
                  },
                  $$slots: { default: true }
                });
                var button = sibling(node_25, 2);
                var text_27 = child(button, true);
                reset(button);
                var span = sibling(button, 2);
                var text_28 = child(span, true);
                reset(span);
                reset(div_2);
                template_effect(
                  ($0, $1) => {
                    set_text(text_27, $0);
                    set_text(text_28, $1);
                  },
                  [
                    () => i18n("review-graphs-prepare-graphs"),
                    () => i18n("review-graphs-config-hint")
                  ],
                  derived_safe_equal
                );
                event("click", button, () => store_set(showRevlogStats, true));
                append($$anchor4, div_2);
              },
              $$slots: { default: true }
            });
            reset(div_1);
            append($$anchor3, div_1);
          },
          $$slots: { default: true }
        });
      };
      if_block(node_22, ($$render) => {
        if ($showRevlogStats()) $$render(consequent_4);
        else $$render(alternate_4, false);
      });
    }
    reset(div);
    var div_3 = sibling(div, 2);
    each(div_3, 5, () => $tooltip()?.text ?? [], index, ($$anchor2, text2) => {
      var fragment_24 = root_282();
      var span_1 = first_child(fragment_24);
      var text_29 = child(span_1, true);
      reset(span_1);
      next(2);
      template_effect(() => set_text(text_29, get(text2)));
      append($$anchor2, fragment_24);
    });
    reset(div_3);
    template_effect(
      ($0) => {
        set_text(text_1, $0);
        set_style(div_3, "opacity", $tooltipShown() ? 1 : 0);
        set_style(div_3, "left", `${$tooltip().x}px`);
        set_style(div_3, "top", `${$tooltip().y}px`);
      },
      [() => i18n("title-search-stats-extended")],
      derived_safe_equal
    );
    append($$anchor, fragment);
    pop();
    $$cleanup();
  }

  // src/ts/index.ts
  patchFetch();
  config.set(SSEconfig);
  other.set(SSEother);
  setTimeout(() => mount(Root, { target: document.body }), SSEconfig.loadDelayMs ?? 100);
  var style = document.createElement("style");
  style.innerHTML = css;
  document.head.appendChild(style);
})();
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
